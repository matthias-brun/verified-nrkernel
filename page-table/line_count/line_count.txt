    Finished release [optimized] target(s) in 0.04s
     Running `/Users/utaal/Src/verus/source/target/release/line_count -p /Users/utaal/Src/verified-nrkernel/page-table/lib.d`
Category           | Detailed contents              | 

# lib.rs
                   |                                | #![feature(nonnull_slice_from_raw_parts)]
                   |                                | extern crate alloc;
                   |                                | 
                   |                                | pub mod impl_u;
                   |                                | pub mod definitions_t;
                   |                                | pub mod definitions_u;
                   |                                | pub mod spec_t;
                   |                                | pub mod extra;
                   |                                | 
                   |                                | use vstd::prelude::verus;
                   |                                | 
                   |                                | verus!{
                   |                                | 
                   |                                | global size_of usize == 8;
                   |                                | 
                   |                                | }
                   |                                | 
                   |                                | #[cfg(feature = "more")]
                   |                                | pub mod hlspec_user;
                   |                                | #[cfg(feature = "more")]
                   |                                | pub mod os_trace;

# impl_u/mod.rs
Comment            | Comment                        | //#[cfg(feature = "impl")]
Comment            | Comment                        | //pub mod l0;
Comment            | Comment                        | //#[cfg(feature = "impl")]
Comment            | Comment                        | //pub mod l1;
Comment            | Comment                        | //#[cfg(feature = "impl")]
Comment            | Comment                        | //pub mod l2_impl;
Comment            | Comment                        | //#[cfg(feature = "impl")]
Comment            | Comment                        | //pub mod l2_refinement;
                   |                                | pub mod spec_pt;
Comment            | Comment                        | //pub mod indexing;
                   |                                | pub mod os_refinement;

# impl_u/spec_pt.rs
                   |                                | #![verus::trusted]
                   |                                | use vstd::prelude::*;
                   |                                | 
                   |                                | use crate::definitions_t::{candidate_mapping_overlaps_existing_vmem, PageTableEntry};
                   |                                | use crate::spec_t::hardware;
                   |                                | use crate::spec_t::mem;
                   |                                | 
Comment            | Comment                        | // trusted: not trusted
Comment            | Comment                        | // the interface spec is written in such a way that it guarantees that the impl behaves according
Comment            | Comment                        | // to the state machine, and then in the OS state machine we use these definitions, but the actual
Comment            | Comment                        | // content of these definitions does not matter because:
Comment            | Comment                        | //
Comment            | Comment                        | // if we were to mis-specify things in this file, we wouldn't be able to prove the state machine
Comment            | Comment                        | // refinement
Comment            | Comment                        | //
Comment            | Comment                        | // if we split impl <-> system state machines, this becomes trusted for the impl
                   |                                | verus! {
                   |                                | 
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Comment            | Comment                        | // State
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Trusted            | DatatypeDecl                   | pub struct PageTableVariables {
Trusted            | DatatypeDecl                   |     pub pt_mem: mem::PageTableMemory,
Trusted            | DatatypeDecl                   | }
                   |                                | 
Comment            | Comment                        | // Assume `ViewStutter` is any write, that doesn't change the view of the page table memory.
Comment            | Comment                        | // Then, mapping an entry is a sequence that matches: `(Read | ViewStutter)* Write`
Comment            | Comment                        | // (Reading, inserting empty directories and finally mapping the entry with a view-affecting write)
Comment            | Comment                        | // and unmapping an entry is a sequence that matches: `Read* (Write (Read | ViewStutter)*)?`
Comment            | Comment                        | // (Reading to traverse the tree, then if the entry exists, unmapping it with a view-affecting
Comment            | Comment                        | // write and unmapping zero or more, now-empty directories)
Trusted            | DatatypeDecl                   | pub enum ThreadState {
Trusted            | DatatypeDecl                   |     Idle,
Trusted            | DatatypeDecl                   |     Mapping,
Comment            | Comment                        |     /// `result` is `Some`, as soon as the "main" step of unmapping has happened, i.e. either
Comment            | Comment                        |     /// removal of the mapped frame, or determination that result is an error
Trusted            | DatatypeDecl                   |     Unmapping { result: Result<PageTableEntry, ()> },
Trusted            | DatatypeDecl                   | }
                   |                                | 
                   | Impl                           | impl PageTableVariables {
Comment            | Comment                        |     /// Interpretation of the memory according to the MMU's semantics.
Trusted            | Code(S Impl Signat Body(S      |     pub open spec fn interp(self) -> Map<nat, PageTableEntry> {
Trusted            | Code(Spec Impl Body(Spec       |         hardware::interp_pt_mem(self.pt_mem)
Trusted            | Code(Spec Impl Body(Spec       |     }
                   | Impl                           | }
                   |                                | 
Trusted            | DatatypeDecl Directive         | #[allow(inconsistent_fields)]
Trusted            | DatatypeDecl                   | pub enum PageTableStep {
Trusted            | DatatypeDecl                   |     MapStart { vaddr: nat, pte: PageTableEntry },
Trusted            | DatatypeDecl                   |     MapEnd { vaddr: nat, pte: PageTableEntry, result: Result<(), ()> },
Trusted            | DatatypeDecl                   |     UnmapStart { vaddr: nat, result: Result<(), ()> },
Trusted            | DatatypeDecl                   |     UnmapEnd,
Trusted            | DatatypeDecl                   |     ViewStutter,
Trusted            | DatatypeDecl                   |     Stutter,
Trusted            | DatatypeDecl                   | }
                   |                                | 
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Comment            | Comment                        | // Map
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Trusted            | Signature(Spec)                | pub open spec fn step_Map_Start(
Trusted            | Signature(Spec)                |     s1: PageTableVariables,
Trusted            | Signature(Spec)                |     s2: PageTableVariables,
Trusted            | Signature(Spec)                |     vaddr: nat,
Trusted            | Signature(Spec)                |     pte: PageTableEntry,
Trusted            | Code(Spec Signature Body(Spec  | ) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     &&& s2 == s1
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Signature(Spec)                | pub open spec fn step_Map_End(
Trusted            | Signature(Spec)                |     s1: PageTableVariables,
Trusted            | Signature(Spec)                |     s2: PageTableVariables,
Trusted            | Signature(Spec)                |     vaddr: nat,
Trusted            | Signature(Spec)                |     pte: PageTableEntry,
Trusted            | Signature(Spec)                |     result: Result<(), ()>,
Trusted            | Code(Spec Signature Body(Spec  | ) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     if candidate_mapping_overlaps_existing_vmem(s1.interp(), vaddr, pte) {
Trusted            | Code(Spec) Body(Spec)          |         &&& result is Err
Trusted            | Code(Spec) Body(Spec)          |         &&& s2.interp() == s1.interp()
Trusted            | Code(Spec) Body(Spec)          |     } else {
Trusted            | Code(Spec) Body(Spec)          |         &&& result is Ok
Trusted            | Code(Spec) Body(Spec)          |         &&& s2.interp() == s1.interp().insert(vaddr, pte)
Trusted            | Code(Spec) Body(Spec)          |     }
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Comment            | Comment                        | // Unmap
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Trusted            | Signature(Spec)                | pub open spec fn step_Unmap_Start(
Trusted            | Signature(Spec)                |     s1: PageTableVariables,
Trusted            | Signature(Spec)                |     s2: PageTableVariables,
Trusted            | Signature(Spec)                |     vaddr: nat,
Trusted            | Signature(Spec)                |     result: Result<(), ()>,
Trusted            | Code(Spec Signature Body(Spec  | ) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     if s1.interp().dom().contains(vaddr) {
Trusted            | Code(Spec) Body(Spec)          |         &&& result is Ok
Trusted            | Code(Spec) Body(Spec)          |         &&& s2.interp() == s1.interp().remove(vaddr)
Trusted            | Code(Spec) Body(Spec)          |     } else {
Trusted            | Code(Spec) Body(Spec)          |         &&& result is Err
Trusted            | Code(Spec) Body(Spec)          |         &&& s2.interp() == s1.interp()
Trusted            | Code(Spec) Body(Spec)          |     }
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Signature(Spec)                | pub open spec fn step_Unmap_End(
Trusted            | Signature(Spec)                |     s1: PageTableVariables,
Trusted            | Signature(Spec)                |     s2: PageTableVariables,
Trusted            | Code(Spec Signature Body(Spec  | ) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     &&& s2 == s1
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Comment            | Comment                        | // Stutter
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Trusted            | Code(Spec Signature Body(Spec  | pub open spec fn step_Stutter(s1: PageTableVariables, s2: PageTableVariables) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     s1 == s2
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Signature(Spec)                | pub open spec fn step_View_Stutter(
Trusted            | Signature(Spec)                |     s1: PageTableVariables,
Trusted            | Signature(Spec)                |     s2: PageTableVariables,
Trusted            | Code(Spec Signature Body(Spec  | ) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.interp() == s1.interp()
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Comment            | Comment                        | // Init
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Trusted            | Code(Spec Signature Body(Spec  | pub open spec fn init(s: PageTableVariables) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     &&& s.pt_mem.inv()
Trusted            | Code(Spec) Body(Spec)          |     &&& s.pt_mem.regions() === set![s.pt_mem.cr3_spec()@]
Trusted            | Code(Spec) Body(Spec)          |     &&& s.pt_mem.region_view(s.pt_mem.cr3_spec()@).len() == 512
Trusted            | Code(Spec) Body(Spec)          |     &&& (forall|i: nat| i < 512 ==> s.pt_mem.region_view(s.pt_mem.cr3_spec()@)[i as int] == 0)
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Comment            | Comment                        | // Next_Step
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Trusted            | Signature(Spec)                | pub open spec fn next_step(
Trusted            | Signature(Spec)                |     s1: PageTableVariables,
Trusted            | Signature(Spec)                |     s2: PageTableVariables,
Trusted            | Signature(Spec)                |     step: PageTableStep,
Trusted            | Code(Spec Signature Body(Spec  | ) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     match step {
Trusted            | Code(Spec) Body(Spec)          |         PageTableStep::MapStart { vaddr, pte }       => step_Map_Start(s1, s2, vaddr, pte),
Trusted            | Code(Spec) Body(Spec)          |         PageTableStep::MapEnd { vaddr, pte, result } => step_Map_End(s1, s2, vaddr, pte, result),
Trusted            | Code(Spec) Body(Spec)          |         PageTableStep::UnmapStart { vaddr, result }  => step_Unmap_Start(s1, s2, vaddr, result),
Trusted            | Code(Spec) Body(Spec)          |         PageTableStep::UnmapEnd                      => step_Unmap_End(s1, s2),
Trusted            | Code(Spec) Body(Spec)          |         PageTableStep::ViewStutter                   => step_View_Stutter(s1, s2),
Trusted            | Code(Spec) Body(Spec)          |         PageTableStep::Stutter                       => step_Stutter(s1, s2),
Trusted            | Code(Spec) Body(Spec)          |     }
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Code(Spec Signature Body(Spec  | pub open spec fn next(s1: PageTableVariables, s2: PageTableVariables) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     exists|step: PageTableStep| next_step(s1, s2, step)
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
                   |                                | } // verus!

# impl_u/os_refinement.rs
                   |                                | use vstd::prelude::*;
                   |                                | 
Comment            | Comment                        | //use crate::impl_u::spec_pt;
Comment            | Comment                        | //use crate::spec_t::hardware::Core;
                   |                                | use crate::definitions_t::{
                   |                                |     above_zero, aligned, between, candidate_mapping_overlaps_existing_pmem,
                   |                                |     candidate_mapping_overlaps_existing_vmem, overlap, HWLoadResult, HWRWOp, HWStoreResult,
                   |                                |     LoadResult, MemRegion, PageTableEntry, RWOp, StoreResult, WORD_SIZE,
                   |                                | };
                   |                                | use crate::spec_t::hlproof::lemma_mem_domain_from_mappings;
                   |                                | use crate::spec_t::os_invariant::{
                   |                                |     lemma_candidate_mapping_inflight_pmem_overlap_hl_implies_os,
                   |                                |     lemma_candidate_mapping_inflight_pmem_overlap_os_implies_hl,
                   |                                |     lemma_candidate_mapping_inflight_vmem_overlap_hl_implies_os,
                   |                                |     lemma_candidate_mapping_inflight_vmem_overlap_os_implies_hl, next_step_preserves_inv,
                   |                                | };
                   |                                | use crate::spec_t::{hardware, hlspec, mem, os};
                   |                                | use crate::extra::result_map_ok;
                   |                                | 
                   |                                | verus! {
                   |                                | 
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Comment            | Comment                        | // Lemmata
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Proof              | Signature(Proof)               | proof fn lemma_inflight_vaddr_equals_hl_unmap(c: os::OSConstants, s: os::OSVariables)
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         s.basic_inv(c),
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         forall|v_addr|
Spec               | Signature(Proo FunctionSpec    |             s.inflight_unmap_vaddr().contains(v_addr) <==> exists|thread_state|
Spec               | Signature(Proo FunctionSpec    |                 {
Spec               | Signature(Proo FunctionSpec    |                     &&& s.interp_thread_state(c).values().contains(thread_state)
Spec               | Signature(Proo FunctionSpec    |                     &&& s.interp_pt_mem().dom().contains(v_addr)
Spec               | Signature(Proo FunctionSpec    |                     &&& thread_state matches hlspec::AbstractArguments::Unmap { vaddr, .. }
Spec               | Signature(Proo FunctionSpec    |                     &&& vaddr === v_addr
Spec               | Signature(Proo FunctionSpec    |                 },
Proof              | Code(Proof) Body(Proof)        | {
Comment            | Comment                        |     // proof ==> direction
Proof              | Code(Proo ProofDire Body(Proo  |     assert forall|v_addr| s.inflight_unmap_vaddr().contains(v_addr) implies exists|thread_state|
Proof              | Code(Proo ProofDire Body(Proo  |         {
Proof              | Code(Proo ProofDire Body(Proo  |             &&& s.interp_thread_state(c).values().contains(thread_state)
Proof              | Code(Proo ProofDire Body(Proo  |             &&& s.interp_pt_mem().dom().contains(v_addr)
Proof              | Code(Proo ProofDire Body(Proo  |             &&& thread_state matches hlspec::AbstractArguments::Unmap { vaddr, .. }
Proof              | Code(Proo ProofDire Body(Proo  |             &&& vaddr === v_addr
Proof              | Code(Proo ProofDire Body(Proo  |         } by {
Proof              | Code(Proo ProofDire Body(Proo  |         let core = choose|core|
Proof              | Code(Proo ProofDire Body(Proo  |             {
Proof              | Code(Proo ProofDire Body(Proo  |                 &&& s.core_states.dom().contains(core)
Proof              | Code(Proo ProofDire Body(Proo  |                 &&& ({
Proof              | Code(Proo ProofDire Body(Proo  |                     &&& s.core_states[core] matches os::CoreState::UnmapWaiting { vaddr, .. }
Proof              | Code(Proo ProofDire Body(Proo  |                     &&& vaddr == v_addr
Proof              | Code(Proo ProofDire Body(Proo  |                 } || {
Proof              | Code(Proo ProofDire Body(Proo  |                     &&& s.core_states[core] matches os::CoreState::UnmapOpExecuting { vaddr, .. }
Proof              | Code(Proo ProofDire Body(Proo  |                     &&& vaddr == v_addr
Proof              | Code(Proo ProofDire Body(Proo  |                 } || {
Proof              | Code(Proo ProofDire Body(Proo  |                     &&& s.core_states[core] matches os::CoreState::UnmapOpDone { vaddr, .. }
Proof              | Code(Proo ProofDire Body(Proo  |                     &&& vaddr == v_addr
Proof              | Code(Proo ProofDire Body(Proo  |                 } || {
Proof              | Code(Proo ProofDire Body(Proo  |                     &&& s.core_states[core] matches os::CoreState::UnmapShootdownWaiting {
Proof              | Code(Proo ProofDire Body(Proo  |                         vaddr,
Proof              | Code(Proo ProofDire Body(Proo  |                         ..
Proof              | Code(Proo ProofDire Body(Proo  |                     }
Proof              | Code(Proo ProofDire Body(Proo  |                     &&& vaddr == v_addr
Proof              | Code(Proo ProofDire Body(Proo  |                 })
Proof              | Code(Proo ProofDire Body(Proo  |             };
Comment            | Comment                        |         //assert(hardware::valid_core(c.hw, core));
Proof              | Code(Proo ProofDire Body(Proo  |         match s.core_states[core] {
Proof              | Code(Proo ProofDire Body(Proo  |             os::CoreState::UnmapWaiting { ULT_id, vaddr }
Proof              | Code(Proo ProofDire Body(Proo  |             | os::CoreState::UnmapOpExecuting { ULT_id, vaddr, .. }
Proof              | Code(Proo ProofDire Body(Proo  |             | os::CoreState::UnmapOpDone { ULT_id, vaddr, .. }
Proof              | Code(Proo ProofDire Body(Proo  |             | os::CoreState::UnmapShootdownWaiting { ULT_id, vaddr, .. } => {
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(s.interp_thread_state(c).dom().contains(ULT_id));
Proof              | Code(Proo ProofDire Body(Proo  |                 let thread_state = s.interp_thread_state(c)[ULT_id];
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(s.interp_thread_state(c).values().contains(thread_state));
Proof              | Code(Proo ProofDire Body(Proo  |             },
Proof              | Code(Proo ProofDire Body(Proo  |             _ => {
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(false);
Proof              | Code(Proo ProofDire Body(Proo  |             },
Proof              | Code(Proo ProofDire Body(Proo  |         }
Proof              | Code(Proo ProofDire Body(Proo  |     };
Comment            | Comment                        |     // proof  <== diretion
Proof              | Code(Proo ProofDire Body(Proo  |     assert forall|v_addr|
Proof              | Code(Proo ProofDire Body(Proo  |         exists|thread_state|
Proof              | Code(Proo ProofDire Body(Proo  |             {
Proof              | Code(Proo ProofDire Body(Proo  |                 &&& s.interp_thread_state(c).values().contains(thread_state)
Proof              | Code(Proo ProofDire Body(Proo  |                 &&& s.interp_pt_mem().dom().contains(v_addr)
Proof              | Code(Proo ProofDire Body(Proo  |                 &&& thread_state matches hlspec::AbstractArguments::Unmap { vaddr, .. }
Proof              | Code(Proo ProofDire Body(Proo  |                 &&& vaddr === v_addr
Proof              | Code(Proo ProofDire Body(Proo  |             } implies s.inflight_unmap_vaddr().contains(v_addr) by {
Proof              | Code(Proo ProofDire Body(Proo  |         let thread_state = choose|thread_state|
Proof              | Code(Proo ProofDire Body(Proo  |             {
Proof              | Code(Proo ProofDire Body(Proo  |                 &&& s.interp_thread_state(c).values().contains(thread_state)
Proof              | Code(Proo ProofDire Body(Proo  |                 &&& thread_state matches hlspec::AbstractArguments::Unmap { vaddr, pte }
Proof              | Code(Proo ProofDire Body(Proo  |                 &&& vaddr == v_addr
Proof              | Code(Proo ProofDire Body(Proo  |             };
Proof              | Code(Proo ProofDire Body(Proo  |         let ULT_id = choose|id| #[trigger]
Proof              | Code(Proo ProofDire Body(Proo  |             s.interp_thread_state(c).dom().contains(id) && s.interp_thread_state(c)[id]
Proof              | Code(Proo ProofDire Body(Proo  |                 === thread_state;
Proof              | Code(Proo ProofDire Body(Proo  |         assert(s.core_states.dom().contains(c.ULT2core[ULT_id]));
Proof              | Code(Proo ProofDire Body(Proo  |     };
Layout             | Code(Proof) Body(Proof)        | 
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Proof              | Signature(Proof)               | proof fn lemma_effective_mappings_unaffected_if_thread_state_constant(
Proof              | Signature(Proof)               |     c: os::OSConstants,
Proof              | Signature(Proof)               |     s1: os::OSVariables,
Proof              | Signature(Proof)               |     s2: os::OSVariables,
Proof              | Signature(Proof)               | )
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         s1.basic_inv(c),
Spec               | Signature(Proo FunctionSpec    |         s2.basic_inv(c),
Spec               | Signature(Proo FunctionSpec    |         s1.interp_thread_state(c) === s2.interp_thread_state(c),
Spec               | Signature(Proo FunctionSpec    |         s1.interp_pt_mem() === s2.interp_pt_mem(),
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         s1.effective_mappings() === s2.effective_mappings(),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proof) Body(Proof)        |     lemma_inflight_vaddr_equals_hl_unmap(c, s1);
Proof              | Code(Proof) Body(Proof)        |     lemma_inflight_vaddr_equals_hl_unmap(c, s2);
Proof              | Code(Proo ProofDire Body(Proo  |     assert(s2.inflight_unmap_vaddr() =~= s1.inflight_unmap_vaddr());
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Comment            | Comment                        | // Map lemmata
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Proof              | Signature(Proof)               | pub proof fn map_values_contain_value_of_contained_key<A, B>(map: Map<A, B>, key: A)
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         map.dom().contains(key),
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         map.values().contains(map[key]),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Proof              | Signature(Proof)               | proof fn lemma_map_insert_value<A, B>(map: Map<A, B>, key: A, value: B)
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         map.insert(key, value).values().contains(value),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proo ProofDire Body(Proo  |     assert(map.insert(key, value).dom().contains(key));
Proof              | Code(Proo ProofDire Body(Proo  |     assert(map.insert(key, value)[key] == value);
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Proof              | Signature(Proof)               | pub proof fn lemma_map_insert_values_equality<A, B>(map: Map<A, B>, key: A, value: B)
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         map.dom().contains(key),
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         map.values().insert(value) === map.insert(key, value).values().insert(map.index(key)),
Proof              | Code(Proof) Body(Proof)        | {
Comment            | Comment                        |     //
Proof              | Code(Proo ProofDire Body(Proo  |     assert forall|values| #![auto] map.values().insert(value).contains(values) implies map.insert(
Proof              | Code(Proo ProofDire Body(Proo  |         key,
Proof              | Code(Proo ProofDire Body(Proo  |         value,
Proof              | Code(Proo ProofDire Body(Proo  |     ).values().insert(map.index(key)).contains(values) by {
Proof              | Code(Proo ProofDire Body(Proo  |         if (values == value) {
Proof              | Code(Proo ProofDire Body(Proo  |             lemma_map_insert_value(map, key, value);
Proof              | Code(Proo ProofDire Body(Proo  |         } else {
Proof              | Code(Proo ProofDire Body(Proo  |             let k = choose|some_key| #[trigger]
Proof              | Code(Proo ProofDire Body(Proo  |                 map.dom().contains(some_key) && (map[some_key] == values);
Proof              | Code(Proo ProofDire Body(Proo  |             assert(map.insert(key, value).dom().contains(k));
Proof              | Code(Proo ProofDire Body(Proo  |             if (k == key) {
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(map.index(key) == values);
Proof              | Code(Proo ProofDire Body(Proo  |             } else {
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(map[k] === map.insert(key, value)[k]);
Proof              | Code(Proo ProofDire Body(Proo  |             }
Proof              | Code(Proo ProofDire Body(Proo  |         }
Proof              | Code(Proo ProofDire Body(Proo  |     }
Proof              | Code(Proo ProofDire Body(Proo  |     assert(map.values().insert(value) =~= map.insert(key, value).values().insert(map.index(key)));
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Comment            | Comment                        | // soundness lemmata
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Proof              | Signature(Proof)               | proof fn lemma_map_soundness_equality(
Proof              | Signature(Proof)               |     c: os::OSConstants,
Proof              | Signature(Proof)               |     s: os::OSVariables,
Proof              | Signature(Proof)               |     vaddr: nat,
Proof              | Signature(Proof)               |     pte: PageTableEntry,
Proof              | Signature(Proof)               | )
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         s.basic_inv(c),
Spec               | Signature(Proo FunctionSpec    |         above_zero(pte.frame.size),
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         hlspec::step_Map_sound(s.interp(c).mappings, s.interp(c).thread_state.values(), vaddr, pte)
Spec               | Signature(Proo FunctionSpec    |             <==> os::step_Map_sound(s.interp_pt_mem(), s.core_states.values(), vaddr, pte),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proof) Body(Proof)        |     lemma_candidate_mapping_inflight_vmem_overlap_hl_implies_os(c, s, vaddr, pte.frame.size);
Proof              | Code(Proof) Body(Proof)        |     lemma_candidate_mapping_inflight_vmem_overlap_os_implies_hl(c, s, vaddr, pte.frame.size);
Proof              | Code(Proof) Body(Proof)        |     lemma_candidate_mapping_inflight_pmem_overlap_hl_implies_os(c, s, pte);
Proof              | Code(Proof) Body(Proof)        |     lemma_candidate_mapping_inflight_pmem_overlap_os_implies_hl(c, s, pte);
Proof              | Code(Proo ProofDire Body(Proo  |     assert(candidate_mapping_overlaps_existing_pmem(s.interp(c).mappings, pte)
Proof              | Code(Proo ProofDire Body(Proo  |         ==> candidate_mapping_overlaps_existing_pmem(s.interp_pt_mem(), pte));
Layout             | Code(Proof) Body(Proof)        | 
Proof              | Code(Proo ProofDire Body(Proo  |     assert(candidate_mapping_overlaps_existing_pmem(s.interp_pt_mem(), pte) ==> (
Proof              | Code(Proo ProofDire Body(Proo  |     candidate_mapping_overlaps_existing_pmem(s.interp(c).mappings, pte)
Proof              | Code(Proo ProofDire Body(Proo  |         || hlspec::candidate_mapping_overlaps_inflight_pmem(
Proof              | Code(Proo ProofDire Body(Proo  |         s.interp(c).thread_state.values(),
Proof              | Code(Proo ProofDire Body(Proo  |         pte,
Proof              | Code(Proo ProofDire Body(Proo  |     ))) by {
Proof              | Code(Proo ProofDire Body(Proo  |         if candidate_mapping_overlaps_existing_pmem(s.interp_pt_mem(), pte) {
Proof              | Code(Proo ProofDire Body(Proo  |             if (!os::candidate_mapping_overlaps_inflight_pmem(
Proof              | Code(Proo ProofDire Body(Proo  |                 s.interp_pt_mem(),
Proof              | Code(Proo ProofDire Body(Proo  |                 s.core_states.values(),
Proof              | Code(Proo ProofDire Body(Proo  |                 pte,
Proof              | Code(Proo ProofDire Body(Proo  |             )) {
Proof              | Code(Proo ProofDire Body(Proo  |                 let base = choose|b: nat|
Proof              | Code(Proo ProofDire Body(Proo  |                     #![auto]
Proof              | Code(Proo ProofDire Body(Proo  |                     {
Proof              | Code(Proo ProofDire Body(Proo  |                         &&& s.interp_pt_mem().dom().contains(b)
Proof              | Code(Proo ProofDire Body(Proo  |                         &&& overlap(pte.frame, s.interp_pt_mem().index(b).frame)
Proof              | Code(Proo ProofDire Body(Proo  |                     };
Proof              | Code(Proo ProofDire Body(Proo  |                 if (!s.inflight_unmap_vaddr().contains(base)) {
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(s.effective_mappings().dom().contains(base));
Layout             | Code(Proo ProofDire Body(Proo  | 
Proof              | Code(Proo ProofDire Body(Proo  |                 } else {
Proof              | Code(Proo ProofDire Body(Proo  |                     let core = choose|core|
Proof              | Code(Proo ProofDire Body(Proo  |                         s.core_states.dom().contains(core) && match s.core_states[core] {
Proof              | Code(Proo ProofDire Body(Proo  |                             os::CoreState::UnmapWaiting { ULT_id, vaddr }
Proof              | Code(Proo ProofDire Body(Proo  |                             | os::CoreState::UnmapOpExecuting { ULT_id, vaddr, .. }
Proof              | Code(Proo ProofDire Body(Proo  |                             | os::CoreState::UnmapOpDone { ULT_id, vaddr, .. }
Proof              | Code(Proo ProofDire Body(Proo  |                             | os::CoreState::UnmapShootdownWaiting { ULT_id, vaddr, .. } => {
Proof              | Code(Proo ProofDire Body(Proo  |                                 vaddr === base
Proof              | Code(Proo ProofDire Body(Proo  |                             },
Proof              | Code(Proo ProofDire Body(Proo  |                             _ => false,
Proof              | Code(Proo ProofDire Body(Proo  |                         };
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(s.core_states.values().contains(s.core_states.index(core)));
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(os::candidate_mapping_overlaps_inflight_pmem(
Proof              | Code(Proo ProofDire Body(Proo  |                         s.interp_pt_mem(),
Proof              | Code(Proo ProofDire Body(Proo  |                         s.core_states.values(),
Proof              | Code(Proo ProofDire Body(Proo  |                         pte,
Proof              | Code(Proo ProofDire Body(Proo  |                     ));
Proof              | Code(Proo ProofDire Body(Proo  |                 }
Proof              | Code(Proo ProofDire Body(Proo  |             } else {
Proof              | Code(Proo ProofDire Body(Proo  |             }
Proof              | Code(Proo ProofDire Body(Proo  |         } else {
Proof              | Code(Proo ProofDire Body(Proo  |         }
Proof              | Code(Proo ProofDire Body(Proo  |     }
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Proof              | Signature(Proof)               | proof fn lemma_unmap_soundness_equality(
Proof              | Signature(Proof)               |     c: os::OSConstants,
Proof              | Signature(Proof)               |     s: os::OSVariables,
Proof              | Signature(Proof)               |     vaddr: nat,
Proof              | Signature(Proof)               |     pte_size: nat,
Proof              | Signature(Proof)               | )
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         s.basic_inv(c),
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         hlspec::step_Unmap_sound(s.interp(c).thread_state.values(), vaddr, pte_size)
Spec               | Signature(Proo FunctionSpec    |             <==> os::step_Unmap_sound(s.interp_pt_mem(), s.core_states.values(), vaddr, pte_size),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proof) Body(Proof)        |     lemma_candidate_mapping_inflight_vmem_overlap_hl_implies_os(c, s, vaddr, pte_size);
Proof              | Code(Proof) Body(Proof)        |     lemma_candidate_mapping_inflight_vmem_overlap_os_implies_hl(c, s, vaddr, pte_size);
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Proof              | Signature(Proof)               | proof fn lemma_os_overlap_vmem_implies_hl_or_inflight_overlap_vmem(
Proof              | Signature(Proof)               |     c: os::OSConstants,
Proof              | Signature(Proof)               |     s: os::OSVariables,
Proof              | Signature(Proof)               |     vaddr: nat,
Proof              | Signature(Proof)               |     pte: PageTableEntry,
Proof              | Signature(Proof)               | )
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         s.basic_inv(c),
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         candidate_mapping_overlaps_existing_vmem(s.interp_pt_mem(), vaddr, pte)
Spec               | Signature(Proo FunctionSpec    |             ==> candidate_mapping_overlaps_existing_vmem(s.interp(c).mappings, vaddr, pte)
Spec               | Signature(Proo FunctionSpec    |             || hlspec::candidate_mapping_overlaps_inflight_vmem(
Spec               | Signature(Proo FunctionSpec    |             s.interp(c).thread_state.values(),
Spec               | Signature(Proo FunctionSpec    |             vaddr,
Spec               | Signature(Proo FunctionSpec    |             pte.frame.size,
Spec               | Signature(Proo FunctionSpec    |         ),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proof) Body(Proof)        |     let pte_size = pte.frame.size;
Proof              | Code(Proo ProofDire Body(Proo  |     assert(candidate_mapping_overlaps_existing_vmem(s.interp_pt_mem(), vaddr, pte) ==> (
Proof              | Code(Proo ProofDire Body(Proo  |     candidate_mapping_overlaps_existing_vmem(s.interp(c).mappings, vaddr, pte)
Proof              | Code(Proo ProofDire Body(Proo  |         || hlspec::candidate_mapping_overlaps_inflight_vmem(
Proof              | Code(Proo ProofDire Body(Proo  |         s.interp(c).thread_state.values(),
Proof              | Code(Proo ProofDire Body(Proo  |         vaddr,
Proof              | Code(Proo ProofDire Body(Proo  |         pte_size,
Proof              | Code(Proo ProofDire Body(Proo  |     ))) by {
Proof              | Code(Proo ProofDire Body(Proo  |         if candidate_mapping_overlaps_existing_vmem(s.interp_pt_mem(), vaddr, pte) {
Proof              | Code(Proo ProofDire Body(Proo  |             if (!os::candidate_mapping_overlaps_inflight_vmem(
Proof              | Code(Proo ProofDire Body(Proo  |                 s.interp_pt_mem(),
Proof              | Code(Proo ProofDire Body(Proo  |                 s.core_states.values(),
Proof              | Code(Proo ProofDire Body(Proo  |                 vaddr,
Proof              | Code(Proo ProofDire Body(Proo  |                 pte_size,
Proof              | Code(Proo ProofDire Body(Proo  |             )) {
Proof              | Code(Proo ProofDire Body(Proo  |                 let base = choose|b: nat|
Proof              | Code(Proo ProofDire Body(Proo  |                     #![auto]
Proof              | Code(Proo ProofDire Body(Proo  |                     {
Proof              | Code(Proo ProofDire Body(Proo  |                         &&& s.interp_pt_mem().dom().contains(b)
Proof              | Code(Proo ProofDire Body(Proo  |                         &&& overlap(
Proof              | Code(Proo ProofDire Body(Proo  |                             MemRegion { base: vaddr, size: pte_size },
Proof              | Code(Proo ProofDire Body(Proo  |                             MemRegion { base: b, size: s.interp_pt_mem()[b].frame.size },
Proof              | Code(Proo ProofDire Body(Proo  |                         )
Proof              | Code(Proo ProofDire Body(Proo  |                     };
Proof              | Code(Proo ProofDire Body(Proo  |                 if (!s.inflight_unmap_vaddr().contains(base)) {
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(s.effective_mappings().dom().contains(base));
Proof              | Code(Proo ProofDire Body(Proo  |                 } else {
Proof              | Code(Proo ProofDire Body(Proo  |                     let core = choose|core|
Proof              | Code(Proo ProofDire Body(Proo  |                         s.core_states.dom().contains(core) && match s.core_states[core] {
Proof              | Code(Proo ProofDire Body(Proo  |                             os::CoreState::UnmapWaiting { ULT_id, vaddr }
Proof              | Code(Proo ProofDire Body(Proo  |                             | os::CoreState::UnmapOpExecuting { ULT_id, vaddr, .. }
Proof              | Code(Proo ProofDire Body(Proo  |                             | os::CoreState::UnmapOpDone { ULT_id, vaddr, .. }
Proof              | Code(Proo ProofDire Body(Proo  |                             | os::CoreState::UnmapShootdownWaiting { ULT_id, vaddr, .. } => {
Proof              | Code(Proo ProofDire Body(Proo  |                                 vaddr === base
Proof              | Code(Proo ProofDire Body(Proo  |                             },
Proof              | Code(Proo ProofDire Body(Proo  |                             _ => false,
Proof              | Code(Proo ProofDire Body(Proo  |                         };
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(s.core_states.values().contains(s.core_states.index(core)));
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(os::candidate_mapping_overlaps_inflight_vmem(
Proof              | Code(Proo ProofDire Body(Proo  |                         s.interp_pt_mem(),
Proof              | Code(Proo ProofDire Body(Proo  |                         s.core_states.values(),
Proof              | Code(Proo ProofDire Body(Proo  |                         vaddr,
Proof              | Code(Proo ProofDire Body(Proo  |                         pte_size,
Proof              | Code(Proo ProofDire Body(Proo  |                     ));
Proof              | Code(Proo ProofDire Body(Proo  |                 }
Proof              | Code(Proo ProofDire Body(Proo  |             } else {
Proof              | Code(Proo ProofDire Body(Proo  |                 lemma_candidate_mapping_inflight_vmem_overlap_os_implies_hl(c, s, vaddr, pte_size);
Proof              | Code(Proo ProofDire Body(Proo  |             }
Proof              | Code(Proo ProofDire Body(Proo  |         } else {
Proof              | Code(Proo ProofDire Body(Proo  |         }
Proof              | Code(Proo ProofDire Body(Proo  |     }
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Comment            | Comment                        | // Refinement proof
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Proof              | Signature(Proof)               | proof fn os_init_refines_hl_init(c: os::OSConstants, s: os::OSVariables)
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         os::init(c, s),
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         hlspec::init(c.interp(), s.interp(c)),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proof) Body(Proof)        |     let abs_c = c.interp();
Proof              | Code(Proof) Body(Proof)        |     let abs_s = s.interp(c);
Comment            | Comment                        |     //lemma_effective_mappings_equal_interp_pt_mem(s);
Proof              | Code(Proo ProofDire Body(Proo  |     assert forall|id: nat| id < abs_c.thread_no implies (abs_s.thread_state[id]
Proof              | Code(Proo ProofDire Body(Proo  |         === hlspec::AbstractArguments::Empty) by {
Proof              | Code(Proo ProofDire Body(Proo  |         assert(c.ULT2core.contains_key(id));
Proof              | Code(Proo ProofDire Body(Proo  |         let core = c.ULT2core[id];
Proof              | Code(Proo ProofDire Body(Proo  |         assert(hardware::valid_core(c.hw, core));
Proof              | Code(Proo ProofDire Body(Proo  |         assert(s.core_states[core] === os::CoreState::Idle);  //nn
Proof              | Code(Proo ProofDire Body(Proo  |     };
Proof              | Code(Proo ProofDire Body(Proo  |     assert(abs_s.mem === Map::empty());
Proof              | Code(Proo ProofDire Body(Proo  |     assert(abs_s.mappings === Map::empty());
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Proof              | Signature(Proof)               | proof fn os_next_refines_hl_next(c: os::OSConstants, s1: os::OSVariables, s2: os::OSVariables)
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         os::next(c, s1, s2),
Spec               | Signature(Proo FunctionSpec    |         s1.inv(c),
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         hlspec::next(c.interp(), s1.interp(c), s2.interp(c)),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proof) Body(Proof)        |     let step = choose|step: os::OSStep| os::next_step(c, s1, s2, step);
Proof              | Code(Proof) Body(Proof)        |     next_step_refines_hl_next_step(c, s1, s2, step);
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Proof              | Signature(Proof)               | proof fn next_step_refines_hl_next_step(
Proof              | Signature(Proof)               |     c: os::OSConstants,
Proof              | Signature(Proof)               |     s1: os::OSVariables,
Proof              | Signature(Proof)               |     s2: os::OSVariables,
Proof              | Signature(Proof)               |     step: os::OSStep,
Proof              | Signature(Proof)               | )
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         os::next_step(c, s1, s2, step),
Spec               | Signature(Proo FunctionSpec    |         s1.inv(c),
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         hlspec::next_step(c.interp(), s1.interp(c), s2.interp(c), step.interp(c, s1)),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proof) Body(Proof)        |     next_step_preserves_inv(c, s1, s2, step);
Proof              | Code(Proof) Body(Proof)        |     match step {
Proof              | Code(Proof) Body(Proof)        |         os::OSStep::HW { ULT_id, step } => match step {
Proof              | Code(Proof) Body(Proof)        |             hardware::HWStep::ReadWrite { vaddr, paddr, op, pte, core } => {
Proof              | Code(Proof) Body(Proof)        |                 step_ReadWrite_refines(c, s1, s2, ULT_id, vaddr, paddr, op, pte, core)
Proof              | Code(Proof) Body(Proof)        |             },
Proof              | Code(Proof) Body(Proof)        |             _ => {},
Proof              | Code(Proof) Body(Proof)        |         },
Comment            | Comment                        |         //Map steps
Proof              | Code(Proof) Body(Proof)        |         os::OSStep::MapStart { ULT_id, vaddr, pte } => {
Proof              | Code(Proof) Body(Proof)        |             step_Map_Start_refines(c, s1, s2, ULT_id, vaddr, pte);
Proof              | Code(Proof) Body(Proof)        |         },
Proof              | Code(Proof) Body(Proof)        |         os::OSStep::MapOpStart { core } => {
Proof              | Code(Proo ProofDire Body(Proo  |             assert(s1.interp(c).thread_state =~= s2.interp(c).thread_state);
Proof              | Code(Proof) Body(Proof)        |             lemma_effective_mappings_unaffected_if_thread_state_constant(c, s1, s2);
Proof              | Code(Proof) Body(Proof)        |         },
Proof              | Code(Proof) Body(Proof)        |         os::OSStep::MapEnd { core, result } => {
Proof              | Code(Proof) Body(Proof)        |             if (s1.sound) {
Proof              | Code(Proof) Body(Proof)        |                 step_Map_End_refines(c, s1, s2, core, result);
Proof              | Code(Proof) Body(Proof)        |             }
Proof              | Code(Proof) Body(Proof)        |         },
Comment            | Comment                        |         //Unmap steps
Proof              | Code(Proof) Body(Proof)        |         os::OSStep::UnmapStart { ULT_id, vaddr } => {
Proof              | Code(Proof) Body(Proof)        |             if (s1.sound) {
Proof              | Code(Proof) Body(Proof)        |                 step_Unmap_Start_refines(c, s1, s2, ULT_id, vaddr);
Proof              | Code(Proof) Body(Proof)        |             }
Proof              | Code(Proof) Body(Proof)        |         },
Proof              | Code(Proof) Body(Proof)        |         os::OSStep::UnmapOpStart { core, result } => {
Proof              | Code(Proof) Body(Proof)        |             if s1.sound {
Proof              | Code(Proof) Body(Proof)        |                 step_Unmap_Op_Start_refines(c, s1, s2, core, result);
Proof              | Code(Proof) Body(Proof)        |             }
Proof              | Code(Proof) Body(Proof)        |         },
Proof              | Code(Proof) Body(Proof)        |         os::OSStep::UnmapOpEnd { core } => {
Proof              | Code(Proo ProofDire Body(Proo  |             assert(s1.interp(c).thread_state =~= s2.interp(c).thread_state);
Proof              | Code(Proof) Body(Proof)        |             lemma_effective_mappings_unaffected_if_thread_state_constant(c, s1, s2);
Proof              | Code(Proof) Body(Proof)        |         },
Proof              | Code(Proof) Body(Proof)        |         os::OSStep::UnmapInitiateShootdown { core } => {
Proof              | Code(Proo ProofDire Body(Proo  |             assert(s1.interp(c).thread_state =~= s2.interp(c).thread_state);
Proof              | Code(Proof) Body(Proof)        |             lemma_effective_mappings_unaffected_if_thread_state_constant(c, s1, s2);
Proof              | Code(Proof) Body(Proof)        |         },
Proof              | Code(Proof) Body(Proof)        |         os::OSStep::UnmapEnd { core } => {
Proof              | Code(Proof) Body(Proof)        |             step_Unmap_End_refines(c, s1, s2, core);
Proof              | Code(Proof) Body(Proof)        |         },
Proof              | Code(Proof) Body(Proof)        |         _ => {},
Proof              | Code(Proof) Body(Proof)        |     }
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Comment            | Comment                        | /*
Comment            | Comment                        |     &&& match pte {
Layout             | Comment                        | 
Comment            | Comment                        |         None => {
Comment            | Comment                        |             // If pte is None, no mapping containing vaddr exists..
Comment            | Comment                        |             &&& !mem_domain_from_mappings(c.phys_mem_size, s1.mappings).contains(
Comment            | Comment                        |                 vmem_idx,
Comment            | Comment                        |             )
Comment            | Comment                        |             // .. and the result is always a Undefined and an unchanged memory.
Layout             | Comment                        | 
Comment            | Comment                        |             &&& s2.mem === s1.mem
Comment            | Comment                        |             &&& match op {
Comment            | Comment                        |                 RWOp::Store { new_value, result } => result is Undefined,
Comment            | Comment                        |                 RWOp::Load { is_exec, result } => result is Undefined,
Comment            | Comment                        |             }
Comment            | Comment                        |         },
Comment            | Comment                        |     }
Comment            | Comment                        | }
Comment            | Comment                        | */
                   |                                | 
Comment            | Comment                        | //TODO
Proof              | Signature(Proof)               | proof fn step_ReadWrite_refines(
Proof              | Signature(Proof)               |     c: os::OSConstants,
Proof              | Signature(Proof)               |     s1: os::OSVariables,
Proof              | Signature(Proof)               |     s2: os::OSVariables,
Proof              | Signature(Proof)               |     ULT_id: nat,
Proof              | Signature(Proof)               |     vaddr: nat,
Proof              | Signature(Proof)               |     paddr: nat,
Proof              | Signature(Proof)               |     op: HWRWOp,
Proof              | Signature(Proof)               |     pte: Option<(nat, PageTableEntry)>,
Proof              | Signature(Proof)               |     core: hardware::Core,
Proof              | Signature(Proof)               | )
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         s1.inv(c),
Spec               | Signature(Proo FunctionSpec    |         s2.inv(c),
Spec               | Signature(Proo FunctionSpec    |         os::step_HW(c, s1, s2, ULT_id, hardware::HWStep::ReadWrite { vaddr, paddr, op, pte, core }),
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         ({
Spec               | Signature(Proo FunctionSpec    |             let hl_pte = if (pte is None || (pte matches Some((base, _))
Spec               | Signature(Proo FunctionSpec    |                 && !s1.effective_mappings().dom().contains(base))) {
Spec               | Signature(Proo FunctionSpec    |                 None
Spec               | Signature(Proo FunctionSpec    |             } else {
Spec               | Signature(Proo FunctionSpec    |                 pte
Spec               | Signature(Proo FunctionSpec    |             };
Spec               | Signature(Proo FunctionSpec    |             let rwop = match (op, hl_pte) {
Spec               | Signature(Proo FunctionSpec    |                 (HWRWOp::Store { new_value, result: HWStoreResult::Ok }, Some(_)) => RWOp::Store {
Spec               | Signature(Proo FunctionSpec    |                     new_value,
Spec               | Signature(Proo FunctionSpec    |                     result: StoreResult::Ok,
Spec               | Signature(Proo FunctionSpec    |                 },
Spec               | Signature(Proo FunctionSpec    |                 (HWRWOp::Store { new_value, result: HWStoreResult::Ok }, None) => RWOp::Store {
Spec               | Signature(Proo FunctionSpec    |                     new_value,
Spec               | Signature(Proo FunctionSpec    |                     result: StoreResult::Undefined,
Spec               | Signature(Proo FunctionSpec    |                 },
Spec               | Signature(Proo FunctionSpec    |                 (HWRWOp::Store { new_value, result: HWStoreResult::Pagefault }, _) => RWOp::Store {
Spec               | Signature(Proo FunctionSpec    |                     new_value,
Spec               | Signature(Proo FunctionSpec    |                     result: StoreResult::Undefined,
Spec               | Signature(Proo FunctionSpec    |                 },
Spec               | Signature(Proo FunctionSpec    |                 (HWRWOp::Load { is_exec, result: HWLoadResult::Value(v) }, Some(_)) => RWOp::Load {
Spec               | Signature(Proo FunctionSpec    |                     is_exec,
Spec               | Signature(Proo FunctionSpec    |                     result: LoadResult::Value(v),
Spec               | Signature(Proo FunctionSpec    |                 },
Spec               | Signature(Proo FunctionSpec    |                 (HWRWOp::Load { is_exec, result: HWLoadResult::Value(v) }, None) => RWOp::Load {
Spec               | Signature(Proo FunctionSpec    |                     is_exec,
Spec               | Signature(Proo FunctionSpec    |                     result: LoadResult::Undefined,
Spec               | Signature(Proo FunctionSpec    |                 },
Spec               | Signature(Proo FunctionSpec    |                 (HWRWOp::Load { is_exec, result: HWLoadResult::Pagefault }, _) => RWOp::Load {
Spec               | Signature(Proo FunctionSpec    |                     is_exec,
Spec               | Signature(Proo FunctionSpec    |                     result: LoadResult::Undefined,
Spec               | Signature(Proo FunctionSpec    |                 },
Spec               | Signature(Proo FunctionSpec    |             };
Spec               | Signature(Proo FunctionSpec    |             hlspec::step_ReadWrite(
Spec               | Signature(Proo FunctionSpec    |                 c.interp(),
Spec               | Signature(Proo FunctionSpec    |                 s1.interp(c),
Spec               | Signature(Proo FunctionSpec    |                 s2.interp(c),
Spec               | Signature(Proo FunctionSpec    |                 ULT_id,
Spec               | Signature(Proo FunctionSpec    |                 vaddr,
Spec               | Signature(Proo FunctionSpec    |                 rwop,
Spec               | Signature(Proo FunctionSpec    |                 hl_pte,
Spec               | Signature(Proo FunctionSpec    |             )
Spec               | Signature(Proo FunctionSpec    |         }),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proof) Body(Proof)        |     let hl_c = c.interp();
Proof              | Code(Proof) Body(Proof)        |     let hl_s1 = s1.interp(c);
Proof              | Code(Proof) Body(Proof)        |     let hl_s2 = s2.interp(c);
Layout             | Code(Proof) Body(Proof)        | 
Proof              | Code(Proof) Body(Proof)        |     let hl_pte = if (pte is None || (pte matches Some((base, _))
Proof              | Code(Proof) Body(Proof)        |         && !s1.effective_mappings().dom().contains(base))) {
Proof              | Code(Proof) Body(Proof)        |         None
Proof              | Code(Proof) Body(Proof)        |     } else {
Proof              | Code(Proof) Body(Proof)        |         pte
Proof              | Code(Proof) Body(Proof)        |     };
Proof              | Code(Proof) Body(Proof)        |     let rwop = match (op, hl_pte) {
Proof              | Code(Proof) Body(Proof)        |         (HWRWOp::Store { new_value, result: HWStoreResult::Ok }, Some(_)) => RWOp::Store {
Proof              | Code(Proof) Body(Proof)        |             new_value,
Proof              | Code(Proof) Body(Proof)        |             result: StoreResult::Ok,
Proof              | Code(Proof) Body(Proof)        |         },
Proof              | Code(Proof) Body(Proof)        |         (HWRWOp::Store { new_value, result: HWStoreResult::Ok }, None) => RWOp::Store {
Proof              | Code(Proof) Body(Proof)        |             new_value,
Proof              | Code(Proof) Body(Proof)        |             result: StoreResult::Undefined,
Proof              | Code(Proof) Body(Proof)        |         },
Proof              | Code(Proof) Body(Proof)        |         (HWRWOp::Store { new_value, result: HWStoreResult::Pagefault }, _) => RWOp::Store {
Proof              | Code(Proof) Body(Proof)        |             new_value,
Proof              | Code(Proof) Body(Proof)        |             result: StoreResult::Undefined,
Proof              | Code(Proof) Body(Proof)        |         },
Proof              | Code(Proof) Body(Proof)        |         (HWRWOp::Load { is_exec, result: HWLoadResult::Value(v) }, Some(_)) => RWOp::Load {
Proof              | Code(Proof) Body(Proof)        |             is_exec,
Proof              | Code(Proof) Body(Proof)        |             result: LoadResult::Value(v),
Proof              | Code(Proof) Body(Proof)        |         },
Proof              | Code(Proof) Body(Proof)        |         (HWRWOp::Load { is_exec, result: HWLoadResult::Value(v) }, None) => RWOp::Load {
Proof              | Code(Proof) Body(Proof)        |             is_exec,
Proof              | Code(Proof) Body(Proof)        |             result: LoadResult::Undefined,
Proof              | Code(Proof) Body(Proof)        |         },
Proof              | Code(Proof) Body(Proof)        |         (HWRWOp::Load { is_exec, result: HWLoadResult::Pagefault }, _) => RWOp::Load {
Proof              | Code(Proof) Body(Proof)        |             is_exec,
Proof              | Code(Proof) Body(Proof)        |             result: LoadResult::Undefined,
Proof              | Code(Proof) Body(Proof)        |         },
Proof              | Code(Proof) Body(Proof)        |     };
Layout             | Code(Proof) Body(Proof)        | 
Proof              | Code(Proof) Body(Proof)        |     let vmem_idx = mem::word_index_spec(vaddr);
Comment            | Comment                        |     //let pmem_idx = mem::word_index_spec(paddr);
Layout             | Code(Proof) Body(Proof)        | 
Proof              | Code(Proo ProofDire Body(Proo  |     assert(hl_s2.sound == hl_s1.sound);
Proof              | Code(Proo ProofDire Body(Proo  |     assert(aligned(vaddr, 8));
Proof              | Code(Proo ProofDire Body(Proo  |     assert(hl_s2.mappings === hl_s1.mappings);
Proof              | Code(Proo ProofDire Body(Proo  |     assert(hlspec::valid_thread(hl_c, ULT_id));
Proof              | Code(Proo ProofDire Body(Proo  |     assert(hl_s1.thread_state[ULT_id] === hlspec::AbstractArguments::Empty);
Proof              | Code(Proo ProofDire Body(Proo  |     assert(hl_s2.thread_state === hl_s1.thread_state);
Proof              | Code(Proof) Body(Proof)        |     match hl_pte {
Proof              | Code(Proof) Body(Proof)        |         Some((base, pte)) => {
Proof              | Code(Proo ProofDire Body(Proo  |             assert(s1.effective_mappings().dom().contains(base));
Proof              | Code(Proof) Body(Proof)        |             if (!s1.Unmap_vaddr().contains(base)) {
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(s1.interp_pt_mem().dom().contains(base));
Proof              | Code(Proo ProofDire Body(Proo  |                 assume(s1.interp_pt_mem().contains_pair(base, pte));
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(hl_s1.mappings.dom().contains(base));
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(hl_s1.mappings.contains_pair(base, pte));
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(between(vaddr, base, base + pte.frame.size));
Proof              | Code(Proo ProofDire Body(Proo  |                 assume(hl_c.phys_mem_size == s1.hw.mem.len());
Proof              | Code(Proof) Body(Proof)        |                 match rwop {
Proof              | Code(Proof) Body(Proof)        |                     RWOp::Store { new_value, result } => {
Proof              | Code(Proof) Body(Proof)        |                         if (result is Ok) {
Comment            | Comment                        |                             //assert( s2.hw.mem === s1.mem.hw.update(pmem_idx as int, new_value));
Proof              | Code(Proo ProofDire Body(Proo  |                             assume(hl_s2.mem === hl_s1.mem.insert(vmem_idx, new_value));
Proof              | Code(Proof) Body(Proof)        |                         }
Proof              | Code(Proof) Body(Proof)        |                     },
Proof              | Code(Proof) Body(Proof)        |                     RWOp::Load { is_exec, result } => {
Proof              | Code(Proo ProofDire Body(Proo  |                         assert(hl_s2.mem === hl_s1.mem);
Proof              | Code(Proof) Body(Proof)        |                         if (result is Value) {
Proof              | Code(Proo ProofDire Body(Proo  |                             assume(result->0 == hl_s1.mem.index(vmem_idx));
Proof              | Code(Proof) Body(Proof)        |                         }
Proof              | Code(Proof) Body(Proof)        |                     },
Proof              | Code(Proof) Body(Proof)        |                 }
Proof              | Code(Proof) Body(Proof)        |             } else {
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(!s1.interp_pt_mem().dom().contains(base));
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(false);
Proof              | Code(Proof) Body(Proof)        |             }
Proof              | Code(Proof) Body(Proof)        |         },
Proof              | Code(Proof) Body(Proof)        |         None => {
Proof              | Code(Proof) Body(Proof)        |             if (pte is None) {
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(!exists|base: nat, pte: PageTableEntry|
Proof              | Code(Proo ProofDire Body(Proo  |                     {
Proof              | Code(Proo ProofDire Body(Proo  |                         &&& #[trigger] s1.interp_pt_mem().contains_pair(base, pte)
Proof              | Code(Proo ProofDire Body(Proo  |                         &&& hlspec::mem_domain_from_entry_contains(
Proof              | Code(Proo ProofDire Body(Proo  |                             c.hw.phys_mem_size,
Proof              | Code(Proo ProofDire Body(Proo  |                             vaddr,
Proof              | Code(Proo ProofDire Body(Proo  |                             base,
Proof              | Code(Proo ProofDire Body(Proo  |                             pte,
Proof              | Code(Proo ProofDire Body(Proo  |                         )
Proof              | Code(Proo ProofDire Body(Proo  |                     });
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(hl_s1.mappings.submap_of(s1.interp_pt_mem()));
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(forall|key, value|
Proof              | Code(Proo ProofDire Body(Proo  |                     !s1.interp_pt_mem().contains_pair(key, value) ==> !hl_s1.mappings.contains_pair(
Proof              | Code(Proo ProofDire Body(Proo  |                         key,
Proof              | Code(Proo ProofDire Body(Proo  |                         value,
Proof              | Code(Proo ProofDire Body(Proo  |                     ));
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(!exists|base: nat, pte: PageTableEntry|
Proof              | Code(Proo ProofDire Body(Proo  |                     {
Proof              | Code(Proo ProofDire Body(Proo  |                         &&& #[trigger] hl_s1.mappings.contains_pair(base, pte)
Proof              | Code(Proo ProofDire Body(Proo  |                         &&& hlspec::mem_domain_from_entry_contains(
Proof              | Code(Proo ProofDire Body(Proo  |                             c.hw.phys_mem_size,
Proof              | Code(Proo ProofDire Body(Proo  |                             vaddr,
Proof              | Code(Proo ProofDire Body(Proo  |                             base,
Proof              | Code(Proo ProofDire Body(Proo  |                             pte,
Proof              | Code(Proo ProofDire Body(Proo  |                         )
Proof              | Code(Proo ProofDire Body(Proo  |                     });
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(!hlspec::mem_domain_from_mappings(
Proof              | Code(Proo ProofDire Body(Proo  |                     hl_c.phys_mem_size,
Proof              | Code(Proo ProofDire Body(Proo  |                     hl_s1.mappings,
Proof              | Code(Proo ProofDire Body(Proo  |                 ).contains(vmem_idx));
Proof              | Code(Proof) Body(Proof)        |             } else {
Proof              | Code(Proof) Body(Proof)        |                 let (base, pte) = pte.unwrap();
Comment            | Comment                        |                 //assert(!s1.effective_mappings().dom().contains(vaddr));
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(!s1.effective_mappings().dom().contains(base));
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(!hl_s1.mappings.dom().contains(base));
Proof              | Code(Proo ProofDire Body(Proo  |                 assume(!hlspec::mem_domain_from_mappings(
Proof              | Code(Proo ProofDire Body(Proo  |                     hl_c.phys_mem_size,
Proof              | Code(Proo ProofDire Body(Proo  |                     hl_s1.mappings,
Proof              | Code(Proo ProofDire Body(Proo  |                 ).contains(vmem_idx));
Proof              | Code(Proo ProofDire Body(Proo  |                 assume(hl_s2.mem === hl_s1.mem);
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(match rwop {
Proof              | Code(Proo ProofDire Body(Proo  |                     RWOp::Store { new_value, result } => result is Undefined,
Proof              | Code(Proo ProofDire Body(Proo  |                     RWOp::Load { is_exec, result } => result is Undefined,
Proof              | Code(Proo ProofDire Body(Proo  |                 });
Proof              | Code(Proof) Body(Proof)        |             }
Proof              | Code(Proof) Body(Proof)        |         },
Proof              | Code(Proof) Body(Proof)        |     }
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Proof              | Signature(Proof)               | proof fn step_Map_Start_refines(
Proof              | Signature(Proof)               |     c: os::OSConstants,
Proof              | Signature(Proof)               |     s1: os::OSVariables,
Proof              | Signature(Proof)               |     s2: os::OSVariables,
Proof              | Signature(Proof)               |     ULT_id: nat,
Proof              | Signature(Proof)               |     vaddr: nat,
Proof              | Signature(Proof)               |     pte: PageTableEntry,
Proof              | Signature(Proof)               | )
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         s1.basic_inv(c),
Spec               | Signature(Proo FunctionSpec    |         s2.basic_inv(c),
Spec               | Signature(Proo FunctionSpec    |         os::step_Map_Start(c, s1, s2, ULT_id, vaddr, pte),
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         hlspec::step_Map_start(c.interp(), s1.interp(c), s2.interp(c), ULT_id, vaddr, pte),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proof) Body(Proof)        |     let hl_c = c.interp();
Proof              | Code(Proof) Body(Proof)        |     let hl_s1 = s1.interp(c);
Proof              | Code(Proof) Body(Proof)        |     let hl_s2 = s2.interp(c);
Proof              | Code(Proo ProofDire Body(Proo  |     assert(hlspec::step_Map_enabled(
Proof              | Code(Proo ProofDire Body(Proo  |         s1.interp(c).thread_state.values(),
Proof              | Code(Proo ProofDire Body(Proo  |         s1.interp(c).mappings,
Proof              | Code(Proo ProofDire Body(Proo  |         vaddr,
Proof              | Code(Proo ProofDire Body(Proo  |         pte,
Proof              | Code(Proo ProofDire Body(Proo  |     ));
Proof              | Code(Proo ProofDire Body(Proo  |     assert(hlspec::valid_thread(hl_c, ULT_id));
Proof              | Code(Proo ProofDire Body(Proo  |     assert(s1.interp(c).thread_state[ULT_id] === hlspec::AbstractArguments::Empty);
Proof              | Code(Proof) Body(Proof)        |     let hl_map_sound = hlspec::step_Map_sound(
Proof              | Code(Proof) Body(Proof)        |         s1.interp(c).mappings,
Proof              | Code(Proof) Body(Proof)        |         s1.interp(c).thread_state.values(),
Proof              | Code(Proof) Body(Proof)        |         vaddr,
Proof              | Code(Proof) Body(Proof)        |         pte,
Proof              | Code(Proof) Body(Proof)        |     );
Proof              | Code(Proof) Body(Proof)        |     lemma_map_soundness_equality(c, s1, vaddr, pte);
Proof              | Code(Proof) Body(Proof)        |     if (hl_map_sound) {
Proof              | Code(Proo ProofDire Body(Proo  |         assert(hl_s1.sound == hl_s2.sound);
Proof              | Code(Proo ProofDire Body(Proo  |         assert(hl_s2.thread_state === hl_s1.thread_state.insert(
Proof              | Code(Proo ProofDire Body(Proo  |             ULT_id,
Proof              | Code(Proo ProofDire Body(Proo  |             hlspec::AbstractArguments::Map { vaddr, pte },
Proof              | Code(Proo ProofDire Body(Proo  |         ));
Proof              | Code(Proof) Body(Proof)        |         lemma_map_insert_values_equality(
Proof              | Code(Proof) Body(Proof)        |             hl_s1.thread_state,
Proof              | Code(Proof) Body(Proof)        |             ULT_id,
Proof              | Code(Proof) Body(Proof)        |             hlspec::AbstractArguments::Map { vaddr, pte },
Proof              | Code(Proof) Body(Proof)        |         );
Proof              | Code(Proo ProofDire Body(Proo  |         assert(hl_s2.thread_state.values().insert(hlspec::AbstractArguments::Empty)
Proof              | Code(Proo ProofDire Body(Proo  |             =~= hl_s1.thread_state.values().insert(hlspec::AbstractArguments::Map { vaddr, pte }));
Proof              | Code(Proo ProofDire Body(Proo  |         assert(s1.interp_pt_mem() == s2.interp_pt_mem());
Proof              | Code(Proof) Body(Proof)        |         lemma_inflight_vaddr_equals_hl_unmap(c, s1);
Proof              | Code(Proof) Body(Proof)        |         lemma_inflight_vaddr_equals_hl_unmap(c, s2);
Proof              | Code(Proo ProofDire Body(Proo  |         assert forall|base|
Proof              | Code(Proo ProofDire Body(Proo  |             s1.inflight_unmap_vaddr().contains(base) implies s2.inflight_unmap_vaddr().contains(
Proof              | Code(Proo ProofDire Body(Proo  |             base,
Proof              | Code(Proo ProofDire Body(Proo  |         ) by {
Proof              | Code(Proo ProofDire Body(Proo  |             let threadstate = choose|thread_state|
Proof              | Code(Proo ProofDire Body(Proo  |                 {
Proof              | Code(Proo ProofDire Body(Proo  |                     &&& s1.interp_thread_state(c).values().contains(thread_state)
Proof              | Code(Proo ProofDire Body(Proo  |                     &&& s1.interp_pt_mem().dom().contains(base)
Proof              | Code(Proo ProofDire Body(Proo  |                     &&& thread_state matches hlspec::AbstractArguments::Unmap { vaddr, .. }
Proof              | Code(Proo ProofDire Body(Proo  |                     &&& vaddr === base
Proof              | Code(Proo ProofDire Body(Proo  |                 };
Proof              | Code(Proo ProofDire Body(Proo  |             assert(s2.interp_thread_state(c).values().contains(threadstate));
Proof              | Code(Proo ProofDire Body(Proo  |         }
Proof              | Code(Proo ProofDire Body(Proo  |         assert(s1.inflight_unmap_vaddr() =~= s2.inflight_unmap_vaddr());
Proof              | Code(Proo ProofDire Body(Proo  |         assert(hl_s2.mappings === hl_s1.mappings);
Proof              | Code(Proo ProofDire Body(Proo  |         assert(hl_s2.mem === hl_s1.mem);
Proof              | Code(Proo ProofDire Body(Proo  |         assert(hlspec::state_unchanged_besides_thread_state(
Proof              | Code(Proo ProofDire Body(Proo  |             hl_s1,
Proof              | Code(Proo ProofDire Body(Proo  |             hl_s2,
Proof              | Code(Proo ProofDire Body(Proo  |             ULT_id,
Proof              | Code(Proo ProofDire Body(Proo  |             hlspec::AbstractArguments::Map { vaddr, pte },
Proof              | Code(Proo ProofDire Body(Proo  |         ));
Proof              | Code(Proof) Body(Proof)        |     } else {
Proof              | Code(Proo ProofDire Body(Proo  |         assert(!s2.sound);
Proof              | Code(Proo ProofDire Body(Proo  |         assert(hlspec::unsound_state(hl_s1, hl_s2));
Proof              | Code(Proof) Body(Proof)        |     };
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Proof              | Signature(Proof)               | proof fn step_Map_End_refines(
Proof              | Signature(Proof)               |     c: os::OSConstants,
Proof              | Signature(Proof)               |     s1: os::OSVariables,
Proof              | Signature(Proof)               |     s2: os::OSVariables,
Proof              | Signature(Proof)               |     core: hardware::Core,
Proof              | Signature(Proof)               |     result: Result<(), ()>,
Proof              | Signature(Proof)               | )
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         s1.inv(c),
Spec               | Signature(Proo FunctionSpec    |         s2.inv(c),
Spec               | Signature(Proo FunctionSpec    |         os::step_Map_End(c, s1, s2, core, result),
Spec               | Signature(Proo FunctionSpec    |         s1.sound,
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         ({
Spec               | Signature(Proo FunctionSpec    |             &&& s1.core_states[core] matches os::CoreState::MapExecuting { ULT_id, .. }
Spec               | Signature(Proo FunctionSpec    |             &&& hlspec::step_Map_end(c.interp(), s1.interp(c), s2.interp(c), ULT_id, result)
Spec               | Signature(Proo FunctionSpec    |         }),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proof) Body(Proof)        |     let hl_c = c.interp();
Proof              | Code(Proof) Body(Proof)        |     let hl_s1 = s1.interp(c);
Proof              | Code(Proof) Body(Proof)        |     let hl_s2 = s2.interp(c);
Layout             | Code(Proof) Body(Proof)        | 
Proof              | Code(Proof) Body(Proof)        |     let ULT_id = s1.core_states[core]->MapExecuting_ULT_id;
Proof              | Code(Proof) Body(Proof)        |     let vaddr = s1.core_states[core]->MapExecuting_vaddr;
Proof              | Code(Proof) Body(Proof)        |     let pte = s1.core_states[core]->MapExecuting_pte;
Layout             | Code(Proof) Body(Proof)        | 
Proof              | Code(Proo ProofDire Body(Proo  |     assert(s2.sound);
Proof              | Code(Proo ProofDire Body(Proo  |     assert(hlspec::valid_thread(hl_c, ULT_id));
Proof              | Code(Proo ProofDire Body(Proo  |     assert(s1.interp(c).thread_state[ULT_id] is Map);
Layout             | Code(Proof) Body(Proof)        | 
Proof              | Code(Proof) Body(Proof)        |     if (candidate_mapping_overlaps_existing_vmem(hl_s1.mappings, vaddr, pte)) {
Proof              | Code(Proo ProofDire Body(Proo  |         assert(candidate_mapping_overlaps_existing_vmem(s1.interp_pt_mem(), vaddr, pte));
Proof              | Code(Proo ProofDire Body(Proo  |         assert(result is Err);
Proof              | Code(Proo ProofDire Body(Proo  |         assert(s1.interp_pt_mem() == s2.interp_pt_mem());
Layout             | Code(Proof) Body(Proof)        | 
Proof              | Code(Proof) Body(Proof)        |         lemma_map_insert_values_equality(s1.core_states, core, os::CoreState::Idle);
Proof              | Code(Proo ProofDire Body(Proo  |         assert(s1.core_states.values().insert(os::CoreState::Idle)
Proof              | Code(Proo ProofDire Body(Proo  |             =~= s2.core_states.values().insert(s1.core_states[core]));
Layout             | Code(Proof) Body(Proof)        | 
Proof              | Code(Proo ProofDire Body(Proo  |         assert forall|key| #[trigger]
Proof              | Code(Proo ProofDire Body(Proo  |             hl_s1.thread_state.dom().contains(key) implies hl_s1.thread_state.insert(
Proof              | Code(Proo ProofDire Body(Proo  |             ULT_id,
Proof              | Code(Proo ProofDire Body(Proo  |             hlspec::AbstractArguments::Empty,
Proof              | Code(Proo ProofDire Body(Proo  |         )[key] == hl_s2.thread_state[key] by {
Proof              | Code(Proo ProofDire Body(Proo  |             let core_of_key = c.ULT2core[key];
Proof              | Code(Proo ProofDire Body(Proo  |             if (core_of_key === core) {
Proof              | Code(Proo ProofDire Body(Proo  |             } else {
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(s1.core_states[core_of_key] == s2.core_states[core_of_key]);
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(s1.core_states[c.ULT2core[key]] === s2.core_states[c.ULT2core[key]]);
Proof              | Code(Proo ProofDire Body(Proo  |             }
Proof              | Code(Proo ProofDire Body(Proo  |         }
Proof              | Code(Proo ProofDire Body(Proo  |         assert(hl_s2.thread_state === hl_s1.thread_state.insert(
Proof              | Code(Proo ProofDire Body(Proo  |             ULT_id,
Proof              | Code(Proo ProofDire Body(Proo  |             hlspec::AbstractArguments::Empty,
Proof              | Code(Proo ProofDire Body(Proo  |         ));
Proof              | Code(Proo ProofDire Body(Proo  |         assert(s1.core_states[core] is MapExecuting);
Layout             | Code(Proof) Body(Proof)        | 
Proof              | Code(Proof) Body(Proof)        |         lemma_map_insert_values_equality(
Proof              | Code(Proof) Body(Proof)        |             hl_s1.thread_state,
Proof              | Code(Proof) Body(Proof)        |             ULT_id,
Proof              | Code(Proof) Body(Proof)        |             hlspec::AbstractArguments::Empty,
Proof              | Code(Proof) Body(Proof)        |         );
Proof              | Code(Proo ProofDire Body(Proo  |         assert(hl_s1.thread_state.values().insert(hlspec::AbstractArguments::Empty)
Proof              | Code(Proo ProofDire Body(Proo  |             =~= hl_s2.thread_state.values().insert(hl_s1.thread_state[ULT_id]));
Proof              | Code(Proof) Body(Proof)        |         lemma_inflight_vaddr_equals_hl_unmap(c, s1);
Proof              | Code(Proof) Body(Proof)        |         lemma_inflight_vaddr_equals_hl_unmap(c, s2);
Proof              | Code(Proo ProofDire Body(Proo  |         assert forall|base|
Proof              | Code(Proo ProofDire Body(Proo  |             s1.inflight_unmap_vaddr().contains(base) implies s2.inflight_unmap_vaddr().contains(
Proof              | Code(Proo ProofDire Body(Proo  |             base,
Proof              | Code(Proo ProofDire Body(Proo  |         ) by {
Proof              | Code(Proo ProofDire Body(Proo  |             let threadstate = choose|thread_state|
Proof              | Code(Proo ProofDire Body(Proo  |                 {
Proof              | Code(Proo ProofDire Body(Proo  |                     &&& s1.interp_thread_state(c).values().contains(thread_state)
Proof              | Code(Proo ProofDire Body(Proo  |                     &&& s1.interp_pt_mem().dom().contains(base)
Proof              | Code(Proo ProofDire Body(Proo  |                     &&& thread_state matches hlspec::AbstractArguments::Unmap { vaddr, .. }
Proof              | Code(Proo ProofDire Body(Proo  |                     &&& vaddr === base
Proof              | Code(Proo ProofDire Body(Proo  |                 };
Proof              | Code(Proo ProofDire Body(Proo  |             assert(!(hl_s1.thread_state[ULT_id] is Unmap));
Proof              | Code(Proo ProofDire Body(Proo  |             assert(hl_s1.thread_state.values().insert(hlspec::AbstractArguments::Empty).contains(
Proof              | Code(Proo ProofDire Body(Proo  |                 threadstate,
Proof              | Code(Proo ProofDire Body(Proo  |             ));
Proof              | Code(Proo ProofDire Body(Proo  |             assert(hl_s2.thread_state.values().contains(threadstate));
Proof              | Code(Proo ProofDire Body(Proo  |         }
Proof              | Code(Proo ProofDire Body(Proo  |         assert(s1.inflight_unmap_vaddr() =~= s2.inflight_unmap_vaddr());
Layout             | Code(Proof) Body(Proof)        | 
Proof              | Code(Proof) Body(Proof)        |     } else {
Proof              | Code(Proof) Body(Proof)        |         lemma_os_overlap_vmem_implies_hl_or_inflight_overlap_vmem(c, s1, vaddr, pte);
Proof              | Code(Proof) Body(Proof)        |         if (!hlspec::candidate_mapping_overlaps_inflight_vmem(
Proof              | Code(Proof) Body(Proof)        |             s1.interp(c).thread_state.values(),
Proof              | Code(Proof) Body(Proof)        |             vaddr,
Proof              | Code(Proof) Body(Proof)        |             pte.frame.size,
Proof              | Code(Proof) Body(Proof)        |         )) {
Proof              | Code(Proo ProofDire Body(Proo  |             assert(hl_s1.thread_state[ULT_id] is Map);
Proof              | Code(Proof) Body(Proof)        |             let map_vaddr = hl_s1.thread_state[ULT_id]->Map_vaddr;
Proof              | Code(Proof) Body(Proof)        |             let map_pte = hl_s1.thread_state[ULT_id]->Map_pte;
Comment            | Comment                        |             //assert(hl_s1.thread_state[matches])
Proof              | Code(Proo ProofDire Body(Proo  |             assert(hl_s1.thread_state.dom().contains(ULT_id));
Proof              | Code(Proo ProofDire Body(Proo  |             assert(hl_s1.thread_state.values().contains(hl_s1.thread_state[ULT_id]));
Proof              | Code(Proo ProofDire Body(Proo  |             assert(overlap(
Proof              | Code(Proo ProofDire Body(Proo  |                 MemRegion { base: map_vaddr, size: map_pte.frame.size },
Proof              | Code(Proo ProofDire Body(Proo  |                 MemRegion { base: vaddr, size: pte.frame.size },
Proof              | Code(Proo ProofDire Body(Proo  |             ));
Layout             | Code(Proof) Body(Proof)        | 
Proof              | Code(Proof) Body(Proof)        |         } else {
Proof              | Code(Proo ProofDire Body(Proo  |             assert(!candidate_mapping_overlaps_existing_vmem(hl_s1.mappings, vaddr, pte));
Proof              | Code(Proo ProofDire Body(Proo  |             assert(hlspec::candidate_mapping_overlaps_inflight_vmem(
Proof              | Code(Proo ProofDire Body(Proo  |                 s1.interp(c).thread_state.values(),
Proof              | Code(Proo ProofDire Body(Proo  |                 vaddr,
Proof              | Code(Proo ProofDire Body(Proo  |                 pte.frame.size,
Proof              | Code(Proo ProofDire Body(Proo  |             ));
Proof              | Code(Proof) Body(Proof)        |             lemma_candidate_mapping_inflight_vmem_overlap_hl_implies_os(
Proof              | Code(Proof) Body(Proof)        |                 c,
Proof              | Code(Proof) Body(Proof)        |                 s1,
Proof              | Code(Proof) Body(Proof)        |                 vaddr,
Proof              | Code(Proof) Body(Proof)        |                 pte.frame.size,
Proof              | Code(Proof) Body(Proof)        |             );
Proof              | Code(Proo ProofDire Body(Proo  |             assert(os::candidate_mapping_overlaps_inflight_vmem(
Proof              | Code(Proo ProofDire Body(Proo  |                 s1.interp_pt_mem(),
Proof              | Code(Proo ProofDire Body(Proo  |                 s1.core_states.values(),
Proof              | Code(Proo ProofDire Body(Proo  |                 vaddr,
Proof              | Code(Proo ProofDire Body(Proo  |                 pte.frame.size,
Proof              | Code(Proo ProofDire Body(Proo  |             ));
Proof              | Code(Proof) Body(Proof)        |             if (!candidate_mapping_overlaps_existing_vmem(s1.interp_pt_mem(), vaddr, pte)) {
Proof              | Code(Proo ProofDire Body(Proo  |                 assert forall|key| #[trigger]
Proof              | Code(Proo ProofDire Body(Proo  |                     hl_s1.thread_state.dom().contains(key) implies hl_s1.thread_state.insert(
Proof              | Code(Proo ProofDire Body(Proo  |                     ULT_id,
Proof              | Code(Proo ProofDire Body(Proo  |                     hlspec::AbstractArguments::Empty,
Proof              | Code(Proo ProofDire Body(Proo  |                 )[key] == hl_s2.thread_state[key] by {
Proof              | Code(Proo ProofDire Body(Proo  |                     let core_of_key = c.ULT2core[key];
Proof              | Code(Proo ProofDire Body(Proo  |                     if (core_of_key === core) {
Proof              | Code(Proo ProofDire Body(Proo  |                     } else {
Proof              | Code(Proo ProofDire Body(Proo  |                         assert(!s1.core_states[core_of_key].holds_lock());
Proof              | Code(Proo ProofDire Body(Proo  |                         if (s1.core_states[core_of_key] is UnmapWaiting) {
Proof              | Code(Proo ProofDire Body(Proo  |                             assert(s1.core_states[core_of_key] == s2.core_states[core_of_key]);
Proof              | Code(Proo ProofDire Body(Proo  |                             assert(s1.core_states[c.ULT2core[key]]
Proof              | Code(Proo ProofDire Body(Proo  |                                 === s2.core_states[c.ULT2core[key]]);
Proof              | Code(Proo ProofDire Body(Proo  |                             let Unmap_vaddr = s1.core_states[core_of_key]->UnmapWaiting_vaddr;
Proof              | Code(Proo ProofDire Body(Proo  |                             if (vaddr == Unmap_vaddr) {
Proof              | Code(Proo ProofDire Body(Proo  |                                 assert(!s1.core_states[core].is_idle()
Proof              | Code(Proo ProofDire Body(Proo  |                                     && !s1.core_states[core_of_key].is_idle() && overlap(
Proof              | Code(Proo ProofDire Body(Proo  |                                     MemRegion {
Proof              | Code(Proo ProofDire Body(Proo  |                                         base: s1.core_states[core].vaddr(),
Proof              | Code(Proo ProofDire Body(Proo  |                                         size: s1.core_states[core].vmem_pte_size(
Proof              | Code(Proo ProofDire Body(Proo  |                                             s1.interp_pt_mem(),
Proof              | Code(Proo ProofDire Body(Proo  |                                         ),
Proof              | Code(Proo ProofDire Body(Proo  |                                     },
Proof              | Code(Proo ProofDire Body(Proo  |                                     MemRegion {
Proof              | Code(Proo ProofDire Body(Proo  |                                         base: s1.core_states[core_of_key].vaddr(),
Proof              | Code(Proo ProofDire Body(Proo  |                                         size: s1.core_states[core_of_key].vmem_pte_size(
Proof              | Code(Proo ProofDire Body(Proo  |                                             s1.interp_pt_mem(),
Proof              | Code(Proo ProofDire Body(Proo  |                                         ),
Proof              | Code(Proo ProofDire Body(Proo  |                                     },
Proof              | Code(Proo ProofDire Body(Proo  |                                 ));
Proof              | Code(Proo ProofDire Body(Proo  |                                 assert(core_of_key == core);
Proof              | Code(Proo ProofDire Body(Proo  |                                 assert(false);
Proof              | Code(Proo ProofDire Body(Proo  |                             }
Proof              | Code(Proo ProofDire Body(Proo  |                         } else {
Proof              | Code(Proo ProofDire Body(Proo  |                             assert(s1.core_states[core_of_key] == s2.core_states[core_of_key]);
Proof              | Code(Proo ProofDire Body(Proo  |                             assert(s1.core_states[c.ULT2core[key]]
Proof              | Code(Proo ProofDire Body(Proo  |                                 === s2.core_states[c.ULT2core[key]]);
Proof              | Code(Proo ProofDire Body(Proo  |                         }
Proof              | Code(Proo ProofDire Body(Proo  |                     }
Proof              | Code(Proo ProofDire Body(Proo  |                 }
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(hl_s2.thread_state === hl_s1.thread_state.insert(
Proof              | Code(Proo ProofDire Body(Proo  |                     ULT_id,
Proof              | Code(Proo ProofDire Body(Proo  |                     hlspec::AbstractArguments::Empty,
Proof              | Code(Proo ProofDire Body(Proo  |                 ));
Comment            | Comment                        |                 //assert(!candidate_mapping_overlaps_existing_vmem(s1.interp_pt_mem(), vaddr, pte));
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(result is Ok);
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(s2.interp_pt_mem() == s1.interp_pt_mem().insert(vaddr, pte));
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(!s1.inflight_unmap_vaddr().contains(vaddr));
Proof              | Code(Proo ProofDire Body(Proo  |                 assert forall|idx|
Proof              | Code(Proo ProofDire Body(Proo  |                     s1.inflight_unmap_vaddr().contains(
Proof              | Code(Proo ProofDire Body(Proo  |                         idx,
Proof              | Code(Proo ProofDire Body(Proo  |                     ) implies s2.inflight_unmap_vaddr().contains(idx) by {
Proof              | Code(Proo ProofDire Body(Proo  |                     if (s1.inflight_unmap_vaddr().contains(idx)) {
Proof              | Code(Proo ProofDire Body(Proo  |                         assert(s1.interp_pt_mem().dom().contains(idx));
Proof              | Code(Proo ProofDire Body(Proo  |                         let unmap_core = choose|unmap_core|
Proof              | Code(Proo ProofDire Body(Proo  |                             s1.core_states.dom().contains(unmap_core)
Proof              | Code(Proo ProofDire Body(Proo  |                                 && match s1.core_states[unmap_core] {
Proof              | Code(Proo ProofDire Body(Proo  |                                 os::CoreState::UnmapWaiting { ULT_id, vaddr }
Proof              | Code(Proo ProofDire Body(Proo  |                                 | os::CoreState::UnmapOpExecuting { ULT_id, vaddr, .. }
Proof              | Code(Proo ProofDire Body(Proo  |                                 | os::CoreState::UnmapOpDone { ULT_id, vaddr, .. }
Proof              | Code(Proo ProofDire Body(Proo  |                                 | os::CoreState::UnmapShootdownWaiting { ULT_id, vaddr, .. } => {
Proof              | Code(Proo ProofDire Body(Proo  |                                     vaddr === idx
Proof              | Code(Proo ProofDire Body(Proo  |                                 },
Proof              | Code(Proo ProofDire Body(Proo  |                                 _ => false,
Proof              | Code(Proo ProofDire Body(Proo  |                             };
Proof              | Code(Proo ProofDire Body(Proo  |                         if (unmap_core != core) {
Proof              | Code(Proo ProofDire Body(Proo  |                             assert(s2.interp_pt_mem() == s1.interp_pt_mem().insert(vaddr, pte));
Proof              | Code(Proo ProofDire Body(Proo  |                             assert(s2.interp_pt_mem().dom().contains(idx));
Proof              | Code(Proo ProofDire Body(Proo  |                             assert(s2.core_states.dom().contains(unmap_core));
Proof              | Code(Proo ProofDire Body(Proo  |                             assert(s1.core_states[unmap_core] === s2.core_states[unmap_core]);
Proof              | Code(Proo ProofDire Body(Proo  |                         }
Proof              | Code(Proo ProofDire Body(Proo  |                     }
Proof              | Code(Proo ProofDire Body(Proo  |                 };
Proof              | Code(Proo ProofDire Body(Proo  |                 assert forall|idx|
Proof              | Code(Proo ProofDire Body(Proo  |                     s2.inflight_unmap_vaddr().contains(
Proof              | Code(Proo ProofDire Body(Proo  |                         idx,
Proof              | Code(Proo ProofDire Body(Proo  |                     ) implies s1.inflight_unmap_vaddr().contains(idx) by {
Proof              | Code(Proo ProofDire Body(Proo  |                     if (s2.inflight_unmap_vaddr().contains(idx)) {
Proof              | Code(Proo ProofDire Body(Proo  |                         assert(s2.interp_pt_mem().dom().contains(idx));
Layout             | Code(Proo ProofDire Body(Proo  | 
Proof              | Code(Proo ProofDire Body(Proo  |                         let unmap_core = choose|unmap_core|
Proof              | Code(Proo ProofDire Body(Proo  |                             s2.core_states.dom().contains(unmap_core)
Proof              | Code(Proo ProofDire Body(Proo  |                                 && match s1.core_states[unmap_core] {
Proof              | Code(Proo ProofDire Body(Proo  |                                 os::CoreState::UnmapWaiting { ULT_id, vaddr }
Proof              | Code(Proo ProofDire Body(Proo  |                                 | os::CoreState::UnmapOpExecuting { ULT_id, vaddr, .. }
Proof              | Code(Proo ProofDire Body(Proo  |                                 | os::CoreState::UnmapOpDone { ULT_id, vaddr, .. }
Proof              | Code(Proo ProofDire Body(Proo  |                                 | os::CoreState::UnmapShootdownWaiting { ULT_id, vaddr, .. } => {
Proof              | Code(Proo ProofDire Body(Proo  |                                     vaddr === idx
Proof              | Code(Proo ProofDire Body(Proo  |                                 },
Proof              | Code(Proo ProofDire Body(Proo  |                                 _ => false,
Proof              | Code(Proo ProofDire Body(Proo  |                             };
Proof              | Code(Proo ProofDire Body(Proo  |                         if (idx != vaddr) {
Proof              | Code(Proo ProofDire Body(Proo  |                             if (unmap_core != core) {
Proof              | Code(Proo ProofDire Body(Proo  |                                 assert(s2.interp_pt_mem() == s1.interp_pt_mem().insert(vaddr, pte));
Proof              | Code(Proo ProofDire Body(Proo  |                                 assert(s2.interp_pt_mem().dom().contains(idx));
Proof              | Code(Proo ProofDire Body(Proo  |                                 assert(s2.core_states.dom().contains(unmap_core));
Proof              | Code(Proo ProofDire Body(Proo  |                                 assert(s1.core_states[unmap_core] === s2.core_states[unmap_core]);
Proof              | Code(Proo ProofDire Body(Proo  |                             }
Proof              | Code(Proo ProofDire Body(Proo  |                         } else {
Proof              | Code(Proo ProofDire Body(Proo  |                             assert(!s1.core_states[core].is_idle()
Proof              | Code(Proo ProofDire Body(Proo  |                                 && !s1.core_states[unmap_core].is_idle() && overlap(
Proof              | Code(Proo ProofDire Body(Proo  |                                 MemRegion {
Proof              | Code(Proo ProofDire Body(Proo  |                                     base: s1.core_states[core].vaddr(),
Proof              | Code(Proo ProofDire Body(Proo  |                                     size: s1.core_states[core].vmem_pte_size(s1.interp_pt_mem()),
Proof              | Code(Proo ProofDire Body(Proo  |                                 },
Proof              | Code(Proo ProofDire Body(Proo  |                                 MemRegion {
Proof              | Code(Proo ProofDire Body(Proo  |                                     base: s1.core_states[unmap_core].vaddr(),
Proof              | Code(Proo ProofDire Body(Proo  |                                     size: s1.core_states[unmap_core].vmem_pte_size(
Proof              | Code(Proo ProofDire Body(Proo  |                                         s1.interp_pt_mem(),
Proof              | Code(Proo ProofDire Body(Proo  |                                     ),
Proof              | Code(Proo ProofDire Body(Proo  |                                 },
Proof              | Code(Proo ProofDire Body(Proo  |                             ));
Proof              | Code(Proo ProofDire Body(Proo  |                         }
Proof              | Code(Proo ProofDire Body(Proo  |                     }
Proof              | Code(Proo ProofDire Body(Proo  |                 };
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(s1.inflight_unmap_vaddr() =~= s2.inflight_unmap_vaddr());
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(hl_s2.mappings.contains_pair(vaddr, pte));
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(forall|idx|
Proof              | Code(Proo ProofDire Body(Proo  |                     hl_s1.mappings.contains_key(idx) ==> hl_s2.mappings.contains_key(idx));
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(forall|idx|
Proof              | Code(Proo ProofDire Body(Proo  |                     #![auto]
Proof              | Code(Proo ProofDire Body(Proo  |                     hl_s2.mappings.contains_key(idx) ==> hl_s1.mappings.insert(
Proof              | Code(Proo ProofDire Body(Proo  |                         vaddr,
Proof              | Code(Proo ProofDire Body(Proo  |                         pte,
Proof              | Code(Proo ProofDire Body(Proo  |                     ).contains_key(idx));
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(hl_s2.mappings =~= hl_s1.mappings.insert(vaddr, pte));
Proof              | Code(Proof) Body(Proof)        |                 lemma_mem_domain_from_mappings(
Proof              | Code(Proof) Body(Proof)        |                     c.interp().phys_mem_size,
Proof              | Code(Proof) Body(Proof)        |                     hl_s1.mappings,
Proof              | Code(Proof) Body(Proof)        |                     vaddr,
Proof              | Code(Proof) Body(Proof)        |                     pte,
Proof              | Code(Proof) Body(Proof)        |                 );
Proof              | Code(Proo ProofDire Body(Proo  |                 assert forall|idx: nat|
Proof              | Code(Proo ProofDire Body(Proo  |                     #![auto]
Proof              | Code(Proo ProofDire Body(Proo  |                     hl_s1.mem.dom().contains(idx) implies hl_s2.mem[idx] === hl_s1.mem[idx] by {
Comment            | Comment                        |                     // TODO overlapping mapped vmem
Proof              | Code(Proo ProofDire Body(Proo  |                     if (hl_s1.mem.dom().contains(idx)) {
Proof              | Code(Proo ProofDire Body(Proo  |                         assert(hlspec::mem_domain_from_mappings_contains(
Proof              | Code(Proo ProofDire Body(Proo  |                             hl_c.phys_mem_size,
Proof              | Code(Proo ProofDire Body(Proo  |                             idx,
Proof              | Code(Proo ProofDire Body(Proo  |                             hl_s1.mappings,
Proof              | Code(Proo ProofDire Body(Proo  |                         ));
Proof              | Code(Proo ProofDire Body(Proo  |                         assert(hl_s2.mem.dom().contains(idx));
Proof              | Code(Proo ProofDire Body(Proo  |                         let vidx = (idx * WORD_SIZE as nat);
Proof              | Code(Proo ProofDire Body(Proo  |                         let (mem_base, mem_pte): (nat, PageTableEntry) = choose|
Proof              | Code(Proo ProofDire Body(Proo  |                             base: nat,
Proof              | Code(Proo ProofDire Body(Proo  |                             pte: PageTableEntry,
Proof              | Code(Proo ProofDire Body(Proo  |                         |
Proof              | Code(Proo ProofDire Body(Proo  |                             {
Proof              | Code(Proo ProofDire Body(Proo  |                                 &&& #[trigger] hl_s1.mappings.contains_pair(base, pte)
Proof              | Code(Proo ProofDire Body(Proo  |                                 &&& hlspec::mem_domain_from_entry_contains(
Proof              | Code(Proo ProofDire Body(Proo  |                                     hl_c.phys_mem_size,
Proof              | Code(Proo ProofDire Body(Proo  |                                     vidx,
Proof              | Code(Proo ProofDire Body(Proo  |                                     base,
Proof              | Code(Proo ProofDire Body(Proo  |                                     pte,
Proof              | Code(Proo ProofDire Body(Proo  |                                 )
Proof              | Code(Proo ProofDire Body(Proo  |                             };
Proof              | Code(Proo ProofDire Body(Proo  |                         let paddr = (mem_pte.frame.base + (vidx - mem_base)) as nat;
Layout             | Code(Proo ProofDire Body(Proo  | 
Proof              | Code(Proo ProofDire Body(Proo  |                         assert(hl_s1.mappings.contains_pair(mem_base, mem_pte));
Proof              | Code(Proo ProofDire Body(Proo  |                         assert(between(vidx, mem_base, mem_base + mem_pte.frame.size));
Layout             | Code(Proo ProofDire Body(Proo  | 
Proof              | Code(Proo ProofDire Body(Proo  |                         assert forall|page, entry|
Proof              | Code(Proo ProofDire Body(Proo  |                             hl_s2.mappings.contains_pair(page, entry) && between(
Proof              | Code(Proo ProofDire Body(Proo  |                                 vidx,
Proof              | Code(Proo ProofDire Body(Proo  |                                 page,
Proof              | Code(Proo ProofDire Body(Proo  |                                 page + entry.frame.size,
Proof              | Code(Proo ProofDire Body(Proo  |                             ) implies (page == mem_base) && (entry == mem_pte) by {
Proof              | Code(Proo ProofDire Body(Proo  |                             if (hl_s2.mappings.contains_pair(page, entry) && between(
Proof              | Code(Proo ProofDire Body(Proo  |                                 vidx,
Proof              | Code(Proo ProofDire Body(Proo  |                                 page,
Proof              | Code(Proo ProofDire Body(Proo  |                                 page + entry.frame.size,
Proof              | Code(Proo ProofDire Body(Proo  |                             )) {
Proof              | Code(Proo ProofDire Body(Proo  |                                 assert(overlap(
Proof              | Code(Proo ProofDire Body(Proo  |                                     MemRegion { base: page, size: entry.frame.size },
Proof              | Code(Proo ProofDire Body(Proo  |                                     MemRegion { base: mem_base, size: mem_pte.frame.size },
Proof              | Code(Proo ProofDire Body(Proo  |                                 ));
Proof              | Code(Proo ProofDire Body(Proo  |                                 assert(s2.interp_pt_mem().dom().contains(page));
Proof              | Code(Proo ProofDire Body(Proo  |                                 assert(s2.interp_pt_mem().dom().contains(mem_base));
Proof              | Code(Proo ProofDire Body(Proo  |                                 if (s2.interp_pt_mem().remove(page).dom().contains(mem_base)) {
Proof              | Code(Proo ProofDire Body(Proo  |                                     assert(false);
Proof              | Code(Proo ProofDire Body(Proo  |                                 } else {
Proof              | Code(Proo ProofDire Body(Proo  |                                     assert(page == mem_base);
Proof              | Code(Proo ProofDire Body(Proo  |                                     assert(entry == mem_pte);
Proof              | Code(Proo ProofDire Body(Proo  |                                 }
Proof              | Code(Proo ProofDire Body(Proo  |                             }
Proof              | Code(Proo ProofDire Body(Proo  |                         }
Proof              | Code(Proo ProofDire Body(Proo  |                         assert forall|page, entry|
Proof              | Code(Proo ProofDire Body(Proo  |                             hl_s1.mappings.contains_pair(page, entry) && between(
Proof              | Code(Proo ProofDire Body(Proo  |                                 vidx,
Proof              | Code(Proo ProofDire Body(Proo  |                                 page,
Proof              | Code(Proo ProofDire Body(Proo  |                                 page + entry.frame.size,
Proof              | Code(Proo ProofDire Body(Proo  |                             ) implies (page == mem_base) && (entry == mem_pte) by {
Proof              | Code(Proo ProofDire Body(Proo  |                             assert(s1.effective_mappings().dom().subset_of(
Proof              | Code(Proo ProofDire Body(Proo  |                                 s2.effective_mappings().dom(),
Proof              | Code(Proo ProofDire Body(Proo  |                             ));
Proof              | Code(Proo ProofDire Body(Proo  |                             assert(hl_s1.mappings.submap_of(hl_s2.mappings));
Proof              | Code(Proo ProofDire Body(Proo  |                             assert(hl_s2.mappings.contains_pair(page, entry) && between(
Proof              | Code(Proo ProofDire Body(Proo  |                                 vidx,
Proof              | Code(Proo ProofDire Body(Proo  |                                 page,
Proof              | Code(Proo ProofDire Body(Proo  |                                 page + entry.frame.size,
Proof              | Code(Proo ProofDire Body(Proo  |                             ));
Proof              | Code(Proo ProofDire Body(Proo  |                         }
Proof              | Code(Proo ProofDire Body(Proo  |                     }
Proof              | Code(Proo ProofDire Body(Proo  |                 }
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(hl_s2.mem.dom() === hlspec::mem_domain_from_mappings(
Proof              | Code(Proo ProofDire Body(Proo  |                     hl_c.phys_mem_size,
Proof              | Code(Proo ProofDire Body(Proo  |                     hl_s2.mappings,
Proof              | Code(Proo ProofDire Body(Proo  |                 ));
Proof              | Code(Proof) Body(Proof)        |             } else {
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(!candidate_mapping_overlaps_existing_vmem(hl_s1.mappings, vaddr, pte));
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(result is Err);
Proof              | Code(Proof) Body(Proof)        |                 let os_overlap_vaddr = choose|b: nat|
Proof              | Code(Proof) Body(Proof)        |                     #![auto]
Proof              | Code(Proof) Body(Proof)        |                     {
Proof              | Code(Proof) Body(Proof)        |                         &&& s1.interp_pt_mem().dom().contains(b)
Proof              | Code(Proof) Body(Proof)        |                         &&& overlap(
Proof              | Code(Proof) Body(Proof)        |                             MemRegion { base: vaddr, size: pte.frame.size },
Proof              | Code(Proof) Body(Proof)        |                             MemRegion { base: b, size: s1.interp_pt_mem()[b].frame.size },
Proof              | Code(Proof) Body(Proof)        |                         )
Proof              | Code(Proof) Body(Proof)        |                     };
Layout             | Code(Proof) Body(Proof)        | 
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(s1.interp_pt_mem().dom().contains(os_overlap_vaddr));
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(!hl_s1.mappings.dom().contains(os_overlap_vaddr));
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(s1.inflight_unmap_vaddr().contains(os_overlap_vaddr));
Proof              | Code(Proof) Body(Proof)        |                 let unmap_core = choose|core|
Proof              | Code(Proof) Body(Proof)        |                     s1.core_states.dom().contains(core) && match s1.core_states[core] {
Proof              | Code(Proof) Body(Proof)        |                         os::CoreState::UnmapWaiting { ULT_id, vaddr }
Proof              | Code(Proof) Body(Proof)        |                         | os::CoreState::UnmapOpExecuting { ULT_id, vaddr, .. }
Proof              | Code(Proof) Body(Proof)        |                         | os::CoreState::UnmapOpDone { ULT_id, vaddr, .. }
Proof              | Code(Proof) Body(Proof)        |                         | os::CoreState::UnmapShootdownWaiting { ULT_id, vaddr, .. } => {
Proof              | Code(Proof) Body(Proof)        |                             vaddr === os_overlap_vaddr
Proof              | Code(Proof) Body(Proof)        |                         },
Proof              | Code(Proof) Body(Proof)        |                         _ => false,
Proof              | Code(Proof) Body(Proof)        |                     };
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(!s1.core_states[unmap_core].holds_lock());
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(s1.core_states[unmap_core] is UnmapWaiting);
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(overlap(
Proof              | Code(Proo ProofDire Body(Proo  |                     MemRegion { base: vaddr, size: pte.frame.size },
Proof              | Code(Proo ProofDire Body(Proo  |                     MemRegion {
Proof              | Code(Proo ProofDire Body(Proo  |                         base: s1.core_states[unmap_core]->UnmapWaiting_vaddr,
Proof              | Code(Proo ProofDire Body(Proo  |                         size:
Proof              | Code(Proo ProofDire Body(Proo  |                             s1.interp_pt_mem()[s1.core_states[unmap_core]->UnmapWaiting_vaddr].frame.size,
Proof              | Code(Proo ProofDire Body(Proo  |                     },
Proof              | Code(Proo ProofDire Body(Proo  |                 ));
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(hardware::valid_core(c.hw, core) && hardware::valid_core(c.hw, unmap_core)
Proof              | Code(Proo ProofDire Body(Proo  |                     && !s1.core_states[core].is_idle() && !s1.core_states[unmap_core].is_idle()
Proof              | Code(Proo ProofDire Body(Proo  |                     && overlap(
Proof              | Code(Proo ProofDire Body(Proo  |                     MemRegion {
Proof              | Code(Proo ProofDire Body(Proo  |                         base: s1.core_states[core].vaddr(),
Proof              | Code(Proo ProofDire Body(Proo  |                         size: s1.core_states[core].vmem_pte_size(s1.interp_pt_mem()),
Proof              | Code(Proo ProofDire Body(Proo  |                     },
Proof              | Code(Proo ProofDire Body(Proo  |                     MemRegion {
Proof              | Code(Proo ProofDire Body(Proo  |                         base: s1.core_states[unmap_core].vaddr(),
Proof              | Code(Proo ProofDire Body(Proo  |                         size: s1.core_states[unmap_core].vmem_pte_size(s1.interp_pt_mem()),
Proof              | Code(Proo ProofDire Body(Proo  |                     },
Proof              | Code(Proo ProofDire Body(Proo  |                 ) && (core != unmap_core));
Proof              | Code(Proof) Body(Proof)        |             }
Proof              | Code(Proof) Body(Proof)        |         }
Proof              | Code(Proof) Body(Proof)        |     }
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Proof              | Signature(Proof)               | proof fn step_Unmap_Start_refines(
Proof              | Signature(Proof)               |     c: os::OSConstants,
Proof              | Signature(Proof)               |     s1: os::OSVariables,
Proof              | Signature(Proof)               |     s2: os::OSVariables,
Proof              | Signature(Proof)               |     ULT_id: nat,
Proof              | Signature(Proof)               |     vaddr: nat,
Proof              | Signature(Proof)               | )
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         s1.inv(c),
Spec               | Signature(Proo FunctionSpec    |         s2.inv(c),
Spec               | Signature(Proo FunctionSpec    |         s1.sound,
Spec               | Signature(Proo FunctionSpec    |         os::step_Unmap_Start(c, s1, s2, ULT_id, vaddr),
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         hlspec::step_Unmap_start(c.interp(), s1.interp(c), s2.interp(c), ULT_id, vaddr),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proof) Body(Proof)        |     let hl_c = c.interp();
Proof              | Code(Proof) Body(Proof)        |     let hl_s1 = s1.interp(c);
Proof              | Code(Proof) Body(Proof)        |     let hl_s2 = s2.interp(c);
Proof              | Code(Proof) Body(Proof)        |     let core = c.ULT2core[ULT_id];
Proof              | Code(Proof) Body(Proof)        |     let pte = if (hl_s1.mappings.dom().contains(vaddr)) {
Proof              | Code(Proof) Body(Proof)        |         Some(hl_s1.mappings.index(vaddr))
Proof              | Code(Proof) Body(Proof)        |     } else {
Proof              | Code(Proof) Body(Proof)        |         Option::None
Proof              | Code(Proof) Body(Proof)        |     };
Proof              | Code(Proof) Body(Proof)        |     let pte_size = if (pte is Some) {
Proof              | Code(Proof) Body(Proof)        |         pte.unwrap().frame.size
Proof              | Code(Proof) Body(Proof)        |     } else {
Proof              | Code(Proof) Body(Proof)        |         0
Proof              | Code(Proof) Body(Proof)        |     };
Proof              | Code(Proo ProofDire Body(Proo  |     assert(hlspec::step_Unmap_enabled(vaddr));
Proof              | Code(Proo ProofDire Body(Proo  |     assert(hlspec::valid_thread(hl_c, ULT_id));
Proof              | Code(Proo ProofDire Body(Proo  |     assert(hl_s1.thread_state[ULT_id] === hlspec::AbstractArguments::Empty);
Layout             | Code(Proof) Body(Proof)        | 
Proof              | Code(Proof) Body(Proof)        |     lemma_unmap_soundness_equality(c, s1, vaddr, pte_size);
Proof              | Code(Proof) Body(Proof)        |     if hlspec::step_Unmap_sound(hl_s1.thread_state.values(), vaddr, pte_size) {
Proof              | Code(Proo ProofDire Body(Proo  |         assert(hl_s1.sound == hl_s2.sound);
Proof              | Code(Proo ProofDire Body(Proo  |         assert forall|key| #[trigger]
Proof              | Code(Proo ProofDire Body(Proo  |             hl_s1.thread_state.dom().contains(key) implies hl_s1.thread_state.insert(
Proof              | Code(Proo ProofDire Body(Proo  |             ULT_id,
Proof              | Code(Proo ProofDire Body(Proo  |             hlspec::AbstractArguments::Unmap { vaddr, pte },
Proof              | Code(Proo ProofDire Body(Proo  |         )[key] == hl_s2.thread_state[key] by {
Proof              | Code(Proo ProofDire Body(Proo  |             let core_of_key = c.ULT2core[key];
Proof              | Code(Proo ProofDire Body(Proo  |             if (core_of_key === core) {
Proof              | Code(Proo ProofDire Body(Proo  |                 if (key == ULT_id) {
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(s2.core_states == s1.core_states.insert(
Proof              | Code(Proo ProofDire Body(Proo  |                         core,
Proof              | Code(Proo ProofDire Body(Proo  |                         os::CoreState::UnmapWaiting { ULT_id, vaddr },
Proof              | Code(Proo ProofDire Body(Proo  |                     ));
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(s2.core_states[core] is UnmapWaiting);
Proof              | Code(Proo ProofDire Body(Proo  |                     let thread_pte = hl_s2.thread_state[ULT_id]->Unmap_pte;
Proof              | Code(Proo ProofDire Body(Proo  |                     if (s1.interp_pt_mem().dom().contains(vaddr)
Proof              | Code(Proo ProofDire Body(Proo  |                         && s1.inflight_unmap_vaddr().contains(vaddr)) {
Proof              | Code(Proo ProofDire Body(Proo  |                         let overlap_core = choose|core|
Proof              | Code(Proo ProofDire Body(Proo  |                             s1.core_states.dom().contains(core) && match s1.core_states[core] {
Proof              | Code(Proo ProofDire Body(Proo  |                                 os::CoreState::UnmapWaiting { ULT_id, vaddr: v }
Proof              | Code(Proo ProofDire Body(Proo  |                                 | os::CoreState::UnmapOpExecuting { ULT_id, vaddr: v, .. }
Proof              | Code(Proo ProofDire Body(Proo  |                                 | os::CoreState::UnmapOpDone { ULT_id, vaddr: v, .. }
Proof              | Code(Proo ProofDire Body(Proo  |                                 | os::CoreState::UnmapShootdownWaiting { ULT_id, vaddr: v, .. } => {
Proof              | Code(Proo ProofDire Body(Proo  |                                     vaddr === v
Proof              | Code(Proo ProofDire Body(Proo  |                                 },
Proof              | Code(Proo ProofDire Body(Proo  |                                 _ => false,
Proof              | Code(Proo ProofDire Body(Proo  |                             };
Comment            | Comment                        |                         //overlap{};
Proof              | Code(Proo ProofDire Body(Proo  |                         assert(!s2.core_states[core].is_idle()
Proof              | Code(Proo ProofDire Body(Proo  |                             && !s2.core_states[overlap_core].is_idle() && overlap(
Proof              | Code(Proo ProofDire Body(Proo  |                             MemRegion {
Proof              | Code(Proo ProofDire Body(Proo  |                                 base: s2.core_states[core].vaddr(),
Proof              | Code(Proo ProofDire Body(Proo  |                                 size: s2.core_states[core].vmem_pte_size(s2.interp_pt_mem()),
Proof              | Code(Proo ProofDire Body(Proo  |                             },
Proof              | Code(Proo ProofDire Body(Proo  |                             MemRegion {
Proof              | Code(Proo ProofDire Body(Proo  |                                 base: s2.core_states[overlap_core].vaddr(),
Proof              | Code(Proo ProofDire Body(Proo  |                                 size: s2.core_states[overlap_core].vmem_pte_size(
Proof              | Code(Proo ProofDire Body(Proo  |                                     s2.interp_pt_mem(),
Proof              | Code(Proo ProofDire Body(Proo  |                                 ),
Proof              | Code(Proo ProofDire Body(Proo  |                             },
Proof              | Code(Proo ProofDire Body(Proo  |                         ));
Proof              | Code(Proo ProofDire Body(Proo  |                     }
Proof              | Code(Proo ProofDire Body(Proo  |                 }
Proof              | Code(Proo ProofDire Body(Proo  |             } else {
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(s1.interp_pt_mem() =~= s2.interp_pt_mem());
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(s1.core_states[core_of_key] == s2.core_states[core_of_key]);
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(s1.core_states[c.ULT2core[key]] === s2.core_states[c.ULT2core[key]]);
Proof              | Code(Proo ProofDire Body(Proo  |             }
Proof              | Code(Proo ProofDire Body(Proo  |         }
Proof              | Code(Proo ProofDire Body(Proo  |         assert(hl_s2.thread_state === hl_s1.thread_state.insert(
Proof              | Code(Proo ProofDire Body(Proo  |             ULT_id,
Proof              | Code(Proo ProofDire Body(Proo  |             hlspec::AbstractArguments::Unmap { vaddr, pte },
Proof              | Code(Proo ProofDire Body(Proo  |         ));
Proof              | Code(Proof) Body(Proof)        |         if (pte is None) {
Proof              | Code(Proo ProofDire Body(Proo  |             assert(s1.interp_pt_mem() =~= s2.interp_pt_mem());
Proof              | Code(Proo ProofDire Body(Proo  |             assert forall|ids|
Proof              | Code(Proo ProofDire Body(Proo  |                 s1.inflight_unmap_vaddr().contains(ids) implies s2.inflight_unmap_vaddr().contains(
Proof              | Code(Proo ProofDire Body(Proo  |                 ids,
Proof              | Code(Proo ProofDire Body(Proo  |             ) by {
Proof              | Code(Proo ProofDire Body(Proo  |                 if s1.inflight_unmap_vaddr().contains(ids) {
Proof              | Code(Proo ProofDire Body(Proo  |                     let unmap_core = choose|cr|
Proof              | Code(Proo ProofDire Body(Proo  |                         s1.core_states.dom().contains(cr) && match s1.core_states[cr] {
Proof              | Code(Proo ProofDire Body(Proo  |                             os::CoreState::UnmapWaiting { ULT_id, vaddr }
Proof              | Code(Proo ProofDire Body(Proo  |                             | os::CoreState::UnmapOpExecuting { ULT_id, vaddr, .. }
Proof              | Code(Proo ProofDire Body(Proo  |                             | os::CoreState::UnmapOpDone { ULT_id, vaddr, .. }
Proof              | Code(Proo ProofDire Body(Proo  |                             | os::CoreState::UnmapShootdownWaiting { ULT_id, vaddr, .. } => {
Proof              | Code(Proo ProofDire Body(Proo  |                                 vaddr === ids
Proof              | Code(Proo ProofDire Body(Proo  |                             },
Proof              | Code(Proo ProofDire Body(Proo  |                             _ => false,
Proof              | Code(Proo ProofDire Body(Proo  |                         };
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(!(unmap_core == core));
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(s2.core_states.dom().contains(unmap_core));
Proof              | Code(Proo ProofDire Body(Proo  |                 }
Proof              | Code(Proo ProofDire Body(Proo  |             }
Proof              | Code(Proo ProofDire Body(Proo  |             assert(hl_s2.mappings === hl_s1.mappings);
Proof              | Code(Proo ProofDire Body(Proo  |             assert(hl_s2.mem =~= hl_s1.mem);
Proof              | Code(Proo ProofDire Body(Proo  |             assert(hl_s1.mem.dom() === hlspec::mem_domain_from_mappings(
Proof              | Code(Proo ProofDire Body(Proo  |                 hl_c.phys_mem_size,
Proof              | Code(Proo ProofDire Body(Proo  |                 hl_s1.mappings,
Proof              | Code(Proo ProofDire Body(Proo  |             ));
Proof              | Code(Proo ProofDire Body(Proo  |             assert(hl_s1.mappings =~= hl_s1.mappings.remove(vaddr));
Proof              | Code(Proo ProofDire Body(Proo  |             assert(hl_s2.mem.dom() === hlspec::mem_domain_from_mappings(
Proof              | Code(Proo ProofDire Body(Proo  |                 hl_c.phys_mem_size,
Proof              | Code(Proo ProofDire Body(Proo  |                 hl_s1.mappings.remove(vaddr),
Proof              | Code(Proo ProofDire Body(Proo  |             ));
Proof              | Code(Proof) Body(Proof)        |         } else {
Proof              | Code(Proo ProofDire Body(Proo  |             assert(s2.core_states == s1.core_states.insert(
Proof              | Code(Proo ProofDire Body(Proo  |                 core,
Proof              | Code(Proo ProofDire Body(Proo  |                 os::CoreState::UnmapWaiting { ULT_id, vaddr },
Proof              | Code(Proo ProofDire Body(Proo  |             ));
Proof              | Code(Proof) Body(Proof)        |             lemma_map_insert_value(
Proof              | Code(Proof) Body(Proof)        |                 s1.core_states,
Proof              | Code(Proof) Body(Proof)        |                 core,
Proof              | Code(Proof) Body(Proof)        |                 os::CoreState::UnmapWaiting { ULT_id, vaddr },
Proof              | Code(Proof) Body(Proof)        |             );
Comment            | Comment                        |             // assert(s2.inflight_unmap_vaddr().contains(vaddr));
Comment            | Comment                        |             //assert(!s2.effective_mappings().dom().contains(vaddr));
Proof              | Code(Proo ProofDire Body(Proo  |             assert forall|ids|
Proof              | Code(Proo ProofDire Body(Proo  |                 s1.inflight_unmap_vaddr().insert(vaddr).contains(
Proof              | Code(Proo ProofDire Body(Proo  |                     ids,
Proof              | Code(Proo ProofDire Body(Proo  |                 ) implies #[trigger] s2.inflight_unmap_vaddr().contains(ids) by {
Proof              | Code(Proo ProofDire Body(Proo  |                 if s1.inflight_unmap_vaddr().contains(ids) {
Proof              | Code(Proo ProofDire Body(Proo  |                     if (ids === vaddr) {
Proof              | Code(Proo ProofDire Body(Proo  |                     } else {
Proof              | Code(Proo ProofDire Body(Proo  |                         let unmap_core = choose|cr|
Proof              | Code(Proo ProofDire Body(Proo  |                             s1.core_states.dom().contains(cr) && match s1.core_states[cr] {
Proof              | Code(Proo ProofDire Body(Proo  |                                 os::CoreState::UnmapWaiting { ULT_id, vaddr }
Proof              | Code(Proo ProofDire Body(Proo  |                                 | os::CoreState::UnmapOpExecuting { ULT_id, vaddr, .. }
Proof              | Code(Proo ProofDire Body(Proo  |                                 | os::CoreState::UnmapOpDone { ULT_id, vaddr, .. }
Proof              | Code(Proo ProofDire Body(Proo  |                                 | os::CoreState::UnmapShootdownWaiting { ULT_id, vaddr, .. } => {
Proof              | Code(Proo ProofDire Body(Proo  |                                     vaddr === ids
Proof              | Code(Proo ProofDire Body(Proo  |                                 },
Proof              | Code(Proo ProofDire Body(Proo  |                                 _ => false,
Proof              | Code(Proo ProofDire Body(Proo  |                             };
Proof              | Code(Proo ProofDire Body(Proo  |                         assert(!(unmap_core == core));
Proof              | Code(Proo ProofDire Body(Proo  |                         assert(s2.core_states.dom().contains(unmap_core));
Proof              | Code(Proo ProofDire Body(Proo  |                     }
Proof              | Code(Proo ProofDire Body(Proo  |                 } else {
Proof              | Code(Proo ProofDire Body(Proo  |                 }
Proof              | Code(Proo ProofDire Body(Proo  |             }
Comment            | Comment                        |             //  assert(s2.inflight_unmap_vaddr() =~= s1.inflight_unmap_vaddr().insert(vaddr));
Layout             | Code(Proof) Body(Proof)        | 
Proof              | Code(Proo ProofDire Body(Proo  |             assert(hl_s2.mappings =~= hl_s1.mappings.remove(vaddr));
Proof              | Code(Proo ProofDire Body(Proo  |             assert(hl_s1.mappings =~= hl_s2.mappings.insert(vaddr, hl_s1.mappings.index(vaddr)));
Comment            | Comment                        |             //   assert(hl_s2.mem.dom() === hlspec::mem_domain_from_mappings(hl_c.phys_mem_size, hl_s1.mappings.remove(vaddr)));
Comment            | Comment                        |             //   assert(hl_s1.mem.dom() === hlspec::mem_domain_from_mappings(hl_c.phys_mem_size, hl_s1.mappings));
Proof              | Code(Proof) Body(Proof)        |             lemma_mem_domain_from_mappings(
Proof              | Code(Proof) Body(Proof)        |                 hl_c.phys_mem_size,
Proof              | Code(Proof) Body(Proof)        |                 hl_s2.mappings,
Proof              | Code(Proof) Body(Proof)        |                 vaddr,
Proof              | Code(Proof) Body(Proof)        |                 hl_s1.mappings.index(vaddr),
Proof              | Code(Proof) Body(Proof)        |             );
Comment            | Comment                        |             // assert( hl_s1.mem.dom() =~= hl_s2.mem.dom());
Proof              | Code(Proo ProofDire Body(Proo  |             assert forall|idx: nat| #![auto] hl_s2.mem.dom().contains(idx) implies hl_s2.mem[idx]
Proof              | Code(Proo ProofDire Body(Proo  |                 === hl_s1.mem[idx] by {
Proof              | Code(Proo ProofDire Body(Proo  |                 if (hl_s2.mem.dom().contains(idx)) {
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(hlspec::mem_domain_from_mappings_contains(
Proof              | Code(Proo ProofDire Body(Proo  |                         hl_c.phys_mem_size,
Proof              | Code(Proo ProofDire Body(Proo  |                         idx,
Proof              | Code(Proo ProofDire Body(Proo  |                         hl_s2.mappings,
Proof              | Code(Proo ProofDire Body(Proo  |                     ));
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(hl_s1.mem.dom().contains(idx));
Proof              | Code(Proo ProofDire Body(Proo  |                     let vidx = (idx * WORD_SIZE as nat);
Proof              | Code(Proo ProofDire Body(Proo  |                     let (mem_base, mem_pte): (nat, PageTableEntry) = choose|
Proof              | Code(Proo ProofDire Body(Proo  |                         base: nat,
Proof              | Code(Proo ProofDire Body(Proo  |                         pte: PageTableEntry,
Proof              | Code(Proo ProofDire Body(Proo  |                     |
Proof              | Code(Proo ProofDire Body(Proo  |                         {
Proof              | Code(Proo ProofDire Body(Proo  |                             &&& #[trigger] hl_s2.mappings.contains_pair(base, pte)
Proof              | Code(Proo ProofDire Body(Proo  |                             &&& hlspec::mem_domain_from_entry_contains(
Proof              | Code(Proo ProofDire Body(Proo  |                                 hl_c.phys_mem_size,
Proof              | Code(Proo ProofDire Body(Proo  |                                 vidx,
Proof              | Code(Proo ProofDire Body(Proo  |                                 base,
Proof              | Code(Proo ProofDire Body(Proo  |                                 pte,
Proof              | Code(Proo ProofDire Body(Proo  |                             )
Proof              | Code(Proo ProofDire Body(Proo  |                         };
Proof              | Code(Proo ProofDire Body(Proo  |                     let paddr = (mem_pte.frame.base + (vidx - mem_base)) as nat;
Layout             | Code(Proo ProofDire Body(Proo  | 
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(hl_s2.mappings.contains_pair(mem_base, mem_pte));
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(between(vidx, mem_base, mem_base + mem_pte.frame.size));
Layout             | Code(Proo ProofDire Body(Proo  | 
Proof              | Code(Proo ProofDire Body(Proo  |                     assert forall|page, entry|
Proof              | Code(Proo ProofDire Body(Proo  |                         hl_s1.mappings.contains_pair(page, entry) && between(
Proof              | Code(Proo ProofDire Body(Proo  |                             vidx,
Proof              | Code(Proo ProofDire Body(Proo  |                             page,
Proof              | Code(Proo ProofDire Body(Proo  |                             page + entry.frame.size,
Proof              | Code(Proo ProofDire Body(Proo  |                         ) implies (page == mem_base) && (entry == mem_pte) by {
Proof              | Code(Proo ProofDire Body(Proo  |                         assert(overlap(
Proof              | Code(Proo ProofDire Body(Proo  |                             MemRegion { base: page, size: entry.frame.size },
Proof              | Code(Proo ProofDire Body(Proo  |                             MemRegion { base: mem_base, size: mem_pte.frame.size },
Proof              | Code(Proo ProofDire Body(Proo  |                         ));
Proof              | Code(Proo ProofDire Body(Proo  |                         assert(s1.interp_pt_mem().dom().contains(page));
Proof              | Code(Proo ProofDire Body(Proo  |                         assert(s1.interp_pt_mem().dom().contains(mem_base));
Proof              | Code(Proo ProofDire Body(Proo  |                         if (s1.interp_pt_mem().remove(page).dom().contains(mem_base)) {
Proof              | Code(Proo ProofDire Body(Proo  |                             assert(false);
Proof              | Code(Proo ProofDire Body(Proo  |                         } else {
Proof              | Code(Proo ProofDire Body(Proo  |                             assert(page == mem_base);
Proof              | Code(Proo ProofDire Body(Proo  |                             assert(entry == mem_pte);
Proof              | Code(Proo ProofDire Body(Proo  |                         }
Proof              | Code(Proo ProofDire Body(Proo  |                     }
Proof              | Code(Proo ProofDire Body(Proo  |                     assert forall|page, entry|
Proof              | Code(Proo ProofDire Body(Proo  |                         hl_s2.mappings.contains_pair(page, entry) && between(
Proof              | Code(Proo ProofDire Body(Proo  |                             vidx,
Proof              | Code(Proo ProofDire Body(Proo  |                             page,
Proof              | Code(Proo ProofDire Body(Proo  |                             page + entry.frame.size,
Proof              | Code(Proo ProofDire Body(Proo  |                         ) implies (page == mem_base) && (entry == mem_pte) by {
Proof              | Code(Proo ProofDire Body(Proo  |                         assert(s2.effective_mappings().dom().subset_of(
Proof              | Code(Proo ProofDire Body(Proo  |                             s1.effective_mappings().dom(),
Proof              | Code(Proo ProofDire Body(Proo  |                         ));
Proof              | Code(Proo ProofDire Body(Proo  |                         assert(hl_s2.mappings.submap_of(hl_s1.mappings));
Proof              | Code(Proo ProofDire Body(Proo  |                         assert(hl_s1.mappings.contains_pair(page, entry) && between(
Proof              | Code(Proo ProofDire Body(Proo  |                             vidx,
Proof              | Code(Proo ProofDire Body(Proo  |                             page,
Proof              | Code(Proo ProofDire Body(Proo  |                             page + entry.frame.size,
Proof              | Code(Proo ProofDire Body(Proo  |                         ));
Proof              | Code(Proo ProofDire Body(Proo  |                     }
Proof              | Code(Proo ProofDire Body(Proo  |                 }
Proof              | Code(Proo ProofDire Body(Proo  |             }
Proof              | Code(Proof) Body(Proof)        |         }
Proof              | Code(Proof) Body(Proof)        |     } else {
Proof              | Code(Proof) Body(Proof)        |     }
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Proof              | Signature(Proof)               | proof fn step_Unmap_Op_Start_refines(
Proof              | Signature(Proof)               |     c: os::OSConstants,
Proof              | Signature(Proof)               |     s1: os::OSVariables,
Proof              | Signature(Proof)               |     s2: os::OSVariables,
Proof              | Signature(Proof)               |     core: hardware::Core,
Proof              | Signature(Proof)               |     result: Result<(), ()>
Proof              | Signature(Proof)               | )
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         s1.inv(c),
Spec               | Signature(Proo FunctionSpec    |         s2.inv(c),
Spec               | Signature(Proo FunctionSpec    |         s1.sound,
Spec               | Signature(Proo FunctionSpec    |         os::step_Unmap_Op_Start(c, s1, s2, core, result),
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         hlspec::step_Stutter(c.interp(), s1.interp(c), s2.interp(c)),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proof) Body(Proof)        |     let hl_c = c.interp();
Proof              | Code(Proof) Body(Proof)        |     let hl_s1 = s1.interp(c);
Proof              | Code(Proof) Body(Proof)        |     let hl_s2 = s2.interp(c);
Layout             | Code(Proof) Body(Proof)        | 
Proof              | Code(Proo ProofDire Body(Proo  |     assert(s1.core_states[core] is UnmapWaiting);
Proof              | Code(Proof) Body(Proof)        |     let vaddr = s1.core_states[core]->UnmapWaiting_vaddr;
Layout             | Code(Proof) Body(Proof)        | 
Proof              | Code(Proo ProofDire Body(Proo  |     assert(hl_s1.thread_state.dom() === hl_s2.thread_state.dom());
Proof              | Code(Proo ProofDire Body(Proo  |     assert forall|key| #[trigger]
Proof              | Code(Proo ProofDire Body(Proo  |         hl_s1.thread_state.contains_key(key) implies hl_s1.thread_state[key] == hl_s2.thread_state[key] by {
Proof              | Code(Proo ProofDire Body(Proo  |         assert(c.valid_ULT(key));
Proof              | Code(Proo ProofDire Body(Proo  |         assert(hl_s2.thread_state.dom().contains(key));
Proof              | Code(Proo ProofDire Body(Proo  |         let core_of_key = c.ULT2core[key];
Proof              | Code(Proo ProofDire Body(Proo  |         assert(hardware::valid_core(c.hw, core));
Proof              | Code(Proo ProofDire Body(Proo  |         assert(s2.core_states[core].holds_lock());
Proof              | Code(Proo ProofDire Body(Proo  |         assert(hardware::valid_core(c.hw, core_of_key));
Proof              | Code(Proo ProofDire Body(Proo  |         if s2.core_states[core_of_key].holds_lock() {
Proof              | Code(Proo ProofDire Body(Proo  |             assert(core_of_key === core);
Proof              | Code(Proo ProofDire Body(Proo  |         } else {
Proof              | Code(Proo ProofDire Body(Proo  |             assert(!(core_of_key === core));
Proof              | Code(Proo ProofDire Body(Proo  |             assert(!s1.core_states[core_of_key].holds_lock());
Proof              | Code(Proo ProofDire Body(Proo  |             assert(s1.core_states.index(core_of_key) == s2.core_states.index(core_of_key));
Proof              | Code(Proo ProofDire Body(Proo  |             assert(s1.core_states[c.ULT2core[key]] === s2.core_states[c.ULT2core[key]]);
Proof              | Code(Proo ProofDire Body(Proo  |             if (s1.core_states.index(core_of_key) is UnmapWaiting) {
Proof              | Code(Proo ProofDire Body(Proo  |                 let vaddr_of_key = s1.core_states[core_of_key]->UnmapWaiting_vaddr;
Proof              | Code(Proo ProofDire Body(Proo  |                 if (vaddr_of_key == vaddr) {
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(overlap(
Proof              | Code(Proo ProofDire Body(Proo  |                         MemRegion {
Proof              | Code(Proo ProofDire Body(Proo  |                             base: s2.core_states[core_of_key].vaddr(),
Proof              | Code(Proo ProofDire Body(Proo  |                             size: s2.core_states[core_of_key].vmem_pte_size(s2.interp_pt_mem()),
Proof              | Code(Proo ProofDire Body(Proo  |                         },
Proof              | Code(Proo ProofDire Body(Proo  |                         MemRegion {
Proof              | Code(Proo ProofDire Body(Proo  |                             base: s2.core_states[core].vaddr(),
Proof              | Code(Proo ProofDire Body(Proo  |                             size: s2.core_states[core].vmem_pte_size(s2.interp_pt_mem()),
Proof              | Code(Proo ProofDire Body(Proo  |                         },
Proof              | Code(Proo ProofDire Body(Proo  |                     ));
Layout             | Code(Proo ProofDire Body(Proo  | 
Proof              | Code(Proo ProofDire Body(Proo  |                 } else {
Proof              | Code(Proo ProofDire Body(Proo  |                 }
Proof              | Code(Proo ProofDire Body(Proo  |             } else {
Proof              | Code(Proo ProofDire Body(Proo  |             }
Proof              | Code(Proo ProofDire Body(Proo  |         }
Proof              | Code(Proo ProofDire Body(Proo  |     }
Proof              | Code(Proo ProofDire Body(Proo  |     assert(hl_s1.thread_state =~= hl_s2.thread_state);
Proof              | Code(Proo ProofDire Body(Proo  |     assert(s1.interp_pt_mem().remove(vaddr) =~= s2.interp_pt_mem());
Proof              | Code(Proof) Body(Proof)        |     if (s1.interp_pt_mem().dom().contains(vaddr)) {
Proof              | Code(Proo ProofDire Body(Proo  |         assert(s1.core_states.dom().contains(core));
Proof              | Code(Proo ProofDire Body(Proo  |         assert(s1.inflight_unmap_vaddr().contains(vaddr));
Proof              | Code(Proo ProofDire Body(Proo  |         assert forall|ids|
Proof              | Code(Proo ProofDire Body(Proo  |             s1.inflight_unmap_vaddr().contains(
Proof              | Code(Proo ProofDire Body(Proo  |                 ids,
Proof              | Code(Proo ProofDire Body(Proo  |             ) implies #[trigger] s2.inflight_unmap_vaddr().insert(vaddr).contains(ids) by {
Proof              | Code(Proo ProofDire Body(Proo  |             if s1.inflight_unmap_vaddr().contains(ids) {
Proof              | Code(Proo ProofDire Body(Proo  |                 if (ids === vaddr) {
Proof              | Code(Proo ProofDire Body(Proo  |                 } else {
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(s1.interp_pt_mem().dom().contains(ids));
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(s2.interp_pt_mem().dom().contains(ids));
Proof              | Code(Proo ProofDire Body(Proo  |                     let unmap_core = choose|cr|
Proof              | Code(Proo ProofDire Body(Proo  |                         s1.core_states.dom().contains(cr) && match s1.core_states[cr] {
Proof              | Code(Proo ProofDire Body(Proo  |                             os::CoreState::UnmapWaiting { ULT_id, vaddr }
Proof              | Code(Proo ProofDire Body(Proo  |                             | os::CoreState::UnmapOpExecuting { ULT_id, vaddr, .. }
Proof              | Code(Proo ProofDire Body(Proo  |                             | os::CoreState::UnmapOpDone { ULT_id, vaddr, .. }
Proof              | Code(Proo ProofDire Body(Proo  |                             | os::CoreState::UnmapShootdownWaiting { ULT_id, vaddr, .. } => {
Proof              | Code(Proo ProofDire Body(Proo  |                                 vaddr === ids
Proof              | Code(Proo ProofDire Body(Proo  |                             },
Proof              | Code(Proo ProofDire Body(Proo  |                             _ => false,
Proof              | Code(Proo ProofDire Body(Proo  |                         };
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(!(unmap_core == core));
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(s2.core_states.dom().contains(unmap_core));
Proof              | Code(Proo ProofDire Body(Proo  |                 }
Proof              | Code(Proo ProofDire Body(Proo  |             } else {
Proof              | Code(Proo ProofDire Body(Proo  |             }
Proof              | Code(Proo ProofDire Body(Proo  |         }
Proof              | Code(Proo ProofDire Body(Proo  |         assert(s1.inflight_unmap_vaddr() =~= s2.inflight_unmap_vaddr().insert(vaddr));
Layout             | Code(Proof) Body(Proof)        | 
Proof              | Code(Proof) Body(Proof)        |     } else {
Proof              | Code(Proo ProofDire Body(Proo  |         assert(s1.interp_pt_mem() =~= s2.interp_pt_mem());
Proof              | Code(Proo ProofDire Body(Proo  |         assert forall|ids|
Proof              | Code(Proo ProofDire Body(Proo  |             s1.inflight_unmap_vaddr().contains(ids) implies s2.inflight_unmap_vaddr().contains(
Proof              | Code(Proo ProofDire Body(Proo  |             ids,
Proof              | Code(Proo ProofDire Body(Proo  |         ) by {
Proof              | Code(Proo ProofDire Body(Proo  |             if s1.inflight_unmap_vaddr().contains(ids) {
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(!(ids === vaddr));
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(s1.interp_pt_mem().dom().contains(ids));
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(s2.interp_pt_mem().dom().contains(ids));
Proof              | Code(Proo ProofDire Body(Proo  |                 let unmap_core = choose|cr|
Proof              | Code(Proo ProofDire Body(Proo  |                     s1.core_states.dom().contains(cr) && match s1.core_states[cr] {
Proof              | Code(Proo ProofDire Body(Proo  |                         os::CoreState::UnmapWaiting { ULT_id, vaddr }
Proof              | Code(Proo ProofDire Body(Proo  |                         | os::CoreState::UnmapOpExecuting { ULT_id, vaddr, .. }
Proof              | Code(Proo ProofDire Body(Proo  |                         | os::CoreState::UnmapOpDone { ULT_id, vaddr, .. }
Proof              | Code(Proo ProofDire Body(Proo  |                         | os::CoreState::UnmapShootdownWaiting { ULT_id, vaddr, .. } => {
Proof              | Code(Proo ProofDire Body(Proo  |                             vaddr === ids
Proof              | Code(Proo ProofDire Body(Proo  |                         },
Proof              | Code(Proo ProofDire Body(Proo  |                         _ => false,
Proof              | Code(Proo ProofDire Body(Proo  |                     };
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(!(unmap_core == core));
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(s2.core_states.dom().contains(unmap_core));
Proof              | Code(Proo ProofDire Body(Proo  |             } else {
Proof              | Code(Proo ProofDire Body(Proo  |             }
Proof              | Code(Proo ProofDire Body(Proo  |         }
Proof              | Code(Proo ProofDire Body(Proo  |         assert(s1.inflight_unmap_vaddr() =~= s2.inflight_unmap_vaddr());
Proof              | Code(Proof) Body(Proof)        |     }
Proof              | Code(Proo ProofDire Body(Proo  |     assert(s1.effective_mappings() =~= s2.effective_mappings())
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Proof              | Signature(Proof)               | proof fn step_Unmap_End_refines(
Proof              | Signature(Proof)               |     c: os::OSConstants,
Proof              | Signature(Proof)               |     s1: os::OSVariables,
Proof              | Signature(Proof)               |     s2: os::OSVariables,
Proof              | Signature(Proof)               |     core: hardware::Core,
Proof              | Signature(Proof)               | )
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         s1.inv(c),
Spec               | Signature(Proo FunctionSpec    |         s2.inv(c),
Spec               | Signature(Proo FunctionSpec    |         os::step_Unmap_End(c, s1, s2, core),
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         ({
Spec               | Signature(Proo FunctionSpec    |             &&& s1.core_states[core] matches os::CoreState::UnmapOpDone { result, ULT_id, .. }
Spec               | Signature(Proo FunctionSpec    |             &&& hlspec::step_Unmap_end(c.interp(), s1.interp(c), s2.interp(c), ULT_id, result_map_ok(result, |r| ()))
Spec               | Signature(Proo FunctionSpec    |         } || {
Spec               | Signature(Proo FunctionSpec    |             &&& s1.core_states[core] matches os::CoreState::UnmapShootdownWaiting {
Spec               | Signature(Proo FunctionSpec    |                 ULT_id,
Spec               | Signature(Proo FunctionSpec    |                 result,
Spec               | Signature(Proo FunctionSpec    |                 ..
Spec               | Signature(Proo FunctionSpec    |             }
Spec               | Signature(Proo FunctionSpec    |             &&& hlspec::step_Unmap_end(c.interp(), s1.interp(c), s2.interp(c), ULT_id, result_map_ok(result, |r| ()))
Spec               | Signature(Proo FunctionSpec    |         }),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proof) Body(Proof)        |     let hl_c = c.interp();
Proof              | Code(Proof) Body(Proof)        |     let hl_s1 = s1.interp(c);
Proof              | Code(Proof) Body(Proof)        |     let hl_s2 = s2.interp(c);
Proof              | Code(Proof) Body(Proof)        |     match s1.core_states[core] {
Proof              | Code(Proof) Body(Proof)        |         os::CoreState::UnmapShootdownWaiting { ULT_id, result, vaddr, .. }
Proof              | Code(Proof) Body(Proof)        |         | os::CoreState::UnmapOpDone { result, ULT_id, vaddr, .. } => {
Proof              | Code(Proo ProofDire Body(Proo  |             assert(hlspec::valid_thread(hl_c, ULT_id));
Proof              | Code(Proo ProofDire Body(Proo  |             assert(hl_s2.sound == hl_s1.sound);
Proof              | Code(Proo ProofDire Body(Proo  |             assert(hl_s2.thread_state === hl_s1.thread_state.insert(
Proof              | Code(Proo ProofDire Body(Proo  |                 ULT_id,
Proof              | Code(Proo ProofDire Body(Proo  |                 hlspec::AbstractArguments::Empty,
Proof              | Code(Proo ProofDire Body(Proo  |             ));
Proof              | Code(Proo ProofDire Body(Proo  |             assert(!s1.interp_pt_mem().dom().contains(vaddr));
Proof              | Code(Proo ProofDire Body(Proo  |             assert(!s2.interp_pt_mem().dom().contains(vaddr));
Proof              | Code(Proof) Body(Proof)        |             lemma_inflight_vaddr_equals_hl_unmap(c, s2);
Proof              | Code(Proof) Body(Proof)        |             lemma_inflight_vaddr_equals_hl_unmap(c, s1);
Proof              | Code(Proo ProofDire Body(Proo  |             assert forall|key|
Proof              | Code(Proo ProofDire Body(Proo  |                 s2.effective_mappings().dom().contains(
Proof              | Code(Proo ProofDire Body(Proo  |                     key,
Proof              | Code(Proo ProofDire Body(Proo  |                 ) implies s1.effective_mappings().dom().contains(key) by {
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(s2.interp_pt_mem().dom().contains(key));
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(s1.interp_pt_mem().dom().contains(key));
Proof              | Code(Proo ProofDire Body(Proo  |                 if (key == vaddr) {
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(false);
Proof              | Code(Proo ProofDire Body(Proo  |                 } else {
Proof              | Code(Proo ProofDire Body(Proo  |                     if (s1.inflight_unmap_vaddr().contains(key)) {
Proof              | Code(Proo ProofDire Body(Proo  |                         let threadstate = choose|thread_state|
Proof              | Code(Proo ProofDire Body(Proo  |                             {
Proof              | Code(Proo ProofDire Body(Proo  |                                 &&& s1.interp_thread_state(c).values().contains(thread_state)
Proof              | Code(Proo ProofDire Body(Proo  |                                 &&& s1.interp_pt_mem().dom().contains(key)
Proof              | Code(Proo ProofDire Body(Proo  |                                 &&& thread_state matches hlspec::AbstractArguments::Unmap {
Proof              | Code(Proo ProofDire Body(Proo  |                                     vaddr,
Proof              | Code(Proo ProofDire Body(Proo  |                                     ..
Proof              | Code(Proo ProofDire Body(Proo  |                                 }
Proof              | Code(Proo ProofDire Body(Proo  |                                 &&& vaddr === key
Proof              | Code(Proo ProofDire Body(Proo  |                             };
Proof              | Code(Proo ProofDire Body(Proo  |                         let ult_id = choose|id|
Proof              | Code(Proo ProofDire Body(Proo  |                             #![auto]
Proof              | Code(Proo ProofDire Body(Proo  |                             s1.interp_thread_state(c).dom().contains(id) && s1.interp_thread_state(
Proof              | Code(Proo ProofDire Body(Proo  |                                 c,
Proof              | Code(Proo ProofDire Body(Proo  |                             ).index(id) == threadstate;
Proof              | Code(Proo ProofDire Body(Proo  |                         assert(!(ult_id == ULT_id));
Proof              | Code(Proo ProofDire Body(Proo  |                         assert(s2.interp_thread_state(c).values().contains(threadstate));
Proof              | Code(Proo ProofDire Body(Proo  |                     } else {
Proof              | Code(Proo ProofDire Body(Proo  |                     }
Proof              | Code(Proo ProofDire Body(Proo  |                 }
Proof              | Code(Proo ProofDire Body(Proo  |             }
Proof              | Code(Proo ProofDire Body(Proo  |             assert(s1.effective_mappings().dom() =~= s2.effective_mappings().dom());
Proof              | Code(Proo ProofDire Body(Proo  |             assert(s1.effective_mappings() =~= s2.effective_mappings());
Proof              | Code(Proo ProofDire Body(Proo  |             assert(hl_s2.mappings === hl_s1.mappings);
Proof              | Code(Proo ProofDire Body(Proo  |             assert(hl_s2.mem === hl_s1.mem);
Proof              | Code(Proof) Body(Proof)        |         },
Proof              | Code(Proof) Body(Proof)        |         _ => {
Proof              | Code(Proo ProofDire Body(Proo  |             assert(false);
Proof              | Code(Proof) Body(Proof)        |         },
Proof              | Code(Proof) Body(Proof)        |     };
Layout             | Code(Proof) Body(Proof)        | 
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
                   |                                | } // verus!

# definitions_t.rs
                   |                                | #![verus::trusted]
                   |                                | 
Comment            | Comment                        | // trusted: these are used in trusted definitions
Comment            | Comment                        | //
Comment            | Comment                        | // `overlap_sanity_check` hardens a spec, so we don't count it as trusted
                   |                                | 
                   |                                | use vstd::prelude::*;
                   |                                | 
                   |                                | verus! {
                   |                                | 
Trusted            | MacroDefinition                | macro_rules! bitmask_inc {
Trusted            | MacroDefinition                |     ($low:expr,$high:expr) => {
Trusted            | MacroDefinition                |         (!(!0u64 << (($high+1u64)-$low))) << $low
Trusted            | MacroDefinition                |     }
Trusted            | MacroDefinition                | }
                   |                                | 
Directives         | Directive                      | pub(crate) use bitmask_inc;
                   |                                | 
Trusted            | MacroDefinition                | macro_rules! bit {
Trusted            | MacroDefinition                |     ($v:expr) => {
Trusted            | MacroDefinition                |         1u64 << $v
Trusted            | MacroDefinition                |     }
Trusted            | MacroDefinition                | }
                   |                                | 
Directives         | Directive                      | pub(crate) use bit;
                   |                                | 
Trusted            | Const(Exec)                    | pub const X86_NUM_LAYERS: usize = 4;
                   |                                | 
Trusted            | Const(Exec)                    | pub const X86_NUM_ENTRIES: usize = 512;
                   |                                | 
Comment            | Comment                        | // The maximum physical address width is between 32 and 52 bits.
Trusted            | Const(Exec) Directive          | #[verifier(external_body)]
Trusted            | Const(Exec)                    | pub const MAX_PHYADDR_WIDTH: u64 = unimplemented!();
                   |                                | 
Trusted            | Directive                      | #[verifier(external_body)]
Trusted            | Signature(Proof)               | pub proof fn axiom_max_phyaddr_width_facts()
Trusted            | Signature(Proo FunctionSpec    |     ensures
Trusted            | Signature(Proo FunctionSpec    |         32 <= MAX_PHYADDR_WIDTH <= 52,
Trusted            | Code(Proof) Body(Proof)        | ;
                   |                                | 
Comment            | Comment                        | // We cannot use a dual exec/spec constant for MAX_PHYADDR, because for those Verus currently
Comment            | Comment                        | // doesn't support manually guiding the no-overflow proofs.
Trusted            | Const(Spec)                    | pub spec const MAX_PHYADDR_SPEC: u64 = ((1u64 << MAX_PHYADDR_WIDTH) - 1u64) as u64;
                   |                                | 
Trusted            | Const(Exec) Directive          | #[verifier::when_used_as_spec(MAX_PHYADDR_SPEC)]
Trusted            | Const(Exec)                    | pub exec const MAX_PHYADDR: u64
Trusted            | Const(Exec)                    |     ensures
Trusted            | Const(Exec)                    |         MAX_PHYADDR == MAX_PHYADDR_SPEC,
Trusted            | Const(Exec)                    | {
Trusted            | Const(Exec)                    |     axiom_max_phyaddr_width_facts();
Trusted            | Const(Exec) ProofDirective     |     assert(1u64 << 32 == 0x100000000) by (compute);
Trusted            | Const(Exec) ProofDirective     |     assert(forall|m: u64, n: u64| n < m < 64 ==> 1u64 << n < 1u64 << m) by (bit_vector);
Trusted            | Const(Exec)                    |     (1u64 << MAX_PHYADDR_WIDTH) - 1u64
Trusted            | Const(Exec)                    | }
                   |                                | 
Trusted            | Const(Exec)                    | pub const WORD_SIZE: usize = 8;
                   |                                | 
Trusted            | Const(Exec)                    | pub const PAGE_SIZE: usize = 4096;
                   |                                | 
Trusted            | Const(Spec)                    | pub spec const X86_MAX_ENTRY_SIZE: nat = 512 * 512 * 512 * 4096;
                   |                                | 
Trusted            | Const(Spec)                    | pub spec const MAX_BASE: nat = X86_MAX_ENTRY_SIZE * (X86_NUM_ENTRIES as nat);
                   |                                | 
Trusted            | Const(Exec)                    | pub const L3_ENTRY_SIZE: usize = PAGE_SIZE;
                   |                                | 
Trusted            | Const(Exec)                    | pub const L2_ENTRY_SIZE: usize = 512 * L3_ENTRY_SIZE;
                   |                                | 
Trusted            | Const(Exec)                    | pub const L1_ENTRY_SIZE: usize = 512 * L2_ENTRY_SIZE;
                   |                                | 
Trusted            | Const(Exec)                    | pub const L0_ENTRY_SIZE: usize = 512 * L1_ENTRY_SIZE;
                   |                                | 
Trusted            | Signature(Spec)                | pub open spec fn index_from_offset(offset: nat, entry_size: nat) -> (res: nat)
Trusted            | Signature(Spec)                |     recommends
Trusted            | Signature(Spec)                |         entry_size > 0,
Trusted            | Code(Spec) Body(Spec)          | {
Trusted            | Code(Spec) Body(Spec)          |     offset / entry_size
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Signature(Spec)                | pub open spec fn index_from_base_and_addr(base: nat, addr: nat, entry_size: nat) -> nat
Trusted            | Signature(Spec)                |     recommends
Trusted            | Signature(Spec)                |         addr >= base,
Trusted            | Signature(Spec)                |         entry_size > 0,
Trusted            | Code(Spec) Body(Spec)          | {
Trusted            | Code(Spec) Body(Spec)          |     index_from_offset(sub(addr, base), entry_size)
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Code(Spec Signature Body(Spec  | pub open spec fn entry_base_from_index(base: nat, idx: nat, entry_size: nat) -> nat {
Trusted            | Code(Spec) Body(Spec)          |     base + idx * entry_size
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Code(Spec Signature Body(Spec  | pub open spec fn next_entry_base_from_index(base: nat, idx: nat, entry_size: nat) -> nat {
Trusted            | Code(Spec) Body(Spec)          |     base + (idx + 1) * entry_size
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Code(Spec Signature Body(Spec  | pub open spec fn candidate_mapping_in_bounds(base: nat, pte: PageTableEntry) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     base + pte.frame.size < x86_arch_spec.upper_vaddr(0, 0)
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Signature(Spec)                | pub open spec fn candidate_mapping_overlaps_existing_vmem(
Trusted            | Signature(Spec)                |     mappings: Map<nat, PageTableEntry>,
Trusted            | Signature(Spec)                |     base: nat,
Trusted            | Signature(Spec)                |     pte: PageTableEntry,
Trusted            | Code(Spec Signature Body(Spec  | ) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     exists|b: nat|
Trusted            | Code(Spec) Body(Spec)          |         #![auto]
Trusted            | Code(Spec) Body(Spec)          |         {
Trusted            | Code(Spec) Body(Spec)          |             &&& mappings.dom().contains(b)
Trusted            | Code(Spec) Body(Spec)          |             &&& overlap(
Trusted            | Code(Spec) Body(Spec)          |                 MemRegion { base: base, size: pte.frame.size },
Trusted            | Code(Spec) Body(Spec)          |                 MemRegion { base: b, size: mappings[b].frame.size },
Trusted            | Code(Spec) Body(Spec)          |             )
Trusted            | Code(Spec) Body(Spec)          |         }
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Signature(Spec)                | pub open spec fn candidate_mapping_overlaps_existing_pmem(
Trusted            | Signature(Spec)                |     mappings: Map<nat, PageTableEntry>,
Trusted            | Signature(Spec)                |     pte: PageTableEntry,
Trusted            | Code(Spec Signature Body(Spec  | ) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     exists|b: nat|
Trusted            | Code(Spec) Body(Spec)          |         #![auto]
Trusted            | Code(Spec) Body(Spec)          |         {
Trusted            | Code(Spec) Body(Spec)          |             &&& mappings.dom().contains(b)
Trusted            | Code(Spec) Body(Spec)          |             &&& overlap(pte.frame, mappings.index(b).frame)
Trusted            | Code(Spec) Body(Spec)          |         }
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Code(Spec Signature Body(Spec  | pub open spec(checked) fn aligned(addr: nat, size: nat) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     addr % size == 0
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Code(Spec Signature Body(Spec  | pub open spec fn between(x: nat, a: nat, b: nat) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     a <= x && x < b
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Signature(Spec)                | pub open spec fn new_seq<T>(i: nat, e: T) -> Seq<T>
Trusted            | Signature(Spec FunctionSpec    |     decreases i,
Trusted            | Code(Spec) Body(Spec)          | {
Trusted            | Code(Spec) Body(Spec)          |     if i == 0 {
Trusted            | Code(Spec) Body(Spec)          |         seq![]
Trusted            | Code(Spec) Body(Spec)          |     } else {
Trusted            | Code(Spec) Body(Spec)          |         new_seq((i - 1) as nat, e).push(e)
Trusted            | Code(Spec) Body(Spec)          |     }
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Comment            | Comment                        | //for Highlevel read write operations
Trusted            | DatatypeDecl                   | pub enum LoadResult {
Trusted            | DatatypeDecl                   |     Undefined,
Trusted            | DatatypeDecl                   |     Value(nat),  // word-sized load
Trusted            | DatatypeDecl                   | }
                   |                                | 
Trusted            | DatatypeDecl                   | pub enum StoreResult {
Trusted            | DatatypeDecl                   |     Undefined,
Trusted            | DatatypeDecl                   |     Ok,
Trusted            | DatatypeDecl                   | }
                   |                                | 
Trusted            | DatatypeDecl Directive         | #[allow(inconsistent_fields)]
Trusted            | DatatypeDecl                   | pub enum RWOp {
Trusted            | DatatypeDecl                   |     Store { new_value: nat, result: StoreResult },
Trusted            | DatatypeDecl                   |     Load { is_exec: bool, result: LoadResult },
Trusted            | DatatypeDecl                   | }
                   |                                | 
Comment            | Comment                        | //for Hardware read write operations
Trusted            | DatatypeDecl                   | pub enum HWLoadResult {
Trusted            | DatatypeDecl                   |     Pagefault,
Trusted            | DatatypeDecl                   |     Value(nat),  // word-sized load
Trusted            | DatatypeDecl                   | }
                   |                                | 
Trusted            | DatatypeDecl                   | pub enum HWStoreResult {
Trusted            | DatatypeDecl                   |     Pagefault,
Trusted            | DatatypeDecl                   |     Ok,
Trusted            | DatatypeDecl                   | }
                   |                                | 
Trusted            | DatatypeDecl Directive         | #[allow(inconsistent_fields)]
Trusted            | DatatypeDecl                   | pub enum HWRWOp {
Trusted            | DatatypeDecl                   |     Store { new_value: nat, result: HWStoreResult },
Trusted            | DatatypeDecl                   |     Load { is_exec: bool, result: HWLoadResult },
Trusted            | DatatypeDecl                   | }
                   |                                | 
Trusted            | DatatypeDecl                   | pub struct MemRegion {
Trusted            | DatatypeDecl                   |     pub base: nat,
Trusted            | DatatypeDecl                   |     pub size: nat,
Trusted            | DatatypeDecl                   | }
                   |                                | 
                   | Impl                           | impl MemRegion {
Trusted            | Code(S Impl Signat Body(S      |     pub open spec fn contains(self, addr: nat) -> bool {
Trusted            | Code(Spec Impl Body(Spec       |         between(addr, self.base, self.base + self.size)
Trusted            | Code(Spec Impl Body(Spec       |     }
                   | Impl                           | }
                   |                                | 
Trusted            | Code(Spec Signature Body(Spec  | pub open spec fn above_zero(size: nat) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     size > 0
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Code(Spec Signature Body(Spec  | pub open spec fn overlap(region1: MemRegion, region2: MemRegion) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     if region1.base <= region2.base {
Trusted            | Code(Spec) Body(Spec)          |         ||| region1.base == region2.base
Trusted            | Code(Spec) Body(Spec)          |         ||| region2.base < region1.base + region1.size
Trusted            | Code(Spec) Body(Spec)          |     } else {
Trusted            | Code(Spec) Body(Spec)          |         region1.base < region2.base + region2.size
Trusted            | Code(Spec) Body(Spec)          |     }
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Comment            | Comment                        | // hardens spec for overlap
                   |                                | #[verus::line_count::ignore]
                   |                                | proof fn overlap_sanity_check() {
                   |                                |     assert(overlap(MemRegion { base: 0, size: 4096 }, MemRegion { base: 0, size: 4096 }));
                   |                                |     assert(overlap(MemRegion { base: 0, size: 8192 }, MemRegion { base: 0, size: 4096 }));
                   |                                |     assert(overlap(MemRegion { base: 0, size: 4096 }, MemRegion { base: 0, size: 8192 }));
                   |                                |     assert(overlap(MemRegion { base: 0, size: 8192 }, MemRegion { base: 4096, size: 4096 }));
                   |                                |     assert(!overlap(MemRegion { base: 4096, size: 8192 }, MemRegion { base: 0, size: 4096 }));
                   |                                |     assert(!overlap(MemRegion { base: 0, size: 4096 }, MemRegion { base: 8192, size: 16384 }));
                   |                                | }
                   |                                | 
Trusted            | DatatypeDecl                   | pub struct MemRegionExec {
Trusted            | DatatypeDecl                   |     pub base: usize,
Trusted            | DatatypeDecl                   |     pub size: usize,
Trusted            | DatatypeDecl                   | }
                   |                                | 
                   | Impl                           | impl MemRegionExec {
Trusted            | Code(S Impl Signat Body(S      |     pub open spec fn view(self) -> MemRegion {
Trusted            | Code(Spec Impl Body(Spec       |         MemRegion { base: self.base as nat, size: self.size as nat }
Trusted            | Code(Spec Impl Body(Spec       |     }
                   | Impl                           | }
                   |                                | 
Trusted            | DatatypeDecl                   | pub struct Flags {
Trusted            | DatatypeDecl                   |     pub is_writable: bool,
Trusted            | DatatypeDecl                   |     pub is_supervisor: bool,
Trusted            | DatatypeDecl                   |     pub disable_execute: bool,
Trusted            | DatatypeDecl                   | }
                   |                                | 
Trusted            | DatatypeDecl                   | pub struct PageTableEntry {
Trusted            | DatatypeDecl                   |     pub frame: MemRegion,
Comment            | Comment                        |     /// The `flags` field on a `PageTableEntry` denotes the combined flags of the entire
Comment            | Comment                        |     /// translation path to the entry. (See page table walk definition in hardware model,
Comment            | Comment                        |     /// `spec_t::hardware`.) However, because we always set the flags on directories to be
Comment            | Comment                        |     /// permissive these flags also correspond to the flags that we set for the frame mapping
Comment            | Comment                        |     /// corresponding to this `PageTableEntry`.
Trusted            | DatatypeDecl                   |     pub flags: Flags,
Trusted            | DatatypeDecl                   | }
                   |                                | 
Trusted            | DatatypeDecl                   | pub struct PageTableEntryExec {
Trusted            | DatatypeDecl                   |     pub frame: MemRegionExec,
Trusted            | DatatypeDecl                   |     pub flags: Flags,
Trusted            | DatatypeDecl                   | }
                   |                                | 
                   | Impl                           | impl PageTableEntryExec {
Trusted            | Code(S Impl Signat Body(S      |     pub open spec fn view(self) -> PageTableEntry {
Trusted            | Code(Spec Impl Body(Spec       |         PageTableEntry { frame: self.frame@, flags: self.flags }
Trusted            | Code(Spec Impl Body(Spec       |     }
                   | Impl                           | }
                   |                                | 
Trusted            | DatatypeDecl                   | pub ghost struct ArchLayer {
Comment            | Comment                        |     /// Address space size mapped by a single entry at this layer
Trusted            | DatatypeDecl                   |     pub entry_size: nat,
Comment            | Comment                        |     /// Number of entries at this layer
Trusted            | DatatypeDecl                   |     pub num_entries: nat,
Trusted            | DatatypeDecl                   | }
                   |                                | 
Trusted            | DatatypeDecl                   | pub ghost struct Arch {
Trusted            | DatatypeDecl                   |     pub layers: Seq<ArchLayer>,
Comment            | Comment                        |     // [512G, 1G  , 2M  , 4K  ]
Comment            | Comment                        |     // [512 , 512 , 512 , 512 ]
Trusted            | DatatypeDecl                   | }
                   |                                | 
                   | Impl                           | impl Arch {
Trusted            | Impl Signature(Spec            |     pub open spec(checked) fn entry_size(self, layer: nat) -> nat
Trusted            | Impl Signature(Spec            |         recommends
Trusted            | Impl Signature(Spec            |             layer < self.layers.len(),
Trusted            | Code(Spec Impl Body(Spec       |     {
Trusted            | Code(Spec Impl Body(Spec       |         self.layers.index(layer as int).entry_size
Trusted            | Code(Spec Impl Body(Spec       |     }
                   | Impl                           | 
Trusted            | Impl Signature(Spec            |     pub open spec(checked) fn num_entries(self, layer: nat) -> nat
Trusted            | Impl Signature(Spec            |         recommends
Trusted            | Impl Signature(Spec            |             layer < self.layers.len(),
Trusted            | Code(Spec Impl Body(Spec       |     {
Trusted            | Code(Spec Impl Body(Spec       |         self.layers.index(layer as int).num_entries
Trusted            | Code(Spec Impl Body(Spec       |     }
                   | Impl                           | 
Trusted            | Impl Signature(Spec            |     pub open spec(checked) fn upper_vaddr(self, layer: nat, base: nat) -> nat
Trusted            | Impl Signature(Spec            |         recommends
Trusted            | Impl Signature(Spec            |             self.inv(),
Trusted            | Impl Signature(Spec            |             layer < self.layers.len(),
Trusted            | Code(Spec Impl Body(Spec       |     {
Trusted            | Code(Spec Impl Body(Spec       |         self.entry_base(layer, base, self.num_entries(layer))
Trusted            | Code(Spec Impl Body(Spec       |     }
                   | Impl                           | 
Trusted            | Code(S Impl Signat Body(S      |     pub open spec(checked) fn inv(&self) -> bool {
Trusted            | Code(Spec Impl Body(Spec       |         &&& self.layers.len() <= X86_NUM_LAYERS
Trusted            | Code(Spec Impl Body(Spec       |         &&& forall|i: nat|
Trusted            | Code(Spec Impl Body(Spec       |             #![trigger self.entry_size(i)]
Trusted            | Code(Spec Impl Body(Spec       |             #![trigger self.num_entries(i)]
Trusted            | Code(Spec Impl Body(Spec       |             i < self.layers.len() ==> {
Trusted            | Code(Spec Impl Body(Spec       |                 &&& 0 < self.entry_size(i) <= X86_MAX_ENTRY_SIZE
Trusted            | Code(Spec Impl Body(Spec       |                 &&& 0 < self.num_entries(i) <= X86_NUM_ENTRIES
Trusted            | Code(Spec Impl Body(Spec       |                 &&& self.entry_size_is_next_layer_size(i)
Trusted            | Code(Spec Impl Body(Spec       |             }
Trusted            | Code(Spec Impl Body(Spec       |     }
                   | Impl                           | 
Trusted            | Impl Signature(Spec            |     pub open spec(checked) fn entry_size_is_next_layer_size(self, i: nat) -> bool
Trusted            | Impl Signature(Spec            |         recommends
Trusted            | Impl Signature(Spec            |             i < self.layers.len(),
Trusted            | Code(Spec Impl Body(Spec       |     {
Trusted            | Code(Spec Impl Body(Spec       |         i + 1 < self.layers.len() ==> self.entry_size(i) == self.entry_size((i + 1) as nat)
Trusted            | Code(Spec Impl Body(Spec       |             * self.num_entries((i + 1) as nat)
Trusted            | Code(Spec Impl Body(Spec       |     }
                   | Impl                           | 
Trusted            | Impl Signature(Spec            |     pub open spec(checked) fn contains_entry_size_at_index_atleast(
Trusted            | Impl Signature(Spec            |         &self,
Trusted            | Impl Signature(Spec            |         entry_size: nat,
Trusted            | Impl Signature(Spec            |         min_idx: nat,
Trusted            | Code(S Impl Signat Body(S      |     ) -> bool {
Trusted            | Code(Spec Impl Body(Spec       |         exists|i: nat|
Trusted            | Code(Spec Impl Body(Spec       |             min_idx <= i && i < self.layers.len() && #[trigger] self.entry_size(i) == entry_size
Trusted            | Code(Spec Impl Body(Spec       |     }
                   | Impl                           | 
Trusted            | Code(S Impl Signat Body(S      |     pub open spec(checked) fn contains_entry_size(&self, entry_size: nat) -> bool {
Trusted            | Code(Spec Impl Body(Spec       |         self.contains_entry_size_at_index_atleast(entry_size, 0)
Trusted            | Code(Spec Impl Body(Spec       |     }
                   | Impl                           | 
Trusted            | Impl Directive                 |     #[verifier(inline)]
Trusted            | Impl Signature(Spec            |     pub open spec(checked) fn index_for_vaddr(self, layer: nat, base: nat, vaddr: nat) -> nat
Trusted            | Impl Signature(Spec            |         recommends
Trusted            | Impl Signature(Spec            |             self.inv(),
Trusted            | Impl Signature(Spec            |             layer < self.layers.len(),
Trusted            | Impl Signature(Spec            |             base <= vaddr,
Trusted            | Code(Spec Impl Body(Spec       |     {
Trusted            | Code(Spec Impl Body(Spec       |         index_from_base_and_addr(base, vaddr, self.entry_size(layer))
Trusted            | Code(Spec Impl Body(Spec       |     }
                   | Impl                           | 
Trusted            | Impl Directive                 |     #[verifier(inline)]
Trusted            | Impl Signature(Spec            |     pub open spec(checked) fn entry_base(self, layer: nat, base: nat, idx: nat) -> nat
Trusted            | Impl Signature(Spec            |         recommends
Trusted            | Impl Signature(Spec            |             self.inv(),
Trusted            | Impl Signature(Spec            |             layer < self.layers.len(),
Trusted            | Code(Spec Impl Body(Spec       |     {
Comment            | Comment                        |         // base + idx * self.entry_size(layer)
Trusted            | Code(Spec Impl Body(Spec       |         entry_base_from_index(base, idx, self.entry_size(layer))
Trusted            | Code(Spec Impl Body(Spec       |     }
                   | Impl                           | 
Trusted            | Impl Directive                 |     #[verifier(inline)]
Trusted            | Impl Signature(Spec            |     pub open spec(checked) fn next_entry_base(self, layer: nat, base: nat, idx: nat) -> nat
Trusted            | Impl Signature(Spec            |         recommends
Trusted            | Impl Signature(Spec            |             self.inv(),
Trusted            | Impl Signature(Spec            |             layer < self.layers.len(),
Trusted            | Code(Spec Impl Body(Spec       |     {
Comment            | Comment                        |         // base + (idx + 1) * self.entry_size(layer)
Trusted            | Code(Spec Impl Body(Spec       |         next_entry_base_from_index(base, idx, self.entry_size(layer))
Trusted            | Code(Spec Impl Body(Spec       |     }
                   | Impl                           | }
                   |                                | 
Trusted            | DatatypeDecl                   | pub struct ArchLayerExec {
Comment            | Comment                        |     /// Address space size mapped by a single entry at this layer
Trusted            | DatatypeDecl                   |     pub entry_size: usize,
Comment            | Comment                        |     /// Number of entries of at this layer
Trusted            | DatatypeDecl                   |     pub num_entries: usize,
Trusted            | DatatypeDecl                   | }
                   |                                | 
Trusted            | DatatypeDecl                   | pub struct ArchExec {
Comment            | Comment                        |     // TODO: This could probably be an array, once we have support for that
Trusted            | DatatypeDecl                   |     pub layers: Vec<ArchLayerExec>,
Trusted            | DatatypeDecl                   | }
                   |                                | 
Comment            | Comment                        | // Why does this exec_spec function even exist:
Comment            | Comment                        | // - In some places we need to refer to the `Exec` versions of the structs in spec mode.
Comment            | Comment                        | // - We can't make x86_arch_exec a const because Verus panics if we initialize the vec directly,
Comment            | Comment                        | //   i.e. we need to push to a mut vec instead. (Does rust even support vecs in a const? Otherwise
Comment            | Comment                        | //   would need arrays.)
Comment            | Comment                        | // - Since x86_arch_exec is a function it has to have a mode, i.e. we need a version for exec usage
Comment            | Comment                        | //   and a version for spec usage. In the spec version we can't initialize the vec (same problem as
Comment            | Comment                        | //   above and can't use mut), i.e. we have to axiomatize their equivalence.
Comment            | Comment                        | // - We can't even have a proof function axiom because we need to show
Comment            | Comment                        | //   `x86_arch_exec_spec() == x86_arch_exec()`, where the second function call is an exec function.
Comment            | Comment                        | //   Thus the axiom is an assumed postcondition on the exec function itself.
Comment            | Comment                        | // - In addition to adding the postcondition, we also need a separate axiom to show that the view
Comment            | Comment                        | //   of x86_arch_exec_spec is the same as x86_arch_spec. This is provable but only with the
Comment            | Comment                        | //   postconditions on x86_arch_exec, which is an exec function. Consequently we can't use that
Comment            | Comment                        | //   postcondition in proof mode.
Comment            | Comment                        | // - All this mess should go away as soon as we can make that exec function the constant it ought
Comment            | Comment                        | //   to be.
Trusted            | Code(Spec Signature Body(Spec  | pub open spec fn x86_arch_exec_spec() -> ArchExec;
                   |                                | 
Trusted            | Directive                      | #[verifier(external_body)]
Trusted            | Signature(Proof)               | pub proof fn axiom_x86_arch_exec_spec()
Trusted            | Signature(Proo FunctionSpec    |     ensures
Trusted            | Signature(Proo FunctionSpec    |         x86_arch_exec_spec()@ == x86_arch_spec,
Trusted            | Code(Proof) Body(Proof)        | ;
                   |                                | 
Trusted            | Signature(Exec)                | pub exec fn x86_arch_exec() -> (res: ArchExec)
Trusted            | Signature(Exec FunctionSpec    |     ensures
Trusted            | Signature(Exec FunctionSpec    |         res.layers@ == seq![
Trusted            | Signature(Exec FunctionSpec    |             ArchLayerExec { entry_size: L0_ENTRY_SIZE, num_entries: 512 },
Trusted            | Signature(Exec FunctionSpec    |             ArchLayerExec { entry_size: L1_ENTRY_SIZE, num_entries: 512 },
Trusted            | Signature(Exec FunctionSpec    |             ArchLayerExec { entry_size: L2_ENTRY_SIZE, num_entries: 512 },
Trusted            | Signature(Exec FunctionSpec    |             ArchLayerExec { entry_size: L3_ENTRY_SIZE, num_entries: 512 },
Trusted            | Signature(Exec FunctionSpec    |         ],
Trusted            | Signature(Exec FunctionSpec    |         res@ === x86_arch_spec,
Trusted            | Signature(Exec FunctionSpec    |         res === x86_arch_exec_spec(),
Trusted            | Code(Exec) Body(Exec)          | {
Comment            | Comment                        |     // Can we somehow just initialize an immutable vec directly? Verus panics when I try do so
Comment            | Comment                        |     // (unless the function is external_body).
Trusted            | Code(Exec) Body(Exec)          |     let mut v = Vec::new();
Trusted            | Code(Exec) Body(Exec)          |     v.push(ArchLayerExec { entry_size: L0_ENTRY_SIZE, num_entries: 512 });
Trusted            | Code(Exec) Body(Exec)          |     v.push(ArchLayerExec { entry_size: L1_ENTRY_SIZE, num_entries: 512 });
Trusted            | Code(Exec) Body(Exec)          |     v.push(ArchLayerExec { entry_size: L2_ENTRY_SIZE, num_entries: 512 });
Trusted            | Code(Exec) Body(Exec)          |     v.push(ArchLayerExec { entry_size: L3_ENTRY_SIZE, num_entries: 512 });
Trusted            | Code(Exec) Body(Exec)          |     let res = ArchExec { layers: v };
Trusted            | Code(Exec ProofBloc Body(Exec  |     proof {
Trusted            | Code(E ProofB ProofD Body(E    |         assert(res@.layers =~= x86_arch_spec.layers);
Comment            | Comment                        |         // This is an axiom to establish the equivalence with x86_arch_exec_spec; See comments
Comment            | Comment                        |         // further up for explanation why this workaround is necessary.
Trusted            | Code(E ProofB ProofD Body(E    |         assume(res === x86_arch_exec_spec());
Trusted            | Code(Exec ProofBloc Body(Exec  |     }
Trusted            | Code(Exec) Body(Exec)          |     res
Trusted            | Code(Exec) Body(Exec)          | }
                   |                                | 
Trusted            | Const(Spec)                    | pub spec const x86_arch_spec: Arch = Arch {
Trusted            | Const(Spec)                    |     layers: seq![
Trusted            | Const(Spec)                    |         ArchLayer { entry_size: L0_ENTRY_SIZE as nat, num_entries: 512 },
Trusted            | Const(Spec)                    |         ArchLayer { entry_size: L1_ENTRY_SIZE as nat, num_entries: 512 },
Trusted            | Const(Spec)                    |         ArchLayer { entry_size: L2_ENTRY_SIZE as nat, num_entries: 512 },
Trusted            | Const(Spec)                    |         ArchLayer { entry_size: L3_ENTRY_SIZE as nat, num_entries: 512 },
Trusted            | Const(Spec)                    |     ],
Trusted            | Const(Spec)                    | };
                   |                                | 
Trusted            | Signature(Proof)               | pub proof fn x86_arch_spec_upper_bound()
Trusted            | Signature(Proo FunctionSpec    |     ensures
Trusted            | Signature(Proo FunctionSpec    |         x86_arch_spec.upper_vaddr(0, 0) == 512 * 512 * 1024 * 1024 * 1024,
Trusted            | Code(Proof) Body(Proof)        | {
Trusted            | Code(Proo ProofDire Body(Proo  |     assert(x86_arch_spec.upper_vaddr(0, 0) == 512 * 512 * 1024 * 1024 * 1024) by (compute_only);
Trusted            | Code(Proof) Body(Proof)        | }
                   |                                | 
                   |                                | } // verus!

# definitions_u.rs
                   |                                | use vstd::prelude::*;
                   |                                | 
                   |                                | use crate::definitions_t::{MAX_PHYADDR, axiom_max_phyaddr_width_facts, aligned, new_seq, Flags, ArchExec, ArchLayerExec};
                   |                                | 
                   |                                | verus! {
Proof              | Signature(Proof)               | pub proof fn lemma_maxphyaddr_facts()
Spec               | Signature(Proo FunctionSpec    |     ensures 0xFFFFFFFF <= MAX_PHYADDR <= 0xFFFFFFFFFFFFF
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proof) Body(Proof)        |     axiom_max_phyaddr_width_facts();
Proof              | Code(Proo ProofDire Body(Proo  |     assert(1u64 << 32 == 0x100000000) by (compute);
Proof              | Code(Proo ProofDire Body(Proo  |     assert(1u64 << 52 == 0x10000000000000) by (compute);
Proof              | Code(Proo ProofDire Body(Proo  |     assert(forall|m:u64,n:u64|  n < m < 64 ==> 1u64 << n < 1u64 << m) by (bit_vector);
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Proof              | Signature(Proof)               | pub proof fn lemma_new_seq<T>(i: nat, e: T)
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         new_seq(i, e).len() == i,
Spec               | Signature(Proo FunctionSpec    |         forall|j: nat| j < i ==> new_seq(i, e).index(j as int) === e,
Spec               | Signature(Proo FunctionSpec    |     decreases i
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proof) Body(Proof)        |     if i == 0 {
Proof              | Code(Proof) Body(Proof)        |     } else {
Proof              | Code(Proof) Body(Proof)        |         lemma_new_seq::<T>((i-1) as nat, e);
Proof              | Code(Proof) Body(Proof)        |     }
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Exec               | Signature(Exec)                | pub exec fn aligned_exec(addr: usize, size: usize) -> (res: bool)
Spec               | Signature(Exec FunctionSpec    |     requires
Spec               | Signature(Exec FunctionSpec    |         size > 0
Spec               | Signature(Exec FunctionSpec    |     ensures
Spec               | Signature(Exec FunctionSpec    |         res == aligned(addr as nat, size as nat)
Exec               | Code(Exec) Body(Exec)          | {
Exec               | Code(Exec) Body(Exec)          |     addr % size == 0
Exec               | Code(Exec) Body(Exec)          | }
                   |                                | 
Comment            | Comment                        | /// We always set permissive flags on directories. Restrictions happen on the frame mapping.
Spec               | Const(Spec)                    | pub spec const permissive_flags: Flags = Flags {
Spec               | Const(Spec)                    |     is_writable:     true,
Spec               | Const(Spec)                    |     is_supervisor:   false,
Spec               | Const(Spec)                    |     disable_execute: false,
Spec               | Const(Spec)                    | };
                   |                                | 
Comment            | Comment                        | // Sometimes z3 needs these concrete bounds to prove the no-overflow VC
Proof              | Signature(Proof)               | pub proof fn overflow_bounds()
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         X86_MAX_ENTRY_SIZE * (X86_NUM_ENTRIES + 1) < 0x10000000000000000,
Spec               | Signature(Proo FunctionSpec    |         MAX_BASE + X86_MAX_ENTRY_SIZE * (X86_NUM_ENTRIES + 1) < 0x10000000000000000,
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proo ProofDire Body(Proo  |     assert(X86_MAX_ENTRY_SIZE * (X86_NUM_ENTRIES + 1) < 0x10000000000000000) by (nonlinear_arith);
Proof              | Code(Proo ProofDire Body(Proo  |     assert(MAX_BASE + X86_MAX_ENTRY_SIZE * (X86_NUM_ENTRIES + 1) < 0x10000000000000000) by (nonlinear_arith);
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Comment            | Comment                        | // Architecture
                   |                                | 
Comment            | Comment                        | // page_size, next_sizes
Comment            | Comment                        | // 2**40    , [ 2 ** 30, 2 ** 20 ]
Comment            | Comment                        | // 2**30    , [ 2 ** 20 ]
Comment            | Comment                        | // 2**20    , [ ]
                   |                                | 
Comment            | Comment                        | // [es0 # es1 , es2 , es3 ] // entry_size
Comment            | Comment                        | // [1T  # 1G  , 1M  , 1K  ] // pages mapped at this level are this size <--
                   |                                | 
Comment            | Comment                        | // [n0  # n1  , n2  , n3  ] // number_of_entries
Comment            | Comment                        | // [1   # 1024, 1024, 1024]
                   |                                | 
Comment            | Comment                        | // es1 == es0 / n1 -- n1 * es1 == es0
Comment            | Comment                        | // es2 == es1 / n2 -- n2 * es2 == es1
Comment            | Comment                        | // es3 == es2 / n3 -- n3 * es3 == es2
                   |                                | 
Comment            | Comment                        | // [es0  #  es1 , es2 , es3 , es4 ] // entry_size
Comment            | Comment                        | // [256T #  512G, 1G  , 2M  , 4K  ]
Comment            | Comment                        | // [n0   #  n1  , n2  , n3  , n4  ] // number_of_entries
Comment            | Comment                        | // [     #  512 , 512 , 512 , 512 ]
Comment            | Comment                        | // [     #  9   , 9   , 9   , 9   , 12  ]
                   |                                | 
Directives         | Directive                      | use crate::definitions_t::{Arch, ArchLayer, MAX_BASE, X86_MAX_ENTRY_SIZE, X86_NUM_ENTRIES, x86_arch_spec, X86_NUM_LAYERS};
                   |                                | 
                   | Impl                           | impl Clone for ArchLayerExec {
Exec               | Code(E Impl Signat Body(E      |     fn clone(&self) -> Self {
Exec               | Code(Exec Impl Body(Exec       |         ArchLayerExec {
Exec               | Code(Exec Impl Body(Exec       |             entry_size: self.entry_size,
Exec               | Code(Exec Impl Body(Exec       |             num_entries: self.num_entries,
Exec               | Code(Exec Impl Body(Exec       |         }
Exec               | Code(Exec Impl Body(Exec       |     }
                   | Impl                           | }
                   |                                | 
                   | Impl                           | impl ArchLayerExec {
Spec               | Code(S Impl Signat Body(S      |     pub open spec fn view(self) -> ArchLayer {
Spec               | Code(Spec Impl Body(Spec       |         ArchLayer {
Spec               | Code(Spec Impl Body(Spec       |             entry_size: self.entry_size as nat,
Spec               | Code(Spec Impl Body(Spec       |             num_entries: self.num_entries as nat,
Spec               | Code(Spec Impl Body(Spec       |         }
Spec               | Code(Spec Impl Body(Spec       |     }
                   | Impl                           | }
                   |                                | 
                   | Impl                           | impl ArchExec {
Spec               | Code(S Impl Signat Body(S      |     pub open spec fn view(self) -> Arch {
Spec               | Code(Spec Impl Body(Spec       |         Arch {
Spec               | Code(Spec Impl Body(Spec       |             layers: self.layers@.map(|i: int, l: ArchLayerExec| l@),
Spec               | Code(Spec Impl Body(Spec       |         }
Spec               | Code(Spec Impl Body(Spec       |     }
                   | Impl                           | 
Exec               | Impl Signature(Exec            |     pub fn entry_size(&self, layer: usize) -> (res: usize)
Spec               | Impl Signature FunctionS       |         requires layer < self@.layers.len()
Spec               | Impl Signature FunctionS       |         ensures  res == self@.entry_size(layer as nat)
Exec               | Code(Exec Impl Body(Exec       |     {
Exec               | Code(Exec Impl Body(Exec       |         self.layers[layer].entry_size
Exec               | Code(Exec Impl Body(Exec       |     }
                   | Impl                           | 
Exec               | Impl Signature(Exec            |     pub fn num_entries(&self, layer: usize) -> (res: usize)
Spec               | Impl Signature FunctionS       |         requires layer < self@.layers.len()
Spec               | Impl Signature FunctionS       |         ensures  res == self@.num_entries(layer as nat)
Exec               | Code(Exec Impl Body(Exec       |     {
Exec               | Code(Exec Impl Body(Exec       |         self.layers[layer].num_entries
Exec               | Code(Exec Impl Body(Exec       |     }
                   | Impl                           | 
Exec               | Impl Signature(Exec            |     pub fn index_for_vaddr(&self, layer: usize, base: usize, vaddr: usize) -> (res: usize)
Spec               | Impl Signature FunctionS       |         requires
Spec               | Impl Signature FunctionS       |             self@.inv(),
Spec               | Impl Signature FunctionS       |             layer < self@.layers.len(),
Spec               | Impl Signature FunctionS       |             vaddr >= base,
Spec               | Impl Signature FunctionS       |         ensures
Spec               | Impl Signature FunctionS       |             res == self@.index_for_vaddr(layer as nat, base as nat, vaddr as nat),
Spec               | Impl Signature FunctionS       |             res == crate::definitions_t::index_from_base_and_addr(base as nat, vaddr as nat, self@.entry_size(layer as nat)),
Exec               | Code(Exec Impl Body(Exec       |     {
Exec               | Code(Exec Impl Body(Exec       |         let es = self.entry_size(layer);
Exec               | Code(Exec Impl Body(Exec       |         let offset = vaddr - base;
Exec               | Code(Exec Impl Body(Exec       |         let res = offset / es;
Proof              | Code(E ProofD Impl Body(E      |         assert(res as nat == offset as nat / es as nat) by (nonlinear_arith)
Proof              | Code(E ProofD Impl Body(E      |             requires
Proof              | Code(E ProofD Impl Body(E      |                 res == offset / es,
Proof              | Code(E ProofD Impl Body(E      |                 0 < es as int,
Proof              | Code(E ProofD Impl Body(E      |         { };
Exec               | Code(Exec Impl Body(Exec       |         res
Exec               | Code(Exec Impl Body(Exec       |     }
                   | Impl                           | 
Directives         | Impl Directive                 |     #[verifier(nonlinear)]
Exec               | Impl Signature(Exec            |     pub fn entry_base(&self, layer: usize, base: usize, idx: usize) -> (res: usize)
Spec               | Impl Signature FunctionS       |         requires
Spec               | Impl Signature FunctionS       |             self@.inv(),
Spec               | Impl Signature FunctionS       |             layer < self@.layers.len(),
Spec               | Impl Signature FunctionS       |             base <= MAX_BASE,
Spec               | Impl Signature FunctionS       |             idx <= X86_NUM_ENTRIES,
Spec               | Impl Signature FunctionS       |         ensures
Spec               | Impl Signature FunctionS       |             res == self@.entry_base(layer as nat, base as nat, idx as nat)
Exec               | Code(Exec Impl Body(Exec       |     {
Proof              | Code(E ProofB Impl Body(E      |         proof {
Comment            | Comment                        |             // FIXME: Weird error message when using the spec const here
Comment            | Comment                        |             // lib::mult_leq_mono_both(idx as nat, self@.entry_size(layer as nat), X86_NUM_ENTRIES as nat, X86_MAX_ENTRY_SIZE);
Proof              | Code(E ProofB Impl Body(E      |             crate::extra::mult_leq_mono_both(idx as nat, self@.entry_size(layer as nat), X86_NUM_ENTRIES as nat, 512 * 1024 * 1024 * 1024);
Proof              | Code(E ProofB Impl Body(E      |         }
Exec               | Code(Exec Impl Body(Exec       |         base + idx * self.entry_size(layer)
Exec               | Code(Exec Impl Body(Exec       |     }
                   | Impl                           | 
Exec               | Impl Signature(Exec            |     pub fn next_entry_base(&self, layer: usize, base: usize, idx: usize) -> (res: usize)
Spec               | Impl Signature FunctionS       |         requires
Spec               | Impl Signature FunctionS       |             self@.inv(),
Spec               | Impl Signature FunctionS       |             layer < self@.layers.len(),
Spec               | Impl Signature FunctionS       |             base <= MAX_BASE,
Spec               | Impl Signature FunctionS       |             idx <= X86_NUM_ENTRIES,
Spec               | Impl Signature FunctionS       |         ensures
Spec               | Impl Signature FunctionS       |             res == self@.next_entry_base(layer as nat, base as nat, idx as nat)
Exec               | Code(Exec Impl Body(Exec       |     {
Proof              | Code(E ProofB Impl Body(E      |         proof {
Proof              | Code(E ProofB Impl Body(E      |             overflow_bounds();
Proof              | Code(E ProofB Impl Body(E      |             let es = self@.entry_size(layer as nat);
Proof              | Code( Proof Proof Impl Body(   |             assert(0 <= (idx + 1) * es <= X86_MAX_ENTRY_SIZE * (X86_NUM_ENTRIES + 1)) by (nonlinear_arith)
Proof              | Code( Proof Proof Impl Body(   |                 requires es <= X86_MAX_ENTRY_SIZE, idx <= X86_NUM_ENTRIES
Comment            | Comment                        |                 { /* New instability with z3 4.10.1 */ };
Proof              | Code(E ProofB Impl Body(E      |         }
Exec               | Code(Exec Impl Body(Exec       |         let offset = (idx + 1) * self.entry_size(layer);
Proof              | Code(E ProofB Impl Body(E      |         proof {
Proof              | Code( Proof Proof Impl Body(   |             assert(base + offset <= MAX_BASE + X86_MAX_ENTRY_SIZE * (X86_NUM_ENTRIES + 1)) by (nonlinear_arith)
Proof              | Code( Proof Proof Impl Body(   |                 requires
Proof              | Code( Proof Proof Impl Body(   |                     0 <= offset <= X86_MAX_ENTRY_SIZE * (X86_NUM_ENTRIES + 1),
Proof              | Code( Proof Proof Impl Body(   |                     0 <= base <= MAX_BASE,
Proof              | Code( Proof Proof Impl Body(   |                 {};
Proof              | Code(E ProofB Impl Body(E      |         }
Exec               | Code(Exec Impl Body(Exec       |         base + offset
Exec               | Code(Exec Impl Body(Exec       |     }
                   | Impl                           | }
                   |                                | 
                   | Impl                           | impl Arch {
Proof              | Impl Signature(Proo            |     pub proof fn lemma_entry_sizes_aligned(self, i: nat, j: nat)
Spec               | Impl Signature FunctionS       |         requires
Spec               | Impl Signature FunctionS       |             self.inv(),
Spec               | Impl Signature FunctionS       |             i <= j,
Spec               | Impl Signature FunctionS       |             j < self.layers.len(),
Spec               | Impl Signature FunctionS       |         ensures
Spec               | Impl Signature FunctionS       |             aligned(self.entry_size(i), self.entry_size(j))
Spec               | Impl Signature FunctionS       |         decreases self.layers.len() - i
Proof              | Code(Proo Impl Body(Proo       |     {
Proof              | Code(Proo Impl Body(Proo       |         if i == j {
Proof              | Code(P ProofD Impl Body(P      |             assert(aligned(self.entry_size(i), self.entry_size(j))) by (nonlinear_arith)
Proof              | Code(P ProofD Impl Body(P      |                 requires i == j, self.entry_size(i) > 0,
Proof              | Code(P ProofD Impl Body(P      |             { };
Proof              | Code(Proo Impl Body(Proo       |         } else {
Proof              | Code(P ProofD Impl Body(P      |             assert(forall|a: int, b: int| #[trigger] (a * b) == b * a);
Proof              | Code(Proo Impl Body(Proo       |             self.lemma_entry_sizes_aligned(i+1,j);
Proof              | Code(P ProofD Impl Body(P      |             assert(aligned(self.entry_size(i+1), self.entry_size(j)));
Proof              | Code(P ProofD Impl Body(P      |             assert(self.entry_size(i) % self.entry_size(i + 1) == 0) by {
Comment            | Comment                        |                 // assert(self.inv());
Comment            | Comment                        |                 // assert(self.entry_size_is_next_layer_size(i));
Comment            | Comment                        |                 // assert(self.entry_size_is_next_layer_size(i + 1));
Comment            | Comment                        |                 // assert(self.entry_size(i) == self.entry_size((i + 1) as nat) * self.num_entries((i + 1) as nat));
Proof              | Code(P ProofD Impl Body(P      |                 assert(self.entry_size(i) % self.entry_size(i + 1) == 0) by (nonlinear_arith)
Proof              | Code(P ProofD Impl Body(P      |                     requires i != j, self.entry_size(i) > 0, self.entry_size(i + 1) > 0,
Proof              | Code(P ProofD Impl Body(P      |                     self.entry_size(i) == self.entry_size((i + 1) as nat) * self.num_entries((i + 1) as nat),
Proof              | Code(P ProofD Impl Body(P      |                 { };
Layout             | Code(P ProofD Impl Body(P      | 
Proof              | Code(P ProofD Impl Body(P      |             };
Proof              | Code(P ProofD Impl Body(P      |             assert(aligned(self.entry_size(i), self.entry_size(i+1)));
Proof              | Code(Proo Impl Body(Proo       |             crate::extra::aligned_transitive(self.entry_size(i), self.entry_size(i+1), self.entry_size(j));
Proof              | Code(P ProofD Impl Body(P      |             assert(aligned(self.entry_size(i), self.entry_size(j)));
Proof              | Code(Proo Impl Body(Proo       |         }
Proof              | Code(Proo Impl Body(Proo       |     }
                   | Impl                           | 
Proof              | Impl Signature(Proo            |     pub proof fn lemma_entry_sizes_aligned_auto(self)
Spec               | Impl Signature FunctionS       |         ensures
Spec               | Impl Signature FunctionS       |             forall|i: nat, j: nat|
Spec               | Impl Signature FunctionS       |                 self.inv() && i <= j && j < self.layers.len() ==>
Spec               | Impl Signature FunctionS       |                 aligned(self.entry_size(i), self.entry_size(j))
Proof              | Code(Proo Impl Body(Proo       |     {
Proof              | Code(Proo Impl Body(Proo       |         assert_forall_by(|i: nat, j: nat| {
Proof              | Code(Proo Impl Body(Proo       |             requires(self.inv() && i <= j && j < self.layers.len());
Proof              | Code(Proo Impl Body(Proo       |             ensures(aligned(self.entry_size(i), self.entry_size(j)));
Proof              | Code(Proo Impl Body(Proo       |             self.lemma_entry_sizes_aligned(i, j);
Proof              | Code(Proo Impl Body(Proo       |         });
Proof              | Code(Proo Impl Body(Proo       |     }
                   | Impl                           | 
Proof              | Impl Signature(Proo            |     pub proof fn lemma_entry_sizes_increase(self, i: nat, j: nat)
Spec               | Impl Signature FunctionS       |         requires
Spec               | Impl Signature FunctionS       |             self.inv(),
Spec               | Impl Signature FunctionS       |             i < j,
Spec               | Impl Signature FunctionS       |             j < self.layers.len(),
Spec               | Impl Signature FunctionS       |         ensures
Spec               | Impl Signature FunctionS       |             self.entry_size(i) >= self.entry_size(j),
Spec               | Impl Signature FunctionS       |         decreases j - i
Proof              | Code(Proo Impl Body(Proo       |     {
Proof              | Code(P ProofD Impl Body(P      |         assert(self.entry_size(i) >= self.entry_size(i + 1))
Proof              | Code(P ProofD Impl Body(P      |             by (nonlinear_arith)
Proof              | Code(P ProofD Impl Body(P      |             requires
Proof              | Code(P ProofD Impl Body(P      |                 i + 1 < self.layers.len(),
Proof              | Code(P ProofD Impl Body(P      |                 self.entry_size_is_next_layer_size(i),
Proof              | Code(P ProofD Impl Body(P      |                 self.num_entries(i + 1) > 0,
Proof              | Code(P ProofD Impl Body(P      |         { };
Proof              | Code(Proo Impl Body(Proo       |         if j == i + 1 {
Proof              | Code(Proo Impl Body(Proo       |         } else {
Proof              | Code(Proo Impl Body(Proo       |             self.lemma_entry_sizes_increase(i + 1, j);
Layout             | Code(Proo Impl Body(Proo       | 
Proof              | Code(Proo Impl Body(Proo       |         }
Proof              | Code(Proo Impl Body(Proo       |     }
                   | Impl                           | }
                   |                                | 
Directives         | Directive                      | #[verifier(nonlinear)]
Proof              | Signature(Proof)               | pub proof fn x86_arch_inv()
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         x86_arch_spec.inv()
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proo ProofDire Body(Proo  |     assert(x86_arch_spec.entry_size(3) == 4096);
Proof              | Code(Proo ProofDire Body(Proo  |     assert(x86_arch_spec.contains_entry_size(4096));
Proof              | Code(Proo ProofDire Body(Proo  |     assert(x86_arch_spec.layers.len() <= X86_NUM_LAYERS);
Proof              | Code(Proo ProofDire Body(Proo  |     assert forall|i:nat| i < x86_arch_spec.layers.len() implies {
Proof              | Code(Proo ProofDire Body(Proo  |             &&& 0 < #[trigger] x86_arch_spec.entry_size(i)  <= X86_MAX_ENTRY_SIZE
Proof              | Code(Proo ProofDire Body(Proo  |             &&& 0 < #[trigger] x86_arch_spec.num_entries(i) <= X86_NUM_ENTRIES
Proof              | Code(Proo ProofDire Body(Proo  |             &&& x86_arch_spec.entry_size_is_next_layer_size(i)
Proof              | Code(Proo ProofDire Body(Proo  |         } by {
Proof              | Code(Proo ProofDire Body(Proo  |         assert(0 < #[trigger] x86_arch_spec.entry_size(i)  <= X86_MAX_ENTRY_SIZE);
Proof              | Code(Proo ProofDire Body(Proo  |         assert(0 < #[trigger] x86_arch_spec.num_entries(i) <= X86_NUM_ENTRIES);
Proof              | Code(Proo ProofDire Body(Proo  |         assert(x86_arch_spec.entry_size_is_next_layer_size(i));
Proof              | Code(Proo ProofDire Body(Proo  |     }
Proof              | Code(Proo ProofDire Body(Proo  |     assert(x86_arch_spec.inv());
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
                   |                                | 
                   |                                | }
                   |                                | 

# spec_t/mod.rs
                   |                                | pub mod hardware;
                   |                                | pub mod hlspec;
                   |                                | pub mod os;
Comment            | Comment                        | //#[cfg(feature = "impl")]
Comment            | Comment                        | //pub mod impl_spec;
                   |                                | pub mod hlproof;
                   |                                | pub mod mem;
                   |                                | pub mod os_invariant;
                   |                                | #[cfg(feature = "more")]
                   |                                | pub mod atomic_mmu;

# spec_t/hardware.rs
                   |                                | #![verus::trusted]
Comment            | Comment                        | // trusted:
Comment            | Comment                        | // this defines the page table structure as interpreted by the hardware
Comment            | Comment                        | // and the hardware state machine
                   |                                | 
                   |                                | use crate::definitions_t::{
                   |                                |     aligned, axiom_max_phyaddr_width_facts, between, bit, bitmask_inc, Flags, HWRWOp, MemRegion,
                   |                                |     PageTableEntry, L1_ENTRY_SIZE, L2_ENTRY_SIZE, L3_ENTRY_SIZE, MAX_BASE, MAX_PHYADDR_WIDTH,
                   |                                |     PAGE_SIZE,
                   |                                | };
                   |                                | use crate::spec_t::mem::{self, word_index_spec};
                   |                                | use vstd::prelude::*;
                   |                                | 
                   |                                | verus! {
                   |                                | 
Trusted            | DatatypeDecl                   | pub struct HWConstants {
Trusted            | DatatypeDecl                   |     pub NUMA_no: nat,
Trusted            | DatatypeDecl                   |     pub core_no: nat,
Trusted            | DatatypeDecl                   |     pub phys_mem_size: nat,
Comment            | Comment                        |     //optionally: core_nos: Map<nat, nat>,
Trusted            | DatatypeDecl                   | }
                   |                                | 
Comment            | Comment                        | //TODO add invariant
Trusted            | DatatypeDecl                   | pub struct HWVariables {
Comment            | Comment                        |     /// Word-indexed physical memory
Trusted            | DatatypeDecl                   |     pub mem: Seq<nat>,
Trusted            | DatatypeDecl                   |     pub NUMAs: Map<nat, NUMAVariables>,
Comment            | Comment                        |     //one global page_table , handled by spec_pt, unconstrained by hw state
Trusted            | DatatypeDecl                   |     pub global_pt: mem::PageTableMemory,
Trusted            | DatatypeDecl                   | }
                   |                                | 
Trusted            | DatatypeDecl                   | pub struct NUMAVariables {
Trusted            | DatatypeDecl                   |     pub cores: Map<nat, CoreVariables>,
Trusted            | DatatypeDecl                   | }
                   |                                | 
Trusted            | DatatypeDecl                   | pub struct CoreVariables {
Trusted            | DatatypeDecl                   |     pub tlb: Map<nat, PageTableEntry>,
Trusted            | DatatypeDecl                   | }
                   |                                | 
Trusted            | DatatypeDecl                   | pub struct Core {
Trusted            | DatatypeDecl                   |     pub NUMA_id: nat,
Trusted            | DatatypeDecl                   |     pub core_id: nat,
Trusted            | DatatypeDecl                   | }
                   |                                | 
Trusted            | DatatypeDecl Directive         | #[allow(inconsistent_fields)]
Trusted            | DatatypeDecl                   | pub enum HWStep {
Trusted            | DatatypeDecl                   |     ReadWrite {
Trusted            | DatatypeDecl                   |         vaddr: nat,
Trusted            | DatatypeDecl                   |         paddr: nat,
Trusted            | DatatypeDecl                   |         op: HWRWOp,
Trusted            | DatatypeDecl                   |         pte: Option<(nat, PageTableEntry)>,
Trusted            | DatatypeDecl                   |         core: Core,
Trusted            | DatatypeDecl                   |     },
Trusted            | DatatypeDecl                   |     PTMemOp,
Trusted            | DatatypeDecl                   |     TLBFill { vaddr: nat, pte: PageTableEntry, core: Core },
Trusted            | DatatypeDecl                   |     TLBEvict { vaddr: nat, core: Core },
Trusted            | DatatypeDecl                   | }
                   |                                | 
Comment            | Comment                        | // FIXME: Including is_variant conditionally to avoid the warning when not building impl. But this
Comment            | Comment                        | // should disappear completely when I find the time to migrate to the new syntax.
Trusted            | DatatypeDecl Directive         | #[cfg_attr(feature = "impl", is_variant)]
Trusted            | DatatypeDecl                   | pub ghost enum GhostPageDirectoryEntry {
Trusted            | DatatypeDecl                   |     Directory {
Trusted            | DatatypeDecl                   |         addr: usize,
Comment            | Comment                        |         /// Present; must be 1 to map a page or reference a directory
Trusted            | DatatypeDecl                   |         flag_P: bool,
Comment            | Comment                        |         /// Read/write; if 0, writes may not be allowed to the page controlled by this entry
Trusted            | DatatypeDecl                   |         flag_RW: bool,
Comment            | Comment                        |         /// User/supervisor; user-mode accesses are not allowed to the page controlled by this entry
Trusted            | DatatypeDecl                   |         flag_US: bool,
Comment            | Comment                        |         /// Page-level write-through
Trusted            | DatatypeDecl                   |         flag_PWT: bool,
Comment            | Comment                        |         /// Page-level cache disable
Trusted            | DatatypeDecl                   |         flag_PCD: bool,
Comment            | Comment                        |         /// Accessed; indicates whether software has accessed the page referenced by this entry
Trusted            | DatatypeDecl                   |         flag_A: bool,
Comment            | Comment                        |         /// If IA32_EFER.NXE = 1, execute-disable (if 1, instruction fetches are not allowed from
Comment            | Comment                        |         /// the page controlled by this entry); otherwise, reserved (must be 0)
Trusted            | DatatypeDecl                   |         flag_XD: bool,
Trusted            | DatatypeDecl                   |     },
Trusted            | DatatypeDecl                   |     Page {
Trusted            | DatatypeDecl                   |         addr: usize,
Comment            | Comment                        |         /// Present; must be 1 to map a page or reference a directory
Trusted            | DatatypeDecl                   |         flag_P: bool,
Comment            | Comment                        |         /// Read/write; if 0, writes may not be allowed to the page controlled by this entry
Trusted            | DatatypeDecl                   |         flag_RW: bool,
Comment            | Comment                        |         /// User/supervisor; if 0, user-mode accesses are not allowed to the page controlled by this entry
Trusted            | DatatypeDecl                   |         flag_US: bool,
Comment            | Comment                        |         /// Page-level write-through
Trusted            | DatatypeDecl                   |         flag_PWT: bool,
Comment            | Comment                        |         /// Page-level cache disable
Trusted            | DatatypeDecl                   |         flag_PCD: bool,
Comment            | Comment                        |         /// Accessed; indicates whether software has accessed the page referenced by this entry
Trusted            | DatatypeDecl                   |         flag_A: bool,
Comment            | Comment                        |         /// Dirty; indicates whether software has written to the page referenced by this entry
Trusted            | DatatypeDecl                   |         flag_D: bool,
Comment            | Comment                        |         // /// Page size; must be 1 (otherwise, this entry references a directory)
Comment            | Comment                        |         // flag_PS: Option<bool>,
Comment            | Comment                        |         // PS is entirely determined by the Page variant and the layer
Comment            | Comment                        |         /// Global; if CR4.PGE = 1, determines whether the translation is global; ignored otherwise
Trusted            | DatatypeDecl                   |         flag_G: bool,
Comment            | Comment                        |         /// Indirectly determines the memory type used to access the page referenced by this entry
Trusted            | DatatypeDecl                   |         flag_PAT: bool,
Comment            | Comment                        |         /// If IA32_EFER.NXE = 1, execute-disable (if 1, instruction fetches are not allowed from
Comment            | Comment                        |         /// the page controlled by this entry); otherwise, reserved (must be 0)
Trusted            | DatatypeDecl                   |         flag_XD: bool,
Trusted            | DatatypeDecl                   |     },
Comment            | Comment                        |     /// An `Empty` entry is an entry that does not contain a valid mapping. I.e. the entry is
Comment            | Comment                        |     /// either empty or has a bit set that the intel manual designates as must-be-zero. Both empty
Comment            | Comment                        |     /// and invalid entries cause a page fault if used during translation.
Trusted            | DatatypeDecl                   |     Empty,
Trusted            | DatatypeDecl                   | }
                   |                                | 
Comment            | Comment                        | // layer:
Comment            | Comment                        | // 0 -> PML4
Comment            | Comment                        | // 1 -> PDPT, Page Directory Pointer Table
Comment            | Comment                        | // 2 -> PD, Page Directory
Comment            | Comment                        | // 3 -> PT, Page Table
Comment            | Comment                        | // MASK_FLAG_* are flags valid for entries at all levels.
Trusted            | Const(Exec)                    | pub const MASK_FLAG_P: u64 = bit!(0u64);
                   |                                | 
Trusted            | Const(Exec)                    | pub const MASK_FLAG_RW: u64 = bit!(1u64);
                   |                                | 
Trusted            | Const(Exec)                    | pub const MASK_FLAG_US: u64 = bit!(2u64);
                   |                                | 
Trusted            | Const(Exec)                    | pub const MASK_FLAG_PWT: u64 = bit!(3u64);
                   |                                | 
Trusted            | Const(Exec)                    | pub const MASK_FLAG_PCD: u64 = bit!(4u64);
                   |                                | 
Trusted            | Const(Exec)                    | pub const MASK_FLAG_A: u64 = bit!(5u64);
                   |                                | 
Trusted            | Const(Exec)                    | pub const MASK_FLAG_XD: u64 = bit!(63u64);
                   |                                | 
Comment            | Comment                        | // MASK_PG_FLAG_* are flags valid for all page mapping entries, unless a specialized version for that
Comment            | Comment                        | // layer exists, e.g. for layer 3 MASK_L3_PG_FLAG_PAT is used rather than MASK_PG_FLAG_PAT.
Trusted            | Const(Exec)                    | pub const MASK_PG_FLAG_D: u64 = bit!(6u64);
                   |                                | 
Trusted            | Const(Exec)                    | pub const MASK_PG_FLAG_G: u64 = bit!(8u64);
                   |                                | 
Trusted            | Const(Exec)                    | pub const MASK_PG_FLAG_PAT: u64 = bit!(12u64);
                   |                                | 
Trusted            | Const(Exec)                    | pub const MASK_L1_PG_FLAG_PS: u64 = bit!(7u64);
                   |                                | 
Trusted            | Const(Exec)                    | pub const MASK_L2_PG_FLAG_PS: u64 = bit!(7u64);
                   |                                | 
Trusted            | Const(Exec)                    | pub const MASK_L3_PG_FLAG_PAT: u64 = bit!(7u64);
                   |                                | 
Comment            | Comment                        | // const MASK_DIR_REFC:           u64 = bitmask_inc!(52u64,62u64); // Ignored bits for storing refcount in L3 and L2
Comment            | Comment                        | // const MASK_DIR_L1_REFC:        u64 = bitmask_inc!(8u64,12u64); // Ignored bits for storing refcount in L1
Comment            | Comment                        | // const MASK_DIR_REFC_SHIFT:     u64 = 52u64;
Comment            | Comment                        | // const MASK_DIR_L1_REFC_SHIFT:  u64 = 8u64;
Comment            | Comment                        | // In the implementation we can always use the 12:52 mask as the invariant guarantees that in the
Comment            | Comment                        | // other cases, the lower bits are already zero anyway.
Comment            | Comment                        | // We cannot use dual exec/spec constants here because for those Verus currently doesn't support
Comment            | Comment                        | // manually guiding the no-overflow proofs.
Trusted            | Const(Spec)                    | pub spec const MASK_ADDR_SPEC: u64 = bitmask_inc!(12u64, MAX_PHYADDR_WIDTH - 1);
                   |                                | 
Trusted            | Const(Exec) Directive          | #[verifier::when_used_as_spec(MASK_ADDR_SPEC)]
Trusted            | Const(Exec)                    | pub exec const MASK_ADDR: u64
Trusted            | Const(Exec)                    |     ensures
Trusted            | Const(Exec)                    |         MASK_ADDR == MASK_ADDR_SPEC,
Trusted            | Const(Exec)                    | {
Trusted            | Const(Exec)                    |     axiom_max_phyaddr_width_facts();
Trusted            | Const(Exec)                    |     bitmask_inc!(12u64, MAX_PHYADDR_WIDTH - 1)
Trusted            | Const(Exec)                    | }
                   |                                | 
Trusted            | Const(Spec)                    | pub spec const MASK_L1_PG_ADDR_SPEC: u64 = bitmask_inc!(30u64, MAX_PHYADDR_WIDTH - 1);
                   |                                | 
Trusted            | Const(Exec) Directive          | #[verifier::when_used_as_spec(MASK_L1_PG_ADDR_SPEC)]
Trusted            | Const(Exec)                    | pub exec const MASK_L1_PG_ADDR: u64
Trusted            | Const(Exec)                    |     ensures
Trusted            | Const(Exec)                    |         MASK_L1_PG_ADDR == MASK_L1_PG_ADDR_SPEC,
Trusted            | Const(Exec)                    | {
Trusted            | Const(Exec)                    |     axiom_max_phyaddr_width_facts();
Trusted            | Const(Exec)                    |     bitmask_inc!(30u64, MAX_PHYADDR_WIDTH - 1)
Trusted            | Const(Exec)                    | }
                   |                                | 
Trusted            | Const(Spec)                    | pub spec const MASK_L2_PG_ADDR_SPEC: u64 = bitmask_inc!(21u64, MAX_PHYADDR_WIDTH - 1);
                   |                                | 
Trusted            | Const(Exec) Directive          | #[verifier::when_used_as_spec(MASK_L2_PG_ADDR_SPEC)]
Trusted            | Const(Exec)                    | pub exec const MASK_L2_PG_ADDR: u64
Trusted            | Const(Exec)                    |     ensures
Trusted            | Const(Exec)                    |         MASK_L2_PG_ADDR == MASK_L2_PG_ADDR_SPEC,
Trusted            | Const(Exec)                    | {
Trusted            | Const(Exec)                    |     axiom_max_phyaddr_width_facts();
Trusted            | Const(Exec)                    |     bitmask_inc!(21u64, MAX_PHYADDR_WIDTH - 1)
Trusted            | Const(Exec)                    | }
                   |                                | 
Trusted            | Const(Spec)                    | pub spec const MASK_L3_PG_ADDR_SPEC: u64 = bitmask_inc!(12u64, MAX_PHYADDR_WIDTH - 1);
                   |                                | 
Trusted            | Const(Exec) Directive          | #[verifier::when_used_as_spec(MASK_L3_PG_ADDR_SPEC)]
Trusted            | Const(Exec)                    | pub exec const MASK_L3_PG_ADDR: u64
Trusted            | Const(Exec)                    |     ensures
Trusted            | Const(Exec)                    |         MASK_L3_PG_ADDR == MASK_L3_PG_ADDR_SPEC,
Trusted            | Const(Exec)                    | {
Trusted            | Const(Exec)                    |     axiom_max_phyaddr_width_facts();
Trusted            | Const(Exec)                    |     bitmask_inc!(12u64, MAX_PHYADDR_WIDTH - 1)
Trusted            | Const(Exec)                    | }
                   |                                | 
Trusted            | Const(Spec)                    | pub spec const MASK_DIR_ADDR_SPEC: u64 = MASK_ADDR;
                   |                                | 
Trusted            | Const(Exec) Directive          | #[verifier::when_used_as_spec(MASK_DIR_ADDR_SPEC)]
Trusted            | Const(Exec)                    | pub exec const MASK_DIR_ADDR: u64
Trusted            | Const(Exec)                    |     ensures
Trusted            | Const(Exec)                    |         MASK_DIR_ADDR == MASK_DIR_ADDR_SPEC,
Trusted            | Const(Exec)                    | {
Trusted            | Const(Exec)                    |     MASK_ADDR
Trusted            | Const(Exec)                    | }
                   |                                | 
Trusted            | DatatypeDecl Directive         | #[allow(repr_transparent_external_private_fields)]
Comment            | Comment                        | // An entry in any page directory (i.e. in PML4, PDPT, PD or PT)
Trusted            | DatatypeDecl Directive         | #[repr(transparent)]
Trusted            | DatatypeDecl                   | pub struct PageDirectoryEntry {
Trusted            | DatatypeDecl                   |     pub entry: u64,
Trusted            | DatatypeDecl GhostTracked(T    |     pub layer: Ghost<nat>,
Trusted            | DatatypeDecl                   | }
                   |                                | 
Comment            | Comment                        | // This impl defines everything necessary for the page table walk semantics.
Comment            | Comment                        | // PageDirectoryEntry is reused in the implementation, which has an additional impl block for it in
Comment            | Comment                        | // `impl_u::l2_impl`.
                   | Impl                           | impl PageDirectoryEntry {
Trusted            | Code(S Impl Signat Body(S      |     pub open spec fn view(self) -> GhostPageDirectoryEntry {
Trusted            | Code(Spec Impl Body(Spec       |         let v = self.entry;
Trusted            | Code(Spec Impl Body(Spec       |         let flag_P = v & MASK_FLAG_P == MASK_FLAG_P;
Trusted            | Code(Spec Impl Body(Spec       |         let flag_RW = v & MASK_FLAG_RW == MASK_FLAG_RW;
Trusted            | Code(Spec Impl Body(Spec       |         let flag_US = v & MASK_FLAG_US == MASK_FLAG_US;
Trusted            | Code(Spec Impl Body(Spec       |         let flag_PWT = v & MASK_FLAG_PWT == MASK_FLAG_PWT;
Trusted            | Code(Spec Impl Body(Spec       |         let flag_PCD = v & MASK_FLAG_PCD == MASK_FLAG_PCD;
Trusted            | Code(Spec Impl Body(Spec       |         let flag_A = v & MASK_FLAG_A == MASK_FLAG_A;
Trusted            | Code(Spec Impl Body(Spec       |         let flag_XD = v & MASK_FLAG_XD == MASK_FLAG_XD;
Trusted            | Code(Spec Impl Body(Spec       |         let flag_D = v & MASK_PG_FLAG_D == MASK_PG_FLAG_D;
Trusted            | Code(Spec Impl Body(Spec       |         let flag_G = v & MASK_PG_FLAG_G == MASK_PG_FLAG_G;
Trusted            | Code(Spec Impl Body(Spec       |         if self.layer@ <= 3 {
Trusted            | Code(Spec Impl Body(Spec       |             if v & MASK_FLAG_P == MASK_FLAG_P && self.all_mb0_bits_are_zero() {
Trusted            | Code(Spec Impl Body(Spec       |                 if self.layer == 0 {
Trusted            | Code(Spec Impl Body(Spec       |                     let addr = (v & MASK_ADDR) as usize;
Trusted            | Code(Spec Impl Body(Spec       |                     GhostPageDirectoryEntry::Directory {
Trusted            | Code(Spec Impl Body(Spec       |                         addr,
Trusted            | Code(Spec Impl Body(Spec       |                         flag_P,
Trusted            | Code(Spec Impl Body(Spec       |                         flag_RW,
Trusted            | Code(Spec Impl Body(Spec       |                         flag_US,
Trusted            | Code(Spec Impl Body(Spec       |                         flag_PWT,
Trusted            | Code(Spec Impl Body(Spec       |                         flag_PCD,
Trusted            | Code(Spec Impl Body(Spec       |                         flag_A,
Trusted            | Code(Spec Impl Body(Spec       |                         flag_XD,
Trusted            | Code(Spec Impl Body(Spec       |                     }
Trusted            | Code(Spec Impl Body(Spec       |                 } else if self.layer == 1 {
Trusted            | Code(Spec Impl Body(Spec       |                     if v & MASK_L1_PG_FLAG_PS == MASK_L1_PG_FLAG_PS {
Comment            | Comment                        |                         // super page mapping
Trusted            | Code(Spec Impl Body(Spec       |                         let addr = (v & MASK_L1_PG_ADDR) as usize;
Trusted            | Code(Spec Impl Body(Spec       |                         let flag_PAT = v & MASK_PG_FLAG_PAT == MASK_PG_FLAG_PAT;
Trusted            | Code(Spec Impl Body(Spec       |                         GhostPageDirectoryEntry::Page {
Trusted            | Code(Spec Impl Body(Spec       |                             addr,
Trusted            | Code(Spec Impl Body(Spec       |                             flag_P,
Trusted            | Code(Spec Impl Body(Spec       |                             flag_RW,
Trusted            | Code(Spec Impl Body(Spec       |                             flag_US,
Trusted            | Code(Spec Impl Body(Spec       |                             flag_PWT,
Trusted            | Code(Spec Impl Body(Spec       |                             flag_PCD,
Trusted            | Code(Spec Impl Body(Spec       |                             flag_A,
Trusted            | Code(Spec Impl Body(Spec       |                             flag_D,
Trusted            | Code(Spec Impl Body(Spec       |                             flag_G,
Trusted            | Code(Spec Impl Body(Spec       |                             flag_PAT,
Trusted            | Code(Spec Impl Body(Spec       |                             flag_XD,
Trusted            | Code(Spec Impl Body(Spec       |                         }
Trusted            | Code(Spec Impl Body(Spec       |                     } else {
Trusted            | Code(Spec Impl Body(Spec       |                         let addr = (v & MASK_ADDR) as usize;
Trusted            | Code(Spec Impl Body(Spec       |                         GhostPageDirectoryEntry::Directory {
Trusted            | Code(Spec Impl Body(Spec       |                             addr,
Trusted            | Code(Spec Impl Body(Spec       |                             flag_P,
Trusted            | Code(Spec Impl Body(Spec       |                             flag_RW,
Trusted            | Code(Spec Impl Body(Spec       |                             flag_US,
Trusted            | Code(Spec Impl Body(Spec       |                             flag_PWT,
Trusted            | Code(Spec Impl Body(Spec       |                             flag_PCD,
Trusted            | Code(Spec Impl Body(Spec       |                             flag_A,
Trusted            | Code(Spec Impl Body(Spec       |                             flag_XD,
Trusted            | Code(Spec Impl Body(Spec       |                         }
Trusted            | Code(Spec Impl Body(Spec       |                     }
Trusted            | Code(Spec Impl Body(Spec       |                 } else if self.layer == 2 {
Trusted            | Code(Spec Impl Body(Spec       |                     if v & MASK_L2_PG_FLAG_PS == MASK_L2_PG_FLAG_PS {
Comment            | Comment                        |                         // huge page mapping
Trusted            | Code(Spec Impl Body(Spec       |                         let addr = (v & MASK_L2_PG_ADDR) as usize;
Trusted            | Code(Spec Impl Body(Spec       |                         let flag_PAT = v & MASK_PG_FLAG_PAT == MASK_PG_FLAG_PAT;
Trusted            | Code(Spec Impl Body(Spec       |                         GhostPageDirectoryEntry::Page {
Trusted            | Code(Spec Impl Body(Spec       |                             addr,
Trusted            | Code(Spec Impl Body(Spec       |                             flag_P,
Trusted            | Code(Spec Impl Body(Spec       |                             flag_RW,
Trusted            | Code(Spec Impl Body(Spec       |                             flag_US,
Trusted            | Code(Spec Impl Body(Spec       |                             flag_PWT,
Trusted            | Code(Spec Impl Body(Spec       |                             flag_PCD,
Trusted            | Code(Spec Impl Body(Spec       |                             flag_A,
Trusted            | Code(Spec Impl Body(Spec       |                             flag_D,
Trusted            | Code(Spec Impl Body(Spec       |                             flag_G,
Trusted            | Code(Spec Impl Body(Spec       |                             flag_PAT,
Trusted            | Code(Spec Impl Body(Spec       |                             flag_XD,
Trusted            | Code(Spec Impl Body(Spec       |                         }
Trusted            | Code(Spec Impl Body(Spec       |                     } else {
Trusted            | Code(Spec Impl Body(Spec       |                         let addr = (v & MASK_ADDR) as usize;
Trusted            | Code(Spec Impl Body(Spec       |                         GhostPageDirectoryEntry::Directory {
Trusted            | Code(Spec Impl Body(Spec       |                             addr,
Trusted            | Code(Spec Impl Body(Spec       |                             flag_P,
Trusted            | Code(Spec Impl Body(Spec       |                             flag_RW,
Trusted            | Code(Spec Impl Body(Spec       |                             flag_US,
Trusted            | Code(Spec Impl Body(Spec       |                             flag_PWT,
Trusted            | Code(Spec Impl Body(Spec       |                             flag_PCD,
Trusted            | Code(Spec Impl Body(Spec       |                             flag_A,
Trusted            | Code(Spec Impl Body(Spec       |                             flag_XD,
Trusted            | Code(Spec Impl Body(Spec       |                         }
Trusted            | Code(Spec Impl Body(Spec       |                     }
Trusted            | Code(Spec Impl Body(Spec       |                 } else {
Comment            | Comment                        |                     // TODO: uncomment when we have inline proofs
Comment            | Comment                        |                     // assert(self.layer == 3);
Trusted            | Code(Spec Impl Body(Spec       |                     let addr = (v & MASK_L3_PG_ADDR) as usize;
Trusted            | Code(Spec Impl Body(Spec       |                     let flag_PAT = v & MASK_L3_PG_FLAG_PAT == MASK_L3_PG_FLAG_PAT;
Trusted            | Code(Spec Impl Body(Spec       |                     GhostPageDirectoryEntry::Page {
Trusted            | Code(Spec Impl Body(Spec       |                         addr,
Trusted            | Code(Spec Impl Body(Spec       |                         flag_P,
Trusted            | Code(Spec Impl Body(Spec       |                         flag_RW,
Trusted            | Code(Spec Impl Body(Spec       |                         flag_US,
Trusted            | Code(Spec Impl Body(Spec       |                         flag_PWT,
Trusted            | Code(Spec Impl Body(Spec       |                         flag_PCD,
Trusted            | Code(Spec Impl Body(Spec       |                         flag_A,
Trusted            | Code(Spec Impl Body(Spec       |                         flag_D,
Trusted            | Code(Spec Impl Body(Spec       |                         flag_G,
Trusted            | Code(Spec Impl Body(Spec       |                         flag_PAT,
Trusted            | Code(Spec Impl Body(Spec       |                         flag_XD,
Trusted            | Code(Spec Impl Body(Spec       |                     }
Trusted            | Code(Spec Impl Body(Spec       |                 }
Trusted            | Code(Spec Impl Body(Spec       |             } else {
Trusted            | Code(Spec Impl Body(Spec       |                 GhostPageDirectoryEntry::Empty
Trusted            | Code(Spec Impl Body(Spec       |             }
Trusted            | Code(Spec Impl Body(Spec       |         } else {
Trusted            | Code(Spec Impl Body(Spec       |             arbitrary()
Trusted            | Code(Spec Impl Body(Spec       |         }
Trusted            | Code(Spec Impl Body(Spec       |     }
                   | Impl                           | 
Comment            | Comment                        |     /// Returns `true` iff all must-be-zero bits for a given entry are zero.
Trusted            | Impl Directive                 |     #[verifier::opaque]
Trusted            | Impl Signature(Spec            |     pub open spec fn all_mb0_bits_are_zero(self) -> bool
Trusted            | Impl Signature(Spec            |         recommends
Trusted            | Impl Signature(Spec            |             self.layer@ <= 3,
Trusted            | Code(Spec Impl Body(Spec       |     {
Trusted            | Code(Spec Impl Body(Spec       |         if self.entry & MASK_FLAG_P == MASK_FLAG_P {
Trusted            | Code(Spec Impl Body(Spec       |             if self.layer == 0 {  // PML4, always directory
Comment            | Comment                        |                 // 51:M, 7
Trusted            | Code(Spec Impl Body(Spec       |                 &&& self.entry & bitmask_inc!(MAX_PHYADDR_WIDTH, 51) == 0
Trusted            | Code(Spec Impl Body(Spec       |                 &&& self.entry & bit!(7u64) == 0
Trusted            | Code(Spec Impl Body(Spec       |             } else if self.layer == 1 {  // PDPT
Trusted            | Code(Spec Impl Body(Spec       |                 if self.entry & MASK_L1_PG_FLAG_PS == MASK_L1_PG_FLAG_PS {
Comment            | Comment                        |                     // 51:M, 29:13
Trusted            | Code(Spec Impl Body(Spec       |                     &&& self.entry & bitmask_inc!(MAX_PHYADDR_WIDTH, 51) == 0
Trusted            | Code(Spec Impl Body(Spec       |                     &&& self.entry & bitmask_inc!(13u64,29u64) == 0
Trusted            | Code(Spec Impl Body(Spec       |                 } else {
Comment            | Comment                        |                     // 51:M, 7
Trusted            | Code(Spec Impl Body(Spec       |                     &&& self.entry & bitmask_inc!(MAX_PHYADDR_WIDTH, 51) == 0
Trusted            | Code(Spec Impl Body(Spec       |                     &&& self.entry & bit!(7u64) == 0
Trusted            | Code(Spec Impl Body(Spec       |                 }
Trusted            | Code(Spec Impl Body(Spec       |             } else if self.layer == 2 {  // PD
Trusted            | Code(Spec Impl Body(Spec       |                 if self.entry & MASK_L2_PG_FLAG_PS == MASK_L2_PG_FLAG_PS {
Comment            | Comment                        |                     // 62:M, 20:13
Trusted            | Code(Spec Impl Body(Spec       |                     &&& self.entry & bitmask_inc!(MAX_PHYADDR_WIDTH, 62) == 0
Trusted            | Code(Spec Impl Body(Spec       |                     &&& self.entry & bitmask_inc!(13u64,20u64) == 0
Trusted            | Code(Spec Impl Body(Spec       |                 } else {
Comment            | Comment                        |                     // 62:M, 7
Trusted            | Code(Spec Impl Body(Spec       |                     &&& self.entry & bitmask_inc!(MAX_PHYADDR_WIDTH, 62) == 0
Trusted            | Code(Spec Impl Body(Spec       |                     &&& self.entry & bit!(7u64) == 0
Trusted            | Code(Spec Impl Body(Spec       |                 }
Trusted            | Code(Spec Impl Body(Spec       |             } else if self.layer == 3 {  // PT, always frame
Comment            | Comment                        |                 // 62:M
Trusted            | Code(Spec Impl Body(Spec       |                 self.entry & bitmask_inc!(MAX_PHYADDR_WIDTH, 62) == 0
Trusted            | Code(Spec Impl Body(Spec       |             } else {
Trusted            | Code(Spec Impl Body(Spec       |                 arbitrary()
Trusted            | Code(Spec Impl Body(Spec       |             }
Trusted            | Code(Spec Impl Body(Spec       |         } else {
Comment            | Comment                        |             // No bits are reserved for unused entries
Trusted            | Code(Spec Impl Body(Spec       |             true
Trusted            | Code(Spec Impl Body(Spec       |         }
Trusted            | Code(Spec Impl Body(Spec       |     }
                   | Impl                           | 
Trusted            | Code(S Impl Signat Body(S      |     pub open spec fn layer(self) -> nat {
Trusted            | Code(Spec Impl Body(Spec       |         self.layer@
Trusted            | Code(Spec Impl Body(Spec       |     }
                   | Impl                           | }
                   |                                | 
                   |                                | #[allow(unused_macros)]
Trusted            | MacroDefinition                | macro_rules! l0_bits {
Trusted            | MacroDefinition                |     ($addr:expr) => { ($addr & bitmask_inc!(39u64,47u64)) >> 39u64 }
Trusted            | MacroDefinition                | }
                   |                                | 
Directives         | Directive                      | pub(crate) use l0_bits;
                   |                                | 
                   |                                | #[allow(unused_macros)]
Trusted            | MacroDefinition                | macro_rules! l1_bits {
Trusted            | MacroDefinition                |     ($addr:expr) => { ($addr & bitmask_inc!(30u64,38u64)) >> 30u64 }
Trusted            | MacroDefinition                | }
                   |                                | 
Directives         | Directive                      | pub(crate) use l1_bits;
                   |                                | 
                   |                                | #[allow(unused_macros)]
Trusted            | MacroDefinition                | macro_rules! l2_bits {
Trusted            | MacroDefinition                |     ($addr:expr) => { ($addr & bitmask_inc!(21u64,29u64)) >> 21u64 }
Trusted            | MacroDefinition                | }
                   |                                | 
Directives         | Directive                      | pub(crate) use l2_bits;
                   |                                | 
                   |                                | #[allow(unused_macros)]
Trusted            | MacroDefinition                | macro_rules! l3_bits {
Trusted            | MacroDefinition                |     ($addr:expr) => { ($addr & bitmask_inc!(12u64,20u64)) >> 12u64 }
Trusted            | MacroDefinition                | }
                   |                                | 
Directives         | Directive                      | pub(crate) use l3_bits;
                   |                                | 
Trusted            | Signature(Spec)                | pub open spec fn read_entry(
Trusted            | Signature(Spec)                |     pt_mem: mem::PageTableMemory,
Trusted            | Signature(Spec)                |     dir_addr: nat,
Trusted            | Signature(Spec)                |     layer: nat,
Trusted            | Signature(Spec)                |     idx: nat,
Trusted            | Code(Spec Signature Body(Spec  | ) -> GhostPageDirectoryEntry {
Trusted            | Code(Spec) Body(Spec)          |     let region = MemRegion { base: dir_addr as nat, size: PAGE_SIZE as nat };
Trusted            | Code(Spec Body(Spec GhostTrac  |     PageDirectoryEntry { entry: pt_mem.spec_read(idx, region), layer: Ghost(layer) }@
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Comment            | Comment                        | /// TODO: list 4-level paging no HLAT etc. as assumptions (+ the register to enable XD semantics,
Comment            | Comment                        | /// it's must-be-zero otherwise)
Comment            | Comment                        | ///
Comment            | Comment                        | /// The intended semantics for valid_pt_walk is this:
Comment            | Comment                        | /// Given a `PageTableMemory` `pt_mem`, the predicate is true for those `addr` and `pte` where the
Comment            | Comment                        | /// MMU's page table walk arrives at an entry mapping the frame `pte.frame`. The properties in
Comment            | Comment                        | /// `pte.flags` reflect the properties along the translation path. I.e. `pte.flags.is_writable` is
Comment            | Comment                        | /// true iff the RW flag is set in all directories along the translation path and in the frame
Comment            | Comment                        | /// mapping. Similarly, `pte.flags.is_supervisor` is true iff the US flag is unset in all those
Comment            | Comment                        | /// structures and `pte.flags.disable_execute` is true iff the XD flag is set in at least one of
Comment            | Comment                        | /// those structures.
Comment            | Comment                        | ///
Comment            | Comment                        | /// In practice, we always set these flags to their more permissive state in directories and only
Comment            | Comment                        | /// make more restrictive settings in the frame mappings. (Ensured in the invariant, see conjunct
Comment            | Comment                        | /// `directories_have_flags` in refinement layers 1 and 2.) But in the hardware model we still
Comment            | Comment                        | /// define the full, correct semantics to ensure the implementation sets the flags correctly.
Trusted            | Signature(Spec)                | pub open spec fn valid_pt_walk(
Trusted            | Signature(Spec)                |     pt_mem: mem::PageTableMemory,
Trusted            | Signature(Spec)                |     addr: u64,
Trusted            | Signature(Spec)                |     pte: PageTableEntry,
Trusted            | Code(Spec Signature Body(Spec  | ) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     let l0_idx: nat = l0_bits!(addr) as nat;
Trusted            | Code(Spec) Body(Spec)          |     let l1_idx: nat = l1_bits!(addr) as nat;
Trusted            | Code(Spec) Body(Spec)          |     let l2_idx: nat = l2_bits!(addr) as nat;
Trusted            | Code(Spec) Body(Spec)          |     let l3_idx: nat = l3_bits!(addr) as nat;
Trusted            | Code(Spec) Body(Spec)          |     match read_entry(pt_mem, pt_mem.cr3_spec()@.base, 0, l0_idx) {
Trusted            | Code(Spec) Body(Spec)          |         GhostPageDirectoryEntry::Directory {
Trusted            | Code(Spec) Body(Spec)          |             addr: dir_addr,
Trusted            | Code(Spec) Body(Spec)          |             flag_RW: l0_RW,
Trusted            | Code(Spec) Body(Spec)          |             flag_US: l0_US,
Trusted            | Code(Spec) Body(Spec)          |             flag_XD: l0_XD,
Trusted            | Code(Spec) Body(Spec)          |             ..
Trusted            | Code(Spec) Body(Spec)          |         } => {
Trusted            | Code(Spec) Body(Spec)          |             match read_entry(pt_mem, dir_addr as nat, 1, l1_idx) {
Trusted            | Code(Spec) Body(Spec)          |                 GhostPageDirectoryEntry::Page {
Trusted            | Code(Spec) Body(Spec)          |                     addr: page_addr,
Trusted            | Code(Spec) Body(Spec)          |                     flag_RW: l1_RW,
Trusted            | Code(Spec) Body(Spec)          |                     flag_US: l1_US,
Trusted            | Code(Spec) Body(Spec)          |                     flag_XD: l1_XD,
Trusted            | Code(Spec) Body(Spec)          |                     ..
Trusted            | Code(Spec) Body(Spec)          |                 } => {
Trusted            | Code(Spec) Body(Spec)          |                     aligned(addr as nat, L1_ENTRY_SIZE as nat) && pte == PageTableEntry {
Trusted            | Code(Spec) Body(Spec)          |                         frame: MemRegion { base: page_addr as nat, size: L1_ENTRY_SIZE as nat },
Trusted            | Code(Spec) Body(Spec)          |                         flags: Flags {
Trusted            | Code(Spec) Body(Spec)          |                             is_writable: l0_RW && l1_RW,
Trusted            | Code(Spec) Body(Spec)          |                             is_supervisor: !l0_US || !l1_US,
Trusted            | Code(Spec) Body(Spec)          |                             disable_execute: l0_XD || l1_XD,
Trusted            | Code(Spec) Body(Spec)          |                         },
Trusted            | Code(Spec) Body(Spec)          |                     }
Trusted            | Code(Spec) Body(Spec)          |                 },
Trusted            | Code(Spec) Body(Spec)          |                 GhostPageDirectoryEntry::Directory {
Trusted            | Code(Spec) Body(Spec)          |                     addr: dir_addr,
Trusted            | Code(Spec) Body(Spec)          |                     flag_RW: l1_RW,
Trusted            | Code(Spec) Body(Spec)          |                     flag_US: l1_US,
Trusted            | Code(Spec) Body(Spec)          |                     flag_XD: l1_XD,
Trusted            | Code(Spec) Body(Spec)          |                     ..
Trusted            | Code(Spec) Body(Spec)          |                 } => {
Trusted            | Code(Spec) Body(Spec)          |                     match read_entry(pt_mem, dir_addr as nat, 2, l2_idx) {
Trusted            | Code(Spec) Body(Spec)          |                         GhostPageDirectoryEntry::Page {
Trusted            | Code(Spec) Body(Spec)          |                             addr: page_addr,
Trusted            | Code(Spec) Body(Spec)          |                             flag_RW: l2_RW,
Trusted            | Code(Spec) Body(Spec)          |                             flag_US: l2_US,
Trusted            | Code(Spec) Body(Spec)          |                             flag_XD: l2_XD,
Trusted            | Code(Spec) Body(Spec)          |                             ..
Trusted            | Code(Spec) Body(Spec)          |                         } => {
Trusted            | Code(Spec) Body(Spec)          |                             aligned(addr as nat, L2_ENTRY_SIZE as nat) && pte == PageTableEntry {
Trusted            | Code(Spec) Body(Spec)          |                                 frame: MemRegion {
Trusted            | Code(Spec) Body(Spec)          |                                     base: page_addr as nat,
Trusted            | Code(Spec) Body(Spec)          |                                     size: L2_ENTRY_SIZE as nat,
Trusted            | Code(Spec) Body(Spec)          |                                 },
Trusted            | Code(Spec) Body(Spec)          |                                 flags: Flags {
Trusted            | Code(Spec) Body(Spec)          |                                     is_writable: l0_RW && l1_RW && l2_RW,
Trusted            | Code(Spec) Body(Spec)          |                                     is_supervisor: !l0_US || !l1_US || !l2_US,
Trusted            | Code(Spec) Body(Spec)          |                                     disable_execute: l0_XD || l1_XD || l2_XD,
Trusted            | Code(Spec) Body(Spec)          |                                 },
Trusted            | Code(Spec) Body(Spec)          |                             }
Trusted            | Code(Spec) Body(Spec)          |                         },
Trusted            | Code(Spec) Body(Spec)          |                         GhostPageDirectoryEntry::Directory {
Trusted            | Code(Spec) Body(Spec)          |                             addr: dir_addr,
Trusted            | Code(Spec) Body(Spec)          |                             flag_RW: l2_RW,
Trusted            | Code(Spec) Body(Spec)          |                             flag_US: l2_US,
Trusted            | Code(Spec) Body(Spec)          |                             flag_XD: l2_XD,
Trusted            | Code(Spec) Body(Spec)          |                             ..
Trusted            | Code(Spec) Body(Spec)          |                         } => {
Trusted            | Code(Spec) Body(Spec)          |                             match read_entry(pt_mem, dir_addr as nat, 3, l3_idx) {
Trusted            | Code(Spec) Body(Spec)          |                                 GhostPageDirectoryEntry::Page {
Trusted            | Code(Spec) Body(Spec)          |                                     addr: page_addr,
Trusted            | Code(Spec) Body(Spec)          |                                     flag_RW: l3_RW,
Trusted            | Code(Spec) Body(Spec)          |                                     flag_US: l3_US,
Trusted            | Code(Spec) Body(Spec)          |                                     flag_XD: l3_XD,
Trusted            | Code(Spec) Body(Spec)          |                                     ..
Trusted            | Code(Spec) Body(Spec)          |                                 } => {
Trusted            | Code(Spec) Body(Spec)          |                                     aligned(addr as nat, L3_ENTRY_SIZE as nat) && pte
Trusted            | Code(Spec) Body(Spec)          |                                         == PageTableEntry {
Trusted            | Code(Spec) Body(Spec)          |                                         frame: MemRegion {
Trusted            | Code(Spec) Body(Spec)          |                                             base: page_addr as nat,
Trusted            | Code(Spec) Body(Spec)          |                                             size: L3_ENTRY_SIZE as nat,
Trusted            | Code(Spec) Body(Spec)          |                                         },
Trusted            | Code(Spec) Body(Spec)          |                                         flags: Flags {
Trusted            | Code(Spec) Body(Spec)          |                                             is_writable: l0_RW && l1_RW && l2_RW && l3_RW,
Trusted            | Code(Spec) Body(Spec)          |                                             is_supervisor: !l0_US || !l1_US || !l2_US || !l3_US,
Trusted            | Code(Spec) Body(Spec)          |                                             disable_execute: l0_XD || l1_XD || l2_XD || l3_XD,
Trusted            | Code(Spec) Body(Spec)          |                                         },
Trusted            | Code(Spec) Body(Spec)          |                                     }
Trusted            | Code(Spec) Body(Spec)          |                                 },
Trusted            | Code(Spec) Body(Spec)          |                                 GhostPageDirectoryEntry::Directory { .. } => false,
Trusted            | Code(Spec) Body(Spec)          |                                 GhostPageDirectoryEntry::Empty => false,
Trusted            | Code(Spec) Body(Spec)          |                             }
Trusted            | Code(Spec) Body(Spec)          |                         },
Trusted            | Code(Spec) Body(Spec)          |                         GhostPageDirectoryEntry::Empty => false,
Trusted            | Code(Spec) Body(Spec)          |                     }
Trusted            | Code(Spec) Body(Spec)          |                 },
Trusted            | Code(Spec) Body(Spec)          |                 GhostPageDirectoryEntry::Empty => false,
Trusted            | Code(Spec) Body(Spec)          |             }
Trusted            | Code(Spec) Body(Spec)          |         },
Trusted            | Code(Spec) Body(Spec)          |         _ => false,
Trusted            | Code(Spec) Body(Spec)          |     }
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Comment            | Comment                        | // Can't use `n as u64` in triggers because it's an arithmetic expression
Trusted            | Signature(Spec)                | pub open spec fn nat_to_u64(n: nat) -> u64
Trusted            | Signature(Spec)                |     recommends
Trusted            | Signature(Spec)                |         n <= u64::MAX,
Trusted            | Code(Spec) Body(Spec)          | {
Trusted            | Code(Spec) Body(Spec)          |     n as u64
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Comment            | Comment                        | /// Page table walker interpretation of the page table memory
Trusted            | Code(Spec Signature Body(Spec  | pub open spec fn interp_pt_mem(pt_mem: mem::PageTableMemory) -> Map<nat, PageTableEntry> {
Trusted            | Code(Spec) Body(Spec)          |     Map::new(
Trusted            | Code(Spec) Body(Spec)          |         |addr: nat|
Trusted            | Code(Spec) Body(Spec)          |             addr
Trusted            | Code(Spec) Body(Spec)          |                 < MAX_BASE
Comment            | Comment                        |             // Casting addr to u64 is okay since addr < MAX_BASE < u64::MAX
Trusted            | Code(Spec) Body(Spec)          |              && exists|pte: PageTableEntry| valid_pt_walk(pt_mem, nat_to_u64(addr), pte),
Trusted            | Code(Spec) Body(Spec)          |         |addr: nat| choose|pte: PageTableEntry| valid_pt_walk(pt_mem, nat_to_u64(addr), pte),
Trusted            | Code(Spec) Body(Spec)          |     )
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Code(Spec Signature Body(Spec  | pub open spec fn init(c: HWConstants, s: HWVariables) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     &&& c.NUMA_no > 0
Trusted            | Code(Spec) Body(Spec)          |     &&& forall|id: nat| #[trigger] valid_NUMA_id(c, id) == s.NUMAs.contains_key(id)
Trusted            | Code(Spec) Body(Spec)          |     &&& forall|id: nat| #[trigger] valid_NUMA_id(c, id) ==> NUMA_init(c, s.NUMAs[id])
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Code(Spec Signature Body(Spec  | pub open spec fn NUMA_init(c: HWConstants, n: NUMAVariables) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     &&& c.core_no > 0
Trusted            | Code(Spec) Body(Spec)          |     &&& forall|id: nat| #[trigger] valid_core_id(c, id) == n.cores.contains_key(id)
Trusted            | Code(Spec) Body(Spec)          |     &&& forall|id: nat| #[trigger] valid_core_id(c, id) ==> n.cores[id].tlb.dom() === Set::empty()
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Comment            | Comment                        | // We only allow aligned accesses. Can think of unaligned accesses as two aligned accesses. When we
Comment            | Comment                        | // get to concurrency we may have to change that.
Trusted            | Signature(Spec)                | pub open spec fn step_ReadWrite(
Trusted            | Signature(Spec)                |     c: HWConstants,
Trusted            | Signature(Spec)                |     s1: HWVariables,
Trusted            | Signature(Spec)                |     s2: HWVariables,
Trusted            | Signature(Spec)                |     vaddr: nat,
Trusted            | Signature(Spec)                |     paddr: nat,
Trusted            | Signature(Spec)                |     op: HWRWOp,
Trusted            | Signature(Spec)                |     pte: Option<(nat, PageTableEntry)>,
Trusted            | Signature(Spec)                |     core: Core,
Trusted            | Code(Spec Signature Body(Spec  | ) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     &&& aligned(vaddr, 8)
Comment            | Comment                        |     //page tables and TLBs stay the same
Layout             | Code(Spec) Body(Spec)          | 
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.NUMAs === s1.NUMAs
Trusted            | Code(Spec) Body(Spec)          |     &&& valid_core(c, core)
Trusted            | Code(Spec) Body(Spec)          |     &&& match pte {
Trusted            | Code(Spec) Body(Spec)          |         Some((base, pte)) => {
Trusted            | Code(Spec) Body(Spec)          |             let pmem_idx = word_index_spec(paddr);
Comment            | Comment                        |             // If pte is Some, it's a cached mapping that maps vaddr to paddr..
Trusted            | Code(Spec) Body(Spec)          |             &&& s1.NUMAs[core.NUMA_id].cores[core.core_id].tlb.contains_pair(base, pte)
Trusted            | Code(Spec) Body(Spec)          |             &&& between(vaddr, base, base + pte.frame.size)
Trusted            | Code(Spec) Body(Spec)          |             &&& paddr === (pte.frame.base + (vaddr
Trusted            | Code(Spec) Body(Spec)          |                 - base)) as nat
Comment            | Comment                        |             // .. and the result depends on the flags.
Layout             | Code(Spec) Body(Spec)          | 
Trusted            | Code(Spec) Body(Spec)          |             &&& match op {
Trusted            | Code(Spec) Body(Spec)          |                 HWRWOp::Store { new_value, result } => {
Trusted            | Code(Spec) Body(Spec)          |                     if pmem_idx < s1.mem.len() && !pte.flags.is_supervisor
Trusted            | Code(Spec) Body(Spec)          |                         && pte.flags.is_writable {
Trusted            | Code(Spec) Body(Spec)          |                         &&& result is Ok
Trusted            | Code(Spec) Body(Spec)          |                         &&& s2.mem === s1.mem.update(pmem_idx as int, new_value)
Trusted            | Code(Spec) Body(Spec)          |                     } else {
Trusted            | Code(Spec) Body(Spec)          |                         &&& result is Pagefault
Trusted            | Code(Spec) Body(Spec)          |                         &&& s2.mem === s1.mem
Trusted            | Code(Spec) Body(Spec)          |                     }
Trusted            | Code(Spec) Body(Spec)          |                 },
Trusted            | Code(Spec) Body(Spec)          |                 HWRWOp::Load { is_exec, result } => {
Trusted            | Code(Spec) Body(Spec)          |                     &&& s2.mem === s1.mem
Trusted            | Code(Spec) Body(Spec)          |                     &&& if pmem_idx < s1.mem.len() && !pte.flags.is_supervisor && (is_exec
Trusted            | Code(Spec) Body(Spec)          |                         ==> !pte.flags.disable_execute) {
Trusted            | Code(Spec) Body(Spec)          |                         &&& result is Value
Trusted            | Code(Spec) Body(Spec)          |                         &&& result->0 == s1.mem[pmem_idx as int]
Trusted            | Code(Spec) Body(Spec)          |                     } else {
Trusted            | Code(Spec) Body(Spec)          |                         &&& result is Pagefault
Trusted            | Code(Spec) Body(Spec)          |                     }
Trusted            | Code(Spec) Body(Spec)          |                 },
Trusted            | Code(Spec) Body(Spec)          |             }
Trusted            | Code(Spec) Body(Spec)          |         },
Trusted            | Code(Spec) Body(Spec)          |         None => {
Comment            | Comment                        |             // If pte is None, no mapping containing vaddr exists..
Trusted            | Code(Spec) Body(Spec)          |             &&& (!exists|base, pte|
Trusted            | Code(Spec) Body(Spec)          |                 {
Trusted            | Code(Spec) Body(Spec)          |                     &&& interp_pt_mem(s1.global_pt).contains_pair(base, pte)
Trusted            | Code(Spec) Body(Spec)          |                     &&& between(vaddr, base, base + pte.frame.size)
Trusted            | Code(Spec) Body(Spec)          |                 })
Comment            | Comment                        |             // .. and the result is always a Undefined and an unchanged memory.
Layout             | Code(Spec) Body(Spec)          | 
Trusted            | Code(Spec) Body(Spec)          |             &&& s2.mem === s1.mem
Trusted            | Code(Spec) Body(Spec)          |             &&& match op {
Trusted            | Code(Spec) Body(Spec)          |                 HWRWOp::Store { new_value, result } => result is Pagefault,
Trusted            | Code(Spec) Body(Spec)          |                 HWRWOp::Load { is_exec, result } => result is Pagefault,
Trusted            | Code(Spec) Body(Spec)          |             }
Trusted            | Code(Spec) Body(Spec)          |         },
Trusted            | Code(Spec) Body(Spec)          |     }
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Code(Spec Signature Body(Spec  | pub open spec fn step_PTMemOp(c: HWConstants, s1: HWVariables, s2: HWVariables) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.mem === s1.mem
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.NUMAs == s1.NUMAs
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Signature(Spec)                | pub open spec fn other_NUMAs_and_cores_unchanged(
Trusted            | Signature(Spec)                |     c: HWConstants,
Trusted            | Signature(Spec)                |     s1: HWVariables,
Trusted            | Signature(Spec)                |     s2: HWVariables,
Trusted            | Signature(Spec)                |     core: Core,
Trusted            | Signature(Spec)                | ) -> bool
Trusted            | Signature(Spec)                |     recommends
Trusted            | Signature(Spec)                |         valid_core(c, core),
Trusted            | Code(Spec) Body(Spec)          | {
Comment            | Comment                        |     //Memory stays the same
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.mem === s1.mem
Comment            | Comment                        |     //Number of Numa nodes stays the same
Comment            | Comment                        |     //all NUMA states are the same besides the one of NUMA_id
Layout             | Code(Spec) Body(Spec)          | 
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.NUMAs.dom() === s1.NUMAs.dom()
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.NUMAs.remove(core.NUMA_id) === s1.NUMAs.remove(
Trusted            | Code(Spec) Body(Spec)          |         core.NUMA_id,
Trusted            | Code(Spec) Body(Spec)          |     )
Comment            | Comment                        |     //all cores_states of NUMA_id stay the same besides core_id
Layout             | Code(Spec) Body(Spec)          | 
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.NUMAs[core.NUMA_id].cores.dom() === s1.NUMAs[core.NUMA_id].cores.dom()
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.NUMAs[core.NUMA_id].cores.remove(core.core_id) === s1.NUMAs[core.NUMA_id].cores.remove(
Trusted            | Code(Spec) Body(Spec)          |         core.core_id,
Trusted            | Code(Spec) Body(Spec)          |     )
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Code(Spec Signature Body(Spec  | pub open spec fn valid_NUMA_id(c: HWConstants, id: nat) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     id < c.NUMA_no
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Code(Spec Signature Body(Spec  | pub open spec fn valid_core_id(c: HWConstants, id: nat) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     id < c.core_no
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Comment            | Comment                        | //TODO this
Trusted            | Code(Spec Signature Body(Spec  | pub open spec fn valid_core(c: HWConstants, core: Core) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     &&& valid_NUMA_id(c, core.NUMA_id)
Trusted            | Code(Spec) Body(Spec)          |     &&& valid_core_id(c, core.core_id)
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Signature(Spec)                | pub open spec fn step_TLBFill(
Trusted            | Signature(Spec)                |     c: HWConstants,
Trusted            | Signature(Spec)                |     s1: HWVariables,
Trusted            | Signature(Spec)                |     s2: HWVariables,
Trusted            | Signature(Spec)                |     vaddr: nat,
Trusted            | Signature(Spec)                |     pte: PageTableEntry,
Trusted            | Signature(Spec)                |     core: Core,
Trusted            | Code(Spec Signature Body(Spec  | ) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     &&& valid_core(c, core)
Trusted            | Code(Spec) Body(Spec)          |     &&& interp_pt_mem(s1.global_pt).contains_pair(vaddr, pte)
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.NUMAs[core.NUMA_id].cores[core.core_id].tlb
Trusted            | Code(Spec) Body(Spec)          |         === s1.NUMAs[core.NUMA_id].cores[core.core_id].tlb.insert(vaddr, pte)
Trusted            | Code(Spec) Body(Spec)          |     &&& other_NUMAs_and_cores_unchanged(c, s1, s2, core)
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Signature(Spec)                | pub open spec fn step_TLBEvict(
Trusted            | Signature(Spec)                |     c: HWConstants,
Trusted            | Signature(Spec)                |     s1: HWVariables,
Trusted            | Signature(Spec)                |     s2: HWVariables,
Trusted            | Signature(Spec)                |     vaddr: nat,
Trusted            | Signature(Spec)                |     core: Core,
Trusted            | Code(Spec Signature Body(Spec  | ) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     &&& valid_core(c, core)
Trusted            | Code(Spec) Body(Spec)          |     &&& s1.NUMAs[core.NUMA_id].cores[core.core_id].tlb.dom().contains(vaddr)
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.NUMAs[core.NUMA_id].cores[core.core_id].tlb
Trusted            | Code(Spec) Body(Spec)          |         === s1.NUMAs[core.NUMA_id].cores[core.core_id].tlb.remove(vaddr)
Trusted            | Code(Spec) Body(Spec)          |     &&& other_NUMAs_and_cores_unchanged(c, s1, s2, core)
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Code(Spec Signature Body(Spec  | pub open spec fn next_step(c: HWConstants, s1: HWVariables, s2: HWVariables, step: HWStep) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     match step {
Trusted            | Code(Spec) Body(Spec)          |         HWStep::ReadWrite { vaddr, paddr, op, pte, core } => step_ReadWrite(
Trusted            | Code(Spec) Body(Spec)          |             c,
Trusted            | Code(Spec) Body(Spec)          |             s1,
Trusted            | Code(Spec) Body(Spec)          |             s2,
Trusted            | Code(Spec) Body(Spec)          |             vaddr,
Trusted            | Code(Spec) Body(Spec)          |             paddr,
Trusted            | Code(Spec) Body(Spec)          |             op,
Trusted            | Code(Spec) Body(Spec)          |             pte,
Trusted            | Code(Spec) Body(Spec)          |             core,
Trusted            | Code(Spec) Body(Spec)          |         ),
Trusted            | Code(Spec) Body(Spec)          |         HWStep::PTMemOp => step_PTMemOp(c, s1, s2),
Trusted            | Code(Spec) Body(Spec)          |         HWStep::TLBFill { vaddr, pte, core } => step_TLBFill(c, s1, s2, vaddr, pte, core),
Trusted            | Code(Spec) Body(Spec)          |         HWStep::TLBEvict { vaddr, core } => step_TLBEvict(c, s1, s2, vaddr, core),
Trusted            | Code(Spec) Body(Spec)          |     }
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Code(Spec Signature Body(Spec  | pub open spec fn next(c: HWConstants, s1: HWVariables, s2: HWVariables) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     exists|step: HWStep| next_step(c, s1, s2, step)
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Comment            | Comment                        | // pub closed spec fn inv(s: HWVariables) -> bool {
Comment            | Comment                        | //     true
Comment            | Comment                        | // }
Comment            | Comment                        | //
Comment            | Comment                        | // proof fn init_implies_inv(s: HWVariables)
Comment            | Comment                        | //     requires
Comment            | Comment                        | //         init(s),
Comment            | Comment                        | //     ensures
Comment            | Comment                        | //         inv(s)
Comment            | Comment                        | // { }
Comment            | Comment                        | //
Comment            | Comment                        | // proof fn next_preserves_inv(s1: HWVariables, s2: HWVariables)
Comment            | Comment                        | //     requires
Comment            | Comment                        | //         next(s1, s2),
Comment            | Comment                        | //         inv(s1),
Comment            | Comment                        | //     ensures
Comment            | Comment                        | //         inv(s2),
Comment            | Comment                        | // {
Comment            | Comment                        | //     let step = choose|step: HWStep| next_step(s1, s2, step);
Comment            | Comment                        | //     match step {
Comment            | Comment                        | //         HWStep::ReadWrite { vaddr, paddr, op , pte} => (),
Comment            | Comment                        | //         HWStep::PTMemOp                             => (),
Comment            | Comment                        | //         HWStep::TLBFill  { vaddr, pte }             => (),
Comment            | Comment                        | //         HWStep::TLBEvict { vaddr }                  => (),
Comment            | Comment                        | //     }
Comment            | Comment                        | // }
                   |                                | } // verus!

# spec_t/hlspec.rs
                   |                                | #![verus::trusted]
Comment            | Comment                        | // trusted:
Comment            | Comment                        | // this is the process-level specification of the kernel's behaviour
                   |                                | 
                   |                                | use crate::definitions_t::{
                   |                                |     above_zero, aligned, between, candidate_mapping_in_bounds,
                   |                                |     candidate_mapping_overlaps_existing_pmem, candidate_mapping_overlaps_existing_vmem, overlap,
                   |                                |     x86_arch_spec, MemRegion, PageTableEntry, RWOp, L1_ENTRY_SIZE, L2_ENTRY_SIZE, L3_ENTRY_SIZE,
                   |                                |     MAX_PHYADDR, WORD_SIZE,
                   |                                | };
                   |                                | use crate::spec_t::mem;
                   |                                | use vstd::prelude::*;
                   |                                | 
                   |                                | use crate::spec_t::hlproof::{
                   |                                |     insert_non_map_preserves_unique, lemma_mem_domain_from_mapping_finite, map_end_preserves_inv,
                   |                                |     map_start_preserves_inv, unmap_start_preserves_inv,
                   |                                | };
                   |                                | 
                   |                                | verus! {
                   |                                | 
Trusted            | DatatypeDecl                   | pub struct AbstractConstants {
Comment            | Comment                        |     //so far const
Trusted            | DatatypeDecl                   |     pub thread_no: nat,
Trusted            | DatatypeDecl                   |     pub phys_mem_size: nat,
Trusted            | DatatypeDecl                   | }
                   |                                | 
Trusted            | DatatypeDecl                   | pub struct AbstractVariables {
Comment            | Comment                        |     /// Word-indexed virtual memory
Trusted            | DatatypeDecl                   |     pub mem: Map<nat, nat>,
Trusted            | DatatypeDecl                   |     pub thread_state: Map<nat, AbstractArguments>,
Comment            | Comment                        |     /// `mappings` constrains the domain of mem and tracks the flags. We could instead move the
Comment            | Comment                        |     /// flags into `map` as well and write the specification exclusively in terms of `map` but that
Comment            | Comment                        |     /// also makes some of the enabling conditions awkward, e.g. full mappings have the same flags, etc.
Trusted            | DatatypeDecl                   |     pub mappings: Map<nat, PageTableEntry>,
Trusted            | DatatypeDecl                   |     pub sound: bool,
Trusted            | DatatypeDecl                   | }
                   |                                | 
Trusted            | DatatypeDecl Directive         | #[allow(inconsistent_fields)]
Trusted            | DatatypeDecl                   | pub enum AbstractStep {
Trusted            | DatatypeDecl                   |     ReadWrite { thread_id: nat, vaddr: nat, op: RWOp, pte: Option<(nat, PageTableEntry)> },
Trusted            | DatatypeDecl                   |     MapStart { thread_id: nat, vaddr: nat, pte: PageTableEntry },
Trusted            | DatatypeDecl                   |     MapEnd { thread_id: nat, result: Result<(), ()> },
Trusted            | DatatypeDecl                   |     UnmapStart { thread_id: nat, vaddr: nat },
Trusted            | DatatypeDecl                   |     UnmapEnd { thread_id: nat, result: Result<(), ()> },
Trusted            | DatatypeDecl                   |     Stutter,
Trusted            | DatatypeDecl                   | }
                   |                                | 
Comment            | Comment                        | //To allow two-step transitions that preserve arguments
Trusted            | DatatypeDecl Directive         | #[allow(inconsistent_fields)]
Trusted            | DatatypeDecl                   | pub enum AbstractArguments {
Trusted            | DatatypeDecl                   |     Map { vaddr: nat, pte: PageTableEntry },
Trusted            | DatatypeDecl                   |     Unmap { vaddr: nat, pte: Option<PageTableEntry> },
Trusted            | DatatypeDecl                   |     Empty,
Trusted            | DatatypeDecl                   | }
                   |                                | 
Trusted            | Code(Spec Signature Body(Spec  | pub open spec fn wf(c: AbstractConstants, s: AbstractVariables) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     &&& forall|id: nat| id < c.thread_no <==> s.thread_state.contains_key(id)
Trusted            | Code(Spec) Body(Spec)          |     &&& s.mappings.dom().finite()
Trusted            | Code(Spec) Body(Spec)          |     &&& s.mem.dom().finite()
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Code(Spec Signature Body(Spec  | pub open spec fn init(c: AbstractConstants, s: AbstractVariables) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     &&& s.mem === Map::empty()
Trusted            | Code(Spec) Body(Spec)          |     &&& s.mappings === Map::empty()
Trusted            | Code(Spec) Body(Spec)          |     &&& forall|id: nat| id < c.thread_no ==> (s.thread_state[id] === AbstractArguments::Empty)
Trusted            | Code(Spec) Body(Spec)          |     &&& wf(c, s)
Trusted            | Code(Spec) Body(Spec)          |     &&& s.sound
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Signature(Spec)                | pub open spec fn mem_domain_from_mappings_contains(
Trusted            | Signature(Spec)                |     phys_mem_size: nat,
Trusted            | Signature(Spec)                |     word_idx: nat,
Trusted            | Signature(Spec)                |     mappings: Map<nat, PageTableEntry>,
Trusted            | Code(Spec Signature Body(Spec  | ) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     let vaddr = word_idx * WORD_SIZE as nat;
Trusted            | Code(Spec) Body(Spec)          |     exists|base: nat, pte: PageTableEntry|
Trusted            | Code(Spec) Body(Spec)          |         {
Trusted            | Code(Spec) Body(Spec)          |             &&& #[trigger] mappings.contains_pair(base, pte)
Trusted            | Code(Spec) Body(Spec)          |             &&& mem_domain_from_entry_contains(phys_mem_size, vaddr, base, pte)
Trusted            | Code(Spec) Body(Spec)          |         }
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Signature(Spec)                | pub open spec fn mem_domain_from_entry_contains(
Trusted            | Signature(Spec)                |     phys_mem_size: nat,
Trusted            | Signature(Spec)                |     vaddr: nat,
Trusted            | Signature(Spec)                |     base: nat,
Trusted            | Signature(Spec)                |     pte: PageTableEntry,
Trusted            | Code(Spec Signature Body(Spec  | ) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     let paddr = (pte.frame.base + (vaddr - base)) as nat;
Trusted            | Code(Spec) Body(Spec)          |     let pmem_idx = mem::word_index_spec(paddr);
Trusted            | Code(Spec) Body(Spec)          |     &&& between(vaddr, base, base + pte.frame.size)
Trusted            | Code(Spec) Body(Spec)          |     &&& pmem_idx < phys_mem_size
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Signature(Spec)                | pub open spec fn mem_domain_from_mappings(
Trusted            | Signature(Spec)                |     phys_mem_size: nat,
Trusted            | Signature(Spec)                |     mappings: Map<nat, PageTableEntry>,
Trusted            | Code(Spec Signature Body(Spec  | ) -> Set<nat> {
Trusted            | Code(Spec) Body(Spec)          |     Set::new(|word_idx: nat| mem_domain_from_mappings_contains(phys_mem_size, word_idx, mappings))
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Signature(Spec)                | pub open spec fn mem_domain_from_entry(phys_mem_size: nat, base: nat, pte: PageTableEntry) -> Set<
Trusted            | Signature(Spec)                |     nat,
Trusted            | Code(Spec Signature Body(Spec  | > {
Trusted            | Code(Spec) Body(Spec)          |     Set::new(
Trusted            | Code(Spec) Body(Spec)          |         |word_idx: nat|
Trusted            | Code(Spec) Body(Spec)          |             mem_domain_from_entry_contains(phys_mem_size, (word_idx * WORD_SIZE as nat), base, pte),
Trusted            | Code(Spec) Body(Spec)          |     )
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Code(Spec Signature Body(Spec  | pub open spec fn valid_thread(c: AbstractConstants, thread_id: nat) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     thread_id < c.thread_no
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Comment            | Comment                        | // Helper function to specify relation between 2 states
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Trusted            | Signature(Spec)                | pub open spec fn state_unchanged_besides_thread_state(
Trusted            | Signature(Spec)                |     s1: AbstractVariables,
Trusted            | Signature(Spec)                |     s2: AbstractVariables,
Trusted            | Signature(Spec)                |     thread_id: nat,
Trusted            | Signature(Spec)                |     thread_arguments: AbstractArguments,
Trusted            | Code(Spec Signature Body(Spec  | ) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.thread_state === s1.thread_state.insert(thread_id, thread_arguments)
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.mem === s1.mem
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.mappings === s1.mappings
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.sound == s1.sound
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Code(Spec Signature Body(Spec  | pub open spec fn unsound_state(s1: AbstractVariables, s2: AbstractVariables) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     !s2.sound
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Comment            | Comment                        | // Overlapping inflight memory helper functions
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Trusted            | Signature(Spec)                | pub open spec fn candidate_mapping_overlaps_inflight_vmem(
Trusted            | Signature(Spec)                |     inflightargs: Set<AbstractArguments>,
Trusted            | Signature(Spec)                |     base: nat,
Trusted            | Signature(Spec)                |     candidate_size: nat,
Trusted            | Code(Spec Signature Body(Spec  | ) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     &&& exists|b: AbstractArguments|
Trusted            | Code(Spec) Body(Spec)          |         #![auto]
Trusted            | Code(Spec) Body(Spec)          |         {
Trusted            | Code(Spec) Body(Spec)          |             &&& inflightargs.contains(b)
Trusted            | Code(Spec) Body(Spec)          |             &&& match b {
Trusted            | Code(Spec) Body(Spec)          |                 AbstractArguments::Map { vaddr, pte } => {
Trusted            | Code(Spec) Body(Spec)          |                     overlap(
Trusted            | Code(Spec) Body(Spec)          |                         MemRegion { base: vaddr, size: pte.frame.size },
Trusted            | Code(Spec) Body(Spec)          |                         MemRegion { base: base, size: candidate_size },
Trusted            | Code(Spec) Body(Spec)          |                     )
Trusted            | Code(Spec) Body(Spec)          |                 },
Trusted            | Code(Spec) Body(Spec)          |                 AbstractArguments::Unmap { vaddr, pte } => {
Trusted            | Code(Spec) Body(Spec)          |                     let size = if pte.is_some() {
Trusted            | Code(Spec) Body(Spec)          |                         pte.unwrap().frame.size
Trusted            | Code(Spec) Body(Spec)          |                     } else {
Trusted            | Code(Spec) Body(Spec)          |                         0
Trusted            | Code(Spec) Body(Spec)          |                     };
Trusted            | Code(Spec) Body(Spec)          |                     overlap(
Trusted            | Code(Spec) Body(Spec)          |                         MemRegion { base: vaddr, size: size },
Trusted            | Code(Spec) Body(Spec)          |                         MemRegion { base: base, size: candidate_size },
Trusted            | Code(Spec) Body(Spec)          |                     )
Trusted            | Code(Spec) Body(Spec)          |                 },
Trusted            | Code(Spec) Body(Spec)          |                 _ => { false },
Trusted            | Code(Spec) Body(Spec)          |             }
Trusted            | Code(Spec) Body(Spec)          |         }
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Signature(Spec)                | pub open spec fn candidate_mapping_overlaps_inflight_pmem(
Trusted            | Signature(Spec)                |     inflightargs: Set<AbstractArguments>,
Trusted            | Signature(Spec)                |     candidate: PageTableEntry,
Trusted            | Code(Spec Signature Body(Spec  | ) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     &&& exists|b: AbstractArguments|
Trusted            | Code(Spec) Body(Spec)          |         #![auto]
Trusted            | Code(Spec) Body(Spec)          |         {
Trusted            | Code(Spec) Body(Spec)          |             &&& inflightargs.contains(b)
Trusted            | Code(Spec) Body(Spec)          |             &&& match b {
Trusted            | Code(Spec) Body(Spec)          |                 AbstractArguments::Map { vaddr, pte } => { overlap(candidate.frame, pte.frame) },
Trusted            | Code(Spec) Body(Spec)          |                 AbstractArguments::Unmap { vaddr, pte } => {
Trusted            | Code(Spec) Body(Spec)          |                     &&& pte.is_some()
Trusted            | Code(Spec) Body(Spec)          |                     &&& overlap(candidate.frame, pte.unwrap().frame)
Trusted            | Code(Spec) Body(Spec)          |                 },
Trusted            | Code(Spec) Body(Spec)          |                 _ => { false },
Trusted            | Code(Spec) Body(Spec)          |             }
Trusted            | Code(Spec) Body(Spec)          |         }
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Comment            | Comment                        | // MMU atomic ReadWrite
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Comment            | Comment                        | //since unmap deleted pte inflight pte == pagefault
Trusted            | Signature(Spec)                | pub open spec fn step_ReadWrite(
Trusted            | Signature(Spec)                |     c: AbstractConstants,
Trusted            | Signature(Spec)                |     s1: AbstractVariables,
Trusted            | Signature(Spec)                |     s2: AbstractVariables,
Trusted            | Signature(Spec)                |     thread_id: nat,
Trusted            | Signature(Spec)                |     vaddr: nat,
Trusted            | Signature(Spec)                |     op: RWOp,
Trusted            | Signature(Spec)                |     pte: Option<(nat, PageTableEntry)>,
Trusted            | Code(Spec Signature Body(Spec  | ) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     let vmem_idx = mem::word_index_spec(vaddr);
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.sound == s1.sound
Trusted            | Code(Spec) Body(Spec)          |     &&& aligned(vaddr, 8)
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.mappings === s1.mappings
Trusted            | Code(Spec) Body(Spec)          |     &&& valid_thread(c, thread_id)
Trusted            | Code(Spec) Body(Spec)          |     &&& s1.thread_state[thread_id] === AbstractArguments::Empty
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.thread_state === s1.thread_state
Trusted            | Code(Spec) Body(Spec)          |     &&& match pte {
Trusted            | Code(Spec) Body(Spec)          |         Some((base, pte)) => {
Trusted            | Code(Spec) Body(Spec)          |             let paddr = (pte.frame.base + (vaddr - base)) as nat;
Trusted            | Code(Spec) Body(Spec)          |             let pmem_idx = mem::word_index_spec(paddr);
Comment            | Comment                        |             // If pte is Some, it's an existing mapping that contains vaddr..
Trusted            | Code(Spec) Body(Spec)          |             &&& s1.mappings.contains_pair(base, pte)
Trusted            | Code(Spec) Body(Spec)          |             &&& between(
Trusted            | Code(Spec) Body(Spec)          |                 vaddr,
Trusted            | Code(Spec) Body(Spec)          |                 base,
Trusted            | Code(Spec) Body(Spec)          |                 base + pte.frame.size,
Trusted            | Code(Spec) Body(Spec)          |             )
Comment            | Comment                        |             // .. and the result depends on the flags.
Trusted            | Code(Spec) Body(Spec)          |             &&& match op {
Trusted            | Code(Spec) Body(Spec)          |                 RWOp::Store { new_value, result } => {
Trusted            | Code(Spec) Body(Spec)          |                     if pmem_idx < c.phys_mem_size && !pte.flags.is_supervisor
Trusted            | Code(Spec) Body(Spec)          |                         && pte.flags.is_writable {
Trusted            | Code(Spec) Body(Spec)          |                         &&& result is Ok
Trusted            | Code(Spec) Body(Spec)          |                         &&& s2.mem === s1.mem.insert(vmem_idx, new_value)
Trusted            | Code(Spec) Body(Spec)          |                     } else {
Trusted            | Code(Spec) Body(Spec)          |                         &&& result is Undefined
Trusted            | Code(Spec) Body(Spec)          |                         &&& s2.mem === s1.mem
Trusted            | Code(Spec) Body(Spec)          |                     }
Trusted            | Code(Spec) Body(Spec)          |                 },
Trusted            | Code(Spec) Body(Spec)          |                 RWOp::Load { is_exec, result } => {
Trusted            | Code(Spec) Body(Spec)          |                     &&& s2.mem === s1.mem
Trusted            | Code(Spec) Body(Spec)          |                     &&& if pmem_idx < c.phys_mem_size && !pte.flags.is_supervisor && (is_exec
Trusted            | Code(Spec) Body(Spec)          |                         ==> !pte.flags.disable_execute) {
Trusted            | Code(Spec) Body(Spec)          |                         &&& result is Value
Trusted            | Code(Spec) Body(Spec)          |                         &&& result->0 == s1.mem.index(vmem_idx)
Trusted            | Code(Spec) Body(Spec)          |                     } else {
Trusted            | Code(Spec) Body(Spec)          |                         &&& result is Undefined
Trusted            | Code(Spec) Body(Spec)          |                     }
Trusted            | Code(Spec) Body(Spec)          |                 },
Trusted            | Code(Spec) Body(Spec)          |             }
Trusted            | Code(Spec) Body(Spec)          |         },
Trusted            | Code(Spec) Body(Spec)          |         None => {
Comment            | Comment                        |             // If pte is None, no mapping containing vaddr exists..
Trusted            | Code(Spec) Body(Spec)          |             &&& !mem_domain_from_mappings(c.phys_mem_size, s1.mappings).contains(
Trusted            | Code(Spec) Body(Spec)          |                 vmem_idx,
Trusted            | Code(Spec) Body(Spec)          |             )
Comment            | Comment                        |             // .. and the result is always a Undefined and an unchanged memory.
Trusted            | Code(Spec) Body(Spec)          |             &&& s2.mem === s1.mem
Trusted            | Code(Spec) Body(Spec)          |             &&& match op {
Trusted            | Code(Spec) Body(Spec)          |                 RWOp::Store { new_value, result } => result is Undefined,
Trusted            | Code(Spec) Body(Spec)          |                 RWOp::Load { is_exec, result } => result is Undefined,
Trusted            | Code(Spec) Body(Spec)          |             }
Trusted            | Code(Spec) Body(Spec)          |         },
Trusted            | Code(Spec) Body(Spec)          |     }
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Comment            | Comment                        | // Map
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Trusted            | Signature(Spec)                | pub open spec fn step_Map_sound(
Trusted            | Signature(Spec)                |     mappings: Map<nat, PageTableEntry>,
Trusted            | Signature(Spec)                |     inflights: Set<AbstractArguments>,
Trusted            | Signature(Spec)                |     vaddr: nat,
Trusted            | Signature(Spec)                |     pte: PageTableEntry,
Trusted            | Code(Spec Signature Body(Spec  | ) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     &&& !candidate_mapping_overlaps_inflight_vmem(inflights, vaddr, pte.frame.size)
Trusted            | Code(Spec) Body(Spec)          |     &&& !candidate_mapping_overlaps_existing_pmem(mappings, pte)
Trusted            | Code(Spec) Body(Spec)          |     &&& !candidate_mapping_overlaps_inflight_pmem(inflights, pte)
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Signature(Spec)                | pub open spec fn step_Map_enabled(
Trusted            | Signature(Spec)                |     inflight: Set<AbstractArguments>,
Trusted            | Signature(Spec)                |     map: Map<nat, PageTableEntry>,
Trusted            | Signature(Spec)                |     vaddr: nat,
Trusted            | Signature(Spec)                |     pte: PageTableEntry,
Trusted            | Code(Spec Signature Body(Spec  | ) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     &&& aligned(vaddr, pte.frame.size)
Trusted            | Code(Spec) Body(Spec)          |     &&& aligned(pte.frame.base, pte.frame.size)
Trusted            | Code(Spec) Body(Spec)          |     &&& pte.frame.base <= MAX_PHYADDR
Trusted            | Code(Spec) Body(Spec)          |     &&& candidate_mapping_in_bounds(vaddr, pte)
Trusted            | Code(Spec) Body(Spec)          |     &&& {  // The size of the frame must be the entry_size of a layer that supports page mappings
Trusted            | Code(Spec) Body(Spec)          |         ||| pte.frame.size == L3_ENTRY_SIZE
Trusted            | Code(Spec) Body(Spec)          |         ||| pte.frame.size == L2_ENTRY_SIZE
Trusted            | Code(Spec) Body(Spec)          |         ||| pte.frame.size == L1_ENTRY_SIZE
Trusted            | Code(Spec) Body(Spec)          |     }
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Comment            | Comment                        | //think about weather or not map start is valid if it overlaps with existing vmem
Trusted            | Signature(Spec)                | pub open spec fn step_Map_start(
Trusted            | Signature(Spec)                |     c: AbstractConstants,
Trusted            | Signature(Spec)                |     s1: AbstractVariables,
Trusted            | Signature(Spec)                |     s2: AbstractVariables,
Trusted            | Signature(Spec)                |     thread_id: nat,
Trusted            | Signature(Spec)                |     vaddr: nat,
Trusted            | Signature(Spec)                |     pte: PageTableEntry,
Trusted            | Code(Spec Signature Body(Spec  | ) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     &&& step_Map_enabled(s1.thread_state.values(), s1.mappings, vaddr, pte)
Trusted            | Code(Spec) Body(Spec)          |     &&& valid_thread(c, thread_id)
Trusted            | Code(Spec) Body(Spec)          |     &&& s1.thread_state[thread_id] === AbstractArguments::Empty
Trusted            | Code(Spec) Body(Spec)          |     &&& if step_Map_sound(s1.mappings, s1.thread_state.values(), vaddr, pte) {
Trusted            | Code(Spec) Body(Spec)          |         state_unchanged_besides_thread_state(
Trusted            | Code(Spec) Body(Spec)          |             s1,
Trusted            | Code(Spec) Body(Spec)          |             s2,
Trusted            | Code(Spec) Body(Spec)          |             thread_id,
Trusted            | Code(Spec) Body(Spec)          |             AbstractArguments::Map { vaddr, pte },
Trusted            | Code(Spec) Body(Spec)          |         )
Trusted            | Code(Spec) Body(Spec)          |     } else {
Trusted            | Code(Spec) Body(Spec)          |         unsound_state(s1, s2)
Trusted            | Code(Spec) Body(Spec)          |     }
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Signature(Spec)                | pub open spec fn step_Map_end(
Trusted            | Signature(Spec)                |     c: AbstractConstants,
Trusted            | Signature(Spec)                |     s1: AbstractVariables,
Trusted            | Signature(Spec)                |     s2: AbstractVariables,
Trusted            | Signature(Spec)                |     thread_id: nat,
Trusted            | Signature(Spec)                |     result: Result<(), ()>,
Trusted            | Code(Spec Signature Body(Spec  | ) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.sound == s1.sound
Trusted            | Code(Spec) Body(Spec)          |     &&& valid_thread(c, thread_id)
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.thread_state === s1.thread_state.insert(thread_id, AbstractArguments::Empty)
Trusted            | Code(Spec) Body(Spec)          |     &&& match s1.thread_state[thread_id] {
Trusted            | Code(Spec) Body(Spec)          |         AbstractArguments::Map { vaddr, pte } => {
Comment            | Comment                        |             //&&& !candidate_mapping_overlaps_existing_pmem(s1.mappings, pte)
Trusted            | Code(Spec) Body(Spec)          |             &&& if (candidate_mapping_overlaps_existing_vmem(s1.mappings, vaddr, pte)) {
Trusted            | Code(Spec) Body(Spec)          |                 &&& result is Err
Trusted            | Code(Spec) Body(Spec)          |                 &&& s2.mappings === s1.mappings
Trusted            | Code(Spec) Body(Spec)          |                 &&& s2.mem === s1.mem
Trusted            | Code(Spec) Body(Spec)          |             } else {
Trusted            | Code(Spec) Body(Spec)          |                 &&& result is Ok
Trusted            | Code(Spec) Body(Spec)          |                 &&& s2.mappings === s1.mappings.insert(vaddr, pte)
Trusted            | Code(Spec) Body(Spec)          |                 &&& (forall|idx: nat|
Trusted            | Code(Spec) Body(Spec)          |                     #![auto]
Trusted            | Code(Spec) Body(Spec)          |                     s1.mem.dom().contains(idx) ==> s2.mem[idx] === s1.mem[idx])
Trusted            | Code(Spec) Body(Spec)          |                 &&& s2.mem.dom() === mem_domain_from_mappings(c.phys_mem_size, s2.mappings)
Trusted            | Code(Spec) Body(Spec)          |             }
Trusted            | Code(Spec) Body(Spec)          |         },
Trusted            | Code(Spec) Body(Spec)          |         _ => { false },
Trusted            | Code(Spec) Body(Spec)          |     }
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Comment            | Comment                        | // Unmap
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Trusted            | Signature(Spec)                | pub open spec fn step_Unmap_sound(
Trusted            | Signature(Spec)                |     inflights: Set<AbstractArguments>,
Trusted            | Signature(Spec)                |     vaddr: nat,
Trusted            | Signature(Spec)                |     pte_size: nat,
Trusted            | Code(Spec Signature Body(Spec  | ) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     !candidate_mapping_overlaps_inflight_vmem(inflights, vaddr, pte_size)
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Code(Spec Signature Body(Spec  | pub open spec fn step_Unmap_enabled(vaddr: nat) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     &&& vaddr < x86_arch_spec.upper_vaddr(0, 0)
Trusted            | Code(Spec) Body(Spec)          |     &&& {  // The given vaddr must be aligned to some valid page size
Trusted            | Code(Spec) Body(Spec)          |         ||| aligned(vaddr, L3_ENTRY_SIZE as nat)
Trusted            | Code(Spec) Body(Spec)          |         ||| aligned(vaddr, L2_ENTRY_SIZE as nat)
Trusted            | Code(Spec) Body(Spec)          |         ||| aligned(vaddr, L1_ENTRY_SIZE as nat)
Trusted            | Code(Spec) Body(Spec)          |     }
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Comment            | Comment                        | //shouldnt need to check for overlapping pmem bc:
Comment            | Comment                        | // if its being mapped rn then itll cause Err anyways
Comment            | Comment                        | // if its being unmapped rn then vmem is the way to go.
Trusted            | Signature(Spec)                | pub open spec fn step_Unmap_start(
Trusted            | Signature(Spec)                |     c: AbstractConstants,
Trusted            | Signature(Spec)                |     s1: AbstractVariables,
Trusted            | Signature(Spec)                |     s2: AbstractVariables,
Trusted            | Signature(Spec)                |     thread_id: nat,
Trusted            | Signature(Spec)                |     vaddr: nat,
Trusted            | Code(Spec Signature Body(Spec  | ) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     let pte = if (s1.mappings.dom().contains(vaddr)) {
Trusted            | Code(Spec) Body(Spec)          |         Some(s1.mappings.index(vaddr))
Trusted            | Code(Spec) Body(Spec)          |     } else {
Trusted            | Code(Spec) Body(Spec)          |         Option::None
Trusted            | Code(Spec) Body(Spec)          |     };
Trusted            | Code(Spec) Body(Spec)          |     let pte_size = if (pte is Some) {
Trusted            | Code(Spec) Body(Spec)          |         pte.unwrap().frame.size
Trusted            | Code(Spec) Body(Spec)          |     } else {
Trusted            | Code(Spec) Body(Spec)          |         0
Trusted            | Code(Spec) Body(Spec)          |     };
Trusted            | Code(Spec) Body(Spec)          |     &&& step_Unmap_enabled(vaddr)
Trusted            | Code(Spec) Body(Spec)          |     &&& valid_thread(c, thread_id)
Trusted            | Code(Spec) Body(Spec)          |     &&& s1.thread_state[thread_id] === AbstractArguments::Empty
Trusted            | Code(Spec) Body(Spec)          |     &&& if step_Unmap_sound(s1.thread_state.values(), vaddr, pte_size) {
Trusted            | Code(Spec) Body(Spec)          |         &&& s2.thread_state === s1.thread_state.insert(
Trusted            | Code(Spec) Body(Spec)          |             thread_id,
Trusted            | Code(Spec) Body(Spec)          |             AbstractArguments::Unmap { vaddr, pte },
Trusted            | Code(Spec) Body(Spec)          |         )
Trusted            | Code(Spec) Body(Spec)          |         &&& if (pte is None) {
Trusted            | Code(Spec) Body(Spec)          |             &&& s2.mappings === s1.mappings
Trusted            | Code(Spec) Body(Spec)          |             &&& s2.mem === s1.mem
Trusted            | Code(Spec) Body(Spec)          |         } else {
Trusted            | Code(Spec) Body(Spec)          |             &&& s2.mappings === s1.mappings.remove(vaddr)
Trusted            | Code(Spec) Body(Spec)          |             &&& s2.mem.dom() === mem_domain_from_mappings(c.phys_mem_size, s2.mappings)
Trusted            | Code(Spec) Body(Spec)          |             &&& (forall|idx: nat|
Trusted            | Code(Spec) Body(Spec)          |                 #![auto]
Trusted            | Code(Spec) Body(Spec)          |                 s2.mem.dom().contains(idx) ==> s2.mem[idx] === s1.mem[idx])
Trusted            | Code(Spec) Body(Spec)          |         }
Trusted            | Code(Spec) Body(Spec)          |         &&& s2.mem.dom() === mem_domain_from_mappings(c.phys_mem_size, s1.mappings.remove(vaddr))
Trusted            | Code(Spec) Body(Spec)          |         &&& s2.sound == s1.sound
Trusted            | Code(Spec) Body(Spec)          |     } else {
Trusted            | Code(Spec) Body(Spec)          |         unsound_state(s1, s2)
Trusted            | Code(Spec) Body(Spec)          |     }
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Signature(Spec)                | pub open spec fn step_Unmap_end(
Trusted            | Signature(Spec)                |     c: AbstractConstants,
Trusted            | Signature(Spec)                |     s1: AbstractVariables,
Trusted            | Signature(Spec)                |     s2: AbstractVariables,
Trusted            | Signature(Spec)                |     thread_id: nat,
Trusted            | Signature(Spec)                |     result: Result<(), ()>,
Trusted            | Code(Spec Signature Body(Spec  | ) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     &&& valid_thread(c, thread_id)
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.thread_state === s1.thread_state.insert(thread_id, AbstractArguments::Empty)
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.sound == s1.sound
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.mappings === s1.mappings
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.mem === s1.mem
Trusted            | Code(Spec) Body(Spec)          |     &&& match s1.thread_state[thread_id] {
Trusted            | Code(Spec) Body(Spec)          |         AbstractArguments::Unmap { vaddr, pte } => {
Trusted            | Code(Spec) Body(Spec)          |             &&& if pte is Some {
Trusted            | Code(Spec) Body(Spec)          |                 result is Ok
Trusted            | Code(Spec) Body(Spec)          |             } else {
Trusted            | Code(Spec) Body(Spec)          |                 result is Err
Trusted            | Code(Spec) Body(Spec)          |             }
Trusted            | Code(Spec) Body(Spec)          |         },
Trusted            | Code(Spec) Body(Spec)          |         _ => { false },
Trusted            | Code(Spec) Body(Spec)          |     }
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Comment            | Comment                        | // Stutter
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Trusted            | Signature(Spec)                | pub open spec fn step_Stutter(
Trusted            | Signature(Spec)                |     c: AbstractConstants,
Trusted            | Signature(Spec)                |     s1: AbstractVariables,
Trusted            | Signature(Spec)                |     s2: AbstractVariables,
Trusted            | Code(Spec Signature Body(Spec  | ) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     s1 === s2
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Comment            | Comment                        | //if s1.sound then match else !s2.sound
Trusted            | Signature(Spec)                | pub open spec fn next_step(
Trusted            | Signature(Spec)                |     c: AbstractConstants,
Trusted            | Signature(Spec)                |     s1: AbstractVariables,
Trusted            | Signature(Spec)                |     s2: AbstractVariables,
Trusted            | Signature(Spec)                |     step: AbstractStep,
Trusted            | Code(Spec Signature Body(Spec  | ) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     if (s1.sound) {
Trusted            | Code(Spec) Body(Spec)          |         match step {
Trusted            | Code(Spec) Body(Spec)          |             AbstractStep::ReadWrite { thread_id, vaddr, op, pte } => step_ReadWrite(
Trusted            | Code(Spec) Body(Spec)          |                 c,
Trusted            | Code(Spec) Body(Spec)          |                 s1,
Trusted            | Code(Spec) Body(Spec)          |                 s2,
Trusted            | Code(Spec) Body(Spec)          |                 thread_id,
Trusted            | Code(Spec) Body(Spec)          |                 vaddr,
Trusted            | Code(Spec) Body(Spec)          |                 op,
Trusted            | Code(Spec) Body(Spec)          |                 pte,
Trusted            | Code(Spec) Body(Spec)          |             ),
Trusted            | Code(Spec) Body(Spec)          |             AbstractStep::MapStart { thread_id, vaddr, pte } => step_Map_start(
Trusted            | Code(Spec) Body(Spec)          |                 c,
Trusted            | Code(Spec) Body(Spec)          |                 s1,
Trusted            | Code(Spec) Body(Spec)          |                 s2,
Trusted            | Code(Spec) Body(Spec)          |                 thread_id,
Trusted            | Code(Spec) Body(Spec)          |                 vaddr,
Trusted            | Code(Spec) Body(Spec)          |                 pte,
Trusted            | Code(Spec) Body(Spec)          |             ),
Trusted            | Code(Spec) Body(Spec)          |             AbstractStep::MapEnd { thread_id, result } => step_Map_end(
Trusted            | Code(Spec) Body(Spec)          |                 c,
Trusted            | Code(Spec) Body(Spec)          |                 s1,
Trusted            | Code(Spec) Body(Spec)          |                 s2,
Trusted            | Code(Spec) Body(Spec)          |                 thread_id,
Trusted            | Code(Spec) Body(Spec)          |                 result,
Trusted            | Code(Spec) Body(Spec)          |             ),
Trusted            | Code(Spec) Body(Spec)          |             AbstractStep::UnmapStart { thread_id, vaddr } => step_Unmap_start(
Trusted            | Code(Spec) Body(Spec)          |                 c,
Trusted            | Code(Spec) Body(Spec)          |                 s1,
Trusted            | Code(Spec) Body(Spec)          |                 s2,
Trusted            | Code(Spec) Body(Spec)          |                 thread_id,
Trusted            | Code(Spec) Body(Spec)          |                 vaddr,
Trusted            | Code(Spec) Body(Spec)          |             ),
Trusted            | Code(Spec) Body(Spec)          |             AbstractStep::UnmapEnd { thread_id, result } => step_Unmap_end(
Trusted            | Code(Spec) Body(Spec)          |                 c,
Trusted            | Code(Spec) Body(Spec)          |                 s1,
Trusted            | Code(Spec) Body(Spec)          |                 s2,
Trusted            | Code(Spec) Body(Spec)          |                 thread_id,
Trusted            | Code(Spec) Body(Spec)          |                 result,
Trusted            | Code(Spec) Body(Spec)          |             ),
Trusted            | Code(Spec) Body(Spec)          |             AbstractStep::Stutter => step_Stutter(c, s1, s2),
Trusted            | Code(Spec) Body(Spec)          |         }
Trusted            | Code(Spec) Body(Spec)          |     } else {
Trusted            | Code(Spec) Body(Spec)          |         !s2.sound
Trusted            | Code(Spec) Body(Spec)          |     }
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Code(Spec Signature Body(Spec  | pub open spec fn next(c: AbstractConstants, s1: AbstractVariables, s2: AbstractVariables) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     exists|step: AbstractStep| next_step(c, s1, s2, step)
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
                   | Code(Spec Signature Body(Spec  | pub open spec fn pmem_no_overlap(mappings: Map<nat, PageTableEntry>) -> bool { // $line_count$${$
                   | Code(Spec) Body(Spec)          |     forall|bs1: nat, bs2: nat|
                   | Code(Spec) Body(Spec)          |         mappings.dom().contains(bs1) && mappings.dom().contains(bs2) && overlap(
                   | Code(Spec) Body(Spec)          |             mappings.index(bs1).frame,
                   | Code(Spec) Body(Spec)          |             mappings.index(bs2).frame,
                   | Code(Spec) Body(Spec)          |         ) ==> equal(bs1, bs2)
                   | Code(Spec) Body(Spec)          | }
                   |                                | 
                   | Signature(Spec)                | pub open spec fn inflight_map_no_overlap_pmem(
                   | Signature(Spec)                |     inflightargs: Set<AbstractArguments>,
                   | Signature(Spec)                |     mappings: Map<nat, PageTableEntry>,
                   | Code(Spec Signature Body(Spec  | ) -> bool {
                   | Code(Spec) Body(Spec)          |     forall|b: AbstractArguments|
                   | Code(Spec) Body(Spec)          |         #![auto]
                   | Code(Spec) Body(Spec)          |         {
                   | Code(Spec) Body(Spec)          |             inflightargs.contains(b) ==> match b {
                   | Code(Spec) Body(Spec)          |                 AbstractArguments::Map { vaddr, pte } => {
                   | Code(Spec) Body(Spec)          |                     !candidate_mapping_overlaps_existing_pmem(mappings, pte)
                   | Code(Spec) Body(Spec)          |                 },
                   | Code(Spec) Body(Spec)          |                 _ => { true },
                   | Code(Spec) Body(Spec)          |             }
                   | Code(Spec) Body(Spec)          |         }
                   | Code(Spec) Body(Spec)          | }
                   |                                | 
                   | Signature(Spec)                | pub open spec fn inflight_map_no_overlap_inflight_pmem(
                   | Signature(Spec)                |     inflightargs: Set<AbstractArguments>,
                   | Code(Spec Signature Body(Spec  | ) -> bool {
                   | Code(Spec) Body(Spec)          |     forall|b: AbstractArguments|
                   | Code(Spec) Body(Spec)          |         #![auto]
                   | Code(Spec) Body(Spec)          |         {
                   | Code(Spec) Body(Spec)          |             inflightargs.contains(b) ==> match b {
                   | Code(Spec) Body(Spec)          |                 AbstractArguments::Map { vaddr, pte } => {
                   | Code(Spec) Body(Spec)          |                     !candidate_mapping_overlaps_inflight_pmem(inflightargs.remove(b), pte)
                   | Code(Spec) Body(Spec)          |                 },
                   | Code(Spec) Body(Spec)          |                 _ => { true },
                   | Code(Spec) Body(Spec)          |             }
                   | Code(Spec) Body(Spec)          |         }
                   | Code(Spec) Body(Spec)          | }
                   |                                | 
                   | Code(Spec Signature Body(Spec  | pub open spec fn mappings_frame_sizes_over_zero(mappings: Map<nat, PageTableEntry>) -> bool {
                   | Code(Spec) Body(Spec)          |     forall|base: nat|
                   | Code(Spec) Body(Spec)          |         #![auto]
                   | Code(Spec) Body(Spec)          |         mappings.dom().contains(base) ==> above_zero(mappings.index(base).frame.size)
                   | Code(Spec) Body(Spec)          | }
                   |                                | 
                   | Code(Spec Signature Body(Spec  | pub open spec fn inflight_mem_size_over_zero(inflightargs: Set<AbstractArguments>) -> bool {
                   | Code(Spec) Body(Spec)          |     forall|b: AbstractArguments|
                   | Code(Spec) Body(Spec)          |         #![auto]
                   | Code(Spec) Body(Spec)          |         {
                   | Code(Spec) Body(Spec)          |             inflightargs.contains(b) ==> match b {
                   | Code(Spec) Body(Spec)          |                 AbstractArguments::Map { vaddr, pte } => { above_zero(pte.frame.size) },
                   | Code(Spec) Body(Spec)          |                 _ => { true },
                   | Code(Spec) Body(Spec)          |             }
                   | Code(Spec) Body(Spec)          |         }
                   | Code(Spec) Body(Spec)          | }
                   |                                | 
                   | Signature(Spec)                | pub open spec fn if_map_then_unique(thread_state: Map<nat, AbstractArguments>, id: nat) -> bool
                   | Signature(Spec)                |     recommends
                   | Signature(Spec)                |         thread_state.dom().contains(id),
                   | Code(Spec) Body(Spec)          | {
                   | Code(Spec) Body(Spec)          |     if let AbstractArguments::Map { vaddr, pte } = thread_state.index(id) {
                   | Code(Spec) Body(Spec)          |         !thread_state.remove(id).values().contains(thread_state.index(id))
                   | Code(Spec) Body(Spec)          |     } else {
                   | Code(Spec) Body(Spec)          |         true
                   | Code(Spec) Body(Spec)          |     }
                   | Code(Spec) Body(Spec)          | }
                   |                                | 
                   | Code(Spec Signature Body(Spec  | pub open spec fn inflight_maps_unique(thread_state: Map<nat, AbstractArguments>) -> bool {
                   | Code(Spec) Body(Spec)          |     forall|a: nat| #[trigger] thread_state.dom().contains(a) ==> if_map_then_unique(thread_state, a)
                   | Code(Spec) Body(Spec)          | }
                   |                                | 
                   | Code(Spec Signature Body(Spec  | pub open spec fn inv(c: AbstractConstants, s: AbstractVariables) -> bool {
                   | Code(Spec) Body(Spec)          |     &&& wf(c, s)
                   | Code(Spec) Body(Spec)          |     &&& pmem_no_overlap(
                   | Code(Spec) Body(Spec)          |         s.mappings,
                   | Code(Spec) Body(Spec)          |     )
Comment            | Comment                        |     //invariants needed to proof the former
                   | Code(Spec) Body(Spec)          |     &&& inflight_map_no_overlap_pmem(s.thread_state.values(), s.mappings)
                   | Code(Spec) Body(Spec)          |     &&& inflight_map_no_overlap_inflight_pmem(s.thread_state.values())
                   | Code(Spec) Body(Spec)          |     &&& mappings_frame_sizes_over_zero(s.mappings)
                   | Code(Spec) Body(Spec)          |     &&& inflight_mem_size_over_zero(s.thread_state.values())
                   | Code(Spec) Body(Spec)          |     &&& inflight_maps_unique(s.thread_state)
                   | Code(Spec) Body(Spec)          | }
Comment            | Comment                        | // $line_count$}$
                   |                                | 
                   | Signature(Proof)               | pub proof fn init_implies_inv(c: AbstractConstants, s: AbstractVariables) // $line_count$${$
                   | Signature(Proo FunctionSpec    |     requires
                   | Signature(Proo FunctionSpec    |         init(c, s),
                   | Signature(Proo FunctionSpec    |     ensures
                   | Signature(Proo FunctionSpec    |         inv(c, s),
                   | Code(Proof) Body(Proof)        | {
                   | Code(Proof) Body(Proof)        | }
                   |                                | 
                   | Signature(Proof)               | pub proof fn next_step_preserves_inv(
                   | Signature(Proof)               |     c: AbstractConstants,
                   | Signature(Proof)               |     s1: AbstractVariables,
                   | Signature(Proof)               |     s2: AbstractVariables,
                   | Signature(Proof)               | )
                   | Signature(Proo FunctionSpec    |     requires
                   | Signature(Proo FunctionSpec    |         next(c, s1, s2),
                   | Signature(Proo FunctionSpec    |         s1.sound ==> inv(c, s1),
                   | Signature(Proo FunctionSpec    |     ensures
                   | Signature(Proo FunctionSpec    |         s2.sound ==> inv(c, s2),
                   | Code(Proof) Body(Proof)        | {
                   | Code(Proof) Body(Proof)        |     if (s1.sound) {
                   | Code(Proof) Body(Proof)        |         let p = choose|step: AbstractStep| next_step(c, s1, s2, step);
                   | Code(Proof) Body(Proof)        |         match p {
                   | Code(Proof) Body(Proof)        |             AbstractStep::UnmapStart { thread_id, vaddr } => {
                   | Code(Proof) Body(Proof)        |                 unmap_start_preserves_inv(c, s1, s2, thread_id, vaddr);
                   | Code(Proof) Body(Proof)        |             },
                   | Code(Proof) Body(Proof)        |             AbstractStep::UnmapEnd { thread_id, result } => {
                   | Code(Proo ProofDire Body(Proo  |                 assert(s2.thread_state.values().subset_of(
                   | Code(Proo ProofDire Body(Proo  |                     s1.thread_state.values().insert(AbstractArguments::Empty),
                   | Code(Proo ProofDire Body(Proo  |                 ));
                   | Code(Proof) Body(Proof)        |                 lemma_mem_domain_from_mapping_finite(c.phys_mem_size, s2.mappings);
                   | Code(Proof) Body(Proof)        |                 insert_non_map_preserves_unique(
                   | Code(Proof) Body(Proof)        |                     s1.thread_state,
                   | Code(Proof) Body(Proof)        |                     thread_id,
                   | Code(Proof) Body(Proof)        |                     AbstractArguments::Empty,
                   | Code(Proof) Body(Proof)        |                 );
                   | Code(Proof) Body(Proof)        |             },
                   | Code(Proof) Body(Proof)        |             AbstractStep::MapStart { thread_id, vaddr, pte } => {
                   | Code(Proof) Body(Proof)        |                 map_start_preserves_inv(c, s1, s2, thread_id, vaddr, pte);
                   | Code(Proof) Body(Proof)        |             },
                   | Code(Proof) Body(Proof)        |             AbstractStep::MapEnd { thread_id, result } => {
                   | Code(Proof) Body(Proof)        |                 map_end_preserves_inv(c, s1, s2, thread_id, result);
                   | Code(Proof) Body(Proof)        |             },
                   | Code(Proof) Body(Proof)        |             _ => {},
                   | Code(Proof) Body(Proof)        |         }
                   | Code(Proof) Body(Proof)        |     } else {
                   | Code(Proo ProofDire Body(Proo  |         assert(!s2.sound);
                   | Code(Proof) Body(Proof)        |     }
                   | Comment                        |     // $line_count$$}$
                   | Code(Proof) Body(Proof)        | }
                   |                                | 
                   |                                | } // verus!

# spec_t/os.rs
                   |                                | #![verus::trusted]
Comment            | Comment                        | // trusted:
Comment            | Comment                        | // describes how the whole system behaves
Comment            | Comment                        | //
Comment            | Comment                        | // this refers to definitions in an untrusted file, but uses them in a way that the
Comment            | Comment                        | // state-machine refinement can check
                   |                                | 
                   |                                | use vstd::prelude::*;
                   |                                | 
                   |                                | use crate::impl_u::spec_pt;
                   |                                | use crate::spec_t::{hardware, hlspec, mem};
Comment            | Comment                        | //TODO move core to definitions
                   |                                | use crate::definitions_t::{
                   |                                |     above_zero, aligned, between, candidate_mapping_in_bounds,
                   |                                |     candidate_mapping_overlaps_existing_pmem, candidate_mapping_overlaps_existing_vmem, overlap,
                   |                                |     x86_arch_spec, HWLoadResult, HWRWOp, HWStoreResult, LoadResult, MemRegion, PageTableEntry,
                   |                                |     RWOp, StoreResult, L1_ENTRY_SIZE, L2_ENTRY_SIZE, L3_ENTRY_SIZE, MAX_PHYADDR, WORD_SIZE,
                   |                                | };
                   |                                | use crate::spec_t::hardware::Core;
                   |                                | use crate::extra::result_map_ok;
                   |                                | 
Comment            | Comment                        | //TODO think about labels
                   |                                | verus! {
                   |                                | 
Trusted            | DatatypeDecl                   | pub struct OSConstants {
Trusted            | DatatypeDecl                   |     pub hw: hardware::HWConstants,
Comment            | Comment                        |     //maps User Level Thread to its assigned core
Trusted            | DatatypeDecl                   |     pub ULT2core: Map<nat, Core>,
Comment            | Comment                        |     //highest thread_id
Trusted            | DatatypeDecl                   |     pub ULT_no: nat,
Trusted            | DatatypeDecl                   | }
                   |                                | 
Trusted            | DatatypeDecl                   | pub struct OSVariables {
Trusted            | DatatypeDecl                   |     pub hw: hardware::HWVariables,
Comment            | Comment                        |     // maps numa node to ULT operation spinning/operating on it
Trusted            | DatatypeDecl                   |     pub core_states: Map<Core, CoreState>,
Trusted            | DatatypeDecl                   |     pub TLB_Shootdown: ShootdownVector,
Comment            | Comment                        |     //Does not affect behaviour of os_specs, just set when operations with overlapping operations are used
Trusted            | DatatypeDecl                   |     pub sound: bool,
Trusted            | DatatypeDecl                   | }
                   |                                | 
Trusted            | DatatypeDecl                   | pub struct ShootdownVector {
Trusted            | DatatypeDecl                   |     pub vaddr: nat,
Trusted            | DatatypeDecl                   |     pub open_requests: Set<Core>,
Trusted            | DatatypeDecl                   | }
                   |                                | 
Trusted            | DatatypeDecl Directive         | #[allow(inconsistent_fields)]
Trusted            | DatatypeDecl                   | pub enum CoreState {
Trusted            | DatatypeDecl                   |     Idle,
Trusted            | DatatypeDecl                   |     MapWaiting { ULT_id: nat, vaddr: nat, pte: PageTableEntry },
Trusted            | DatatypeDecl                   |     MapExecuting { ULT_id: nat, vaddr: nat, pte: PageTableEntry },
Trusted            | DatatypeDecl                   |     UnmapWaiting { ULT_id: nat, vaddr: nat },
Trusted            | DatatypeDecl                   |     UnmapOpExecuting { ULT_id: nat, vaddr: nat, result: Result<PageTableEntry, ()> },
Trusted            | DatatypeDecl                   |     UnmapOpDone { ULT_id: nat, vaddr: nat, result: Result<PageTableEntry, ()> },
Trusted            | DatatypeDecl                   |     UnmapShootdownWaiting {
Trusted            | DatatypeDecl                   |         ULT_id: nat,
Trusted            | DatatypeDecl                   |         vaddr: nat,
Trusted            | DatatypeDecl                   |         result: Result<PageTableEntry, ()>,
Trusted            | DatatypeDecl                   |     },
Trusted            | DatatypeDecl                   | }
                   |                                | 
                   | Impl                           | impl CoreState {
Trusted            | Code(S Impl Signat Body(S      |     pub open spec fn holds_lock(self) -> bool {
Trusted            | Code(Spec Impl Body(Spec       |         match self {
Trusted            | Code(Spec Impl Body(Spec       |             CoreState::Idle
Trusted            | Code(Spec Impl Body(Spec       |             | CoreState::MapWaiting { .. }
Trusted            | Code(Spec Impl Body(Spec       |             | CoreState::UnmapWaiting { .. } => false,
Trusted            | Code(Spec Impl Body(Spec       |             _ => true,
Trusted            | Code(Spec Impl Body(Spec       |         }
Trusted            | Code(Spec Impl Body(Spec       |     }
                   | Impl                           | 
Trusted            | Code(S Impl Signat Body(S      |     pub open spec fn is_idle(self) -> bool {
Trusted            | Code(Spec Impl Body(Spec       |         self is Idle
Trusted            | Code(Spec Impl Body(Spec       |     }
                   | Impl                           | 
Trusted            | Impl Signature(Spec            |     pub open spec fn vmem_pte_size(self, pt: Map<nat, PageTableEntry>) -> nat
Trusted            | Impl Signature(Spec            |         recommends
Trusted            | Impl Signature(Spec            |             !self.is_idle(),
Trusted            | Code(Spec Impl Body(Spec       |     {
Trusted            | Code(Spec Impl Body(Spec       |         match self {
Trusted            | Code(Spec Impl Body(Spec       |             CoreState::MapWaiting { pte, .. } | CoreState::MapExecuting { pte, .. } => {
Trusted            | Code(Spec Impl Body(Spec       |                 pte.frame.size
Trusted            | Code(Spec Impl Body(Spec       |             },
Trusted            | Code(Spec Impl Body(Spec       |             CoreState::UnmapWaiting { vaddr, .. } => {
Trusted            | Code(Spec Impl Body(Spec       |                 if pt.dom().contains(vaddr) {
Trusted            | Code(Spec Impl Body(Spec       |                     pt.index(vaddr).frame.size
Trusted            | Code(Spec Impl Body(Spec       |                 } else {
Trusted            | Code(Spec Impl Body(Spec       |                     0
Trusted            | Code(Spec Impl Body(Spec       |                 }
Trusted            | Code(Spec Impl Body(Spec       |             },
Trusted            | Code(Spec Impl Body(Spec       |             CoreState::UnmapOpExecuting { result, .. }
Trusted            | Code(Spec Impl Body(Spec       |             | CoreState::UnmapOpDone { result, .. }
Trusted            | Code(Spec Impl Body(Spec       |             | CoreState::UnmapShootdownWaiting { result, .. } => {
Trusted            | Code(Spec Impl Body(Spec       |                 if result is Ok {
Trusted            | Code(Spec Impl Body(Spec       |                     result.get_Ok_0().frame.size
Trusted            | Code(Spec Impl Body(Spec       |                 } else {
Trusted            | Code(Spec Impl Body(Spec       |                     0
Trusted            | Code(Spec Impl Body(Spec       |                 }
Trusted            | Code(Spec Impl Body(Spec       |             },
Trusted            | Code(Spec Impl Body(Spec       |             CoreState::Idle => arbitrary(),
Trusted            | Code(Spec Impl Body(Spec       |         }
Trusted            | Code(Spec Impl Body(Spec       |     }
                   | Impl                           | 
Trusted            | Impl Signature(Spec            |     pub open spec fn vaddr(self) -> nat
Trusted            | Impl Signature(Spec            |         recommends
Trusted            | Impl Signature(Spec            |             !self.is_idle(),
Trusted            | Code(Spec Impl Body(Spec       |     {
Trusted            | Code(Spec Impl Body(Spec       |         match self {
Trusted            | Code(Spec Impl Body(Spec       |             CoreState::MapWaiting { vaddr, .. }
Trusted            | Code(Spec Impl Body(Spec       |             | CoreState::MapExecuting { vaddr, .. }
Trusted            | Code(Spec Impl Body(Spec       |             | CoreState::UnmapWaiting { vaddr, .. }
Trusted            | Code(Spec Impl Body(Spec       |             | CoreState::UnmapOpExecuting { vaddr, .. }
Trusted            | Code(Spec Impl Body(Spec       |             | CoreState::UnmapOpDone { vaddr, .. }
Trusted            | Code(Spec Impl Body(Spec       |             | CoreState::UnmapShootdownWaiting { vaddr, .. } => { vaddr },
Trusted            | Code(Spec Impl Body(Spec       |             CoreState::Idle => arbitrary(),
Trusted            | Code(Spec Impl Body(Spec       |         }
Trusted            | Code(Spec Impl Body(Spec       |     }
                   | Impl                           | }
                   |                                | 
                   | Impl                           | impl OSConstants {
Trusted            | Code(S Impl Signat Body(S      |     pub open spec fn valid_ULT(self, ULT_id: nat) -> bool {
Trusted            | Code(Spec Impl Body(Spec       |         ULT_id < self.ULT_no
Trusted            | Code(Spec Impl Body(Spec       |     }
                   | Impl                           | 
Trusted            | Code(S Impl Signat Body(S      |     pub open spec fn interp(self) -> hlspec::AbstractConstants {
Trusted            | Code(Spec Impl Body(Spec       |         hlspec::AbstractConstants { thread_no: self.ULT_no, phys_mem_size: self.hw.phys_mem_size }
Trusted            | Code(Spec Impl Body(Spec       |     }
                   | Impl                           | }
                   |                                | 
                   | Impl                           | impl OSVariables {
Trusted            | Code(S Impl Signat Body(S      |     pub open spec fn kernel_lock(self, consts: OSConstants) -> Option<Core> {
Trusted            | Code(Spec Impl Body(Spec       |         if exists|c: Core|
Trusted            | Code(Spec Impl Body(Spec       |             hardware::valid_core(consts.hw, c) && (#[trigger] self.core_states[c].holds_lock()) {
Trusted            | Code(Spec Impl Body(Spec       |             Some(
Trusted            | Code(Spec Impl Body(Spec       |                 choose|c: Core|
Trusted            | Code(Spec Impl Body(Spec       |                     hardware::valid_core(consts.hw, c) && (
Trusted            | Code(Spec Impl Body(Spec       |                     #[trigger] self.core_states[c].holds_lock()),
Trusted            | Code(Spec Impl Body(Spec       |             )
Trusted            | Code(Spec Impl Body(Spec       |         } else {
Trusted            | Code(Spec Impl Body(Spec       |             None
Trusted            | Code(Spec Impl Body(Spec       |         }
Trusted            | Code(Spec Impl Body(Spec       |     }
                   | Impl                           | 
Comment            | Comment                        |     ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Comment            | Comment                        |     // Invariant and WF
Comment            | Comment                        |     ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Spec               | Code(S Impl Signat Body(S      |     pub open spec fn valid_ids(self, c: OSConstants) -> bool { // $line_count$Spec${$
Spec               | Code(Spec Impl Body(Spec       |         forall|core: Core|
Spec               | Code(Spec Impl Body(Spec       |             hardware::valid_core(c.hw, core) ==> match self.core_states[core] {
Spec               | Code(Spec Impl Body(Spec       |                 CoreState::MapWaiting { ULT_id, .. }
Spec               | Code(Spec Impl Body(Spec       |                 | CoreState::MapExecuting { ULT_id, .. }
Spec               | Code(Spec Impl Body(Spec       |                 | CoreState::UnmapWaiting { ULT_id, .. }
Spec               | Code(Spec Impl Body(Spec       |                 | CoreState::UnmapOpExecuting { ULT_id, .. }
Spec               | Code(Spec Impl Body(Spec       |                 | CoreState::UnmapOpDone { ULT_id, .. }
Spec               | Code(Spec Impl Body(Spec       |                 | CoreState::UnmapShootdownWaiting { ULT_id, .. } => {
Spec               | Code(Spec Impl Body(Spec       |                     &&& c.valid_ULT(ULT_id)
Spec               | Code(Spec Impl Body(Spec       |                     &&& c.ULT2core[ULT_id] === core
Spec               | Code(Spec Impl Body(Spec       |                 },
Spec               | Code(Spec Impl Body(Spec       |                 CoreState::Idle => true,
Spec               | Code(Spec Impl Body(Spec       |             }
Spec               | Code(Spec Impl Body(Spec       |     }
Comment            | Comment                        |     // $line_count$}$
Comment            | Comment                        | /*
Comment            | Comment                        |     pub open spec fn inflight_pte_above_zero_pte_result_consistant(self, c: OSConstants) -> bool {
Comment            | Comment                        |         forall|core: Core|
Comment            | Comment                        |             {
Comment            | Comment                        |                 hardware::valid_core(c.hw, core) ==> match self.core_states[core] {
Comment            | Comment                        |                     CoreState::MapWaiting { vaddr, pte, .. }
Comment            | Comment                        |                     | CoreState::MapExecuting { vaddr, pte, .. } => { above_zero(pte.frame.size) },
Comment            | Comment                        |                     CoreState::UnmapWaiting { vaddr, .. } => {
Comment            | Comment                        |                         self.interp_pt_mem().dom().contains(vaddr) ==> above_zero(
Comment            | Comment                        |                             self.interp_pt_mem()[vaddr].frame.size,
Comment            | Comment                        |                         )
Comment            | Comment                        |                     }
Comment            | Comment                        |                     CoreState::UnmapOpExecuting { result, .. }
Comment            | Comment                        |                     | CoreState::UnmapOpDone { result, .. }
Comment            | Comment                        |                     | CoreState::UnmapShootdownWaiting { result, .. } => {
Comment            | Comment                        |                         result is Ok ==> above_zero(result.get_Ok_0().frame.size)
Comment            | Comment                        |                     },
Comment            | Comment                        |                     CoreState::Idle => { true },
Comment            | Comment                        |                 }
Comment            | Comment                        |             }
Comment            | Comment                        |     }
Comment            | Comment                        | */
Trusted            | Code(S Impl Signat Body(S      |     pub open spec fn successful_unmaps(self, c: OSConstants) -> bool {
Trusted            | Code(Spec Impl Body(Spec       |         forall|core: Core|
Trusted            | Code(Spec Impl Body(Spec       |             {
Trusted            | Code(Spec Impl Body(Spec       |                 hardware::valid_core(c.hw, core) ==> match self.core_states[core] {
Trusted            | Code(Spec Impl Body(Spec       |                     CoreState::UnmapOpExecuting { vaddr, .. }
Trusted            | Code(Spec Impl Body(Spec       |                     | CoreState::UnmapOpDone { vaddr, .. }
Trusted            | Code(Spec Impl Body(Spec       |                     | CoreState::UnmapShootdownWaiting { vaddr, .. } => {
Trusted            | Code(Spec Impl Body(Spec       |                         !self.interp_pt_mem().dom().contains(vaddr)
Trusted            | Code(Spec Impl Body(Spec       |                     },
Trusted            | Code(Spec Impl Body(Spec       |                     _ => { true },
Trusted            | Code(Spec Impl Body(Spec       |                 }
Trusted            | Code(Spec Impl Body(Spec       |             }
Trusted            | Code(Spec Impl Body(Spec       |     }
                   | Impl                           | 
Trusted            | Code(S Impl Signat Body(S      |     pub open spec fn wf(self, c: OSConstants) -> bool {
Trusted            | Code(Spec Impl Body(Spec       |         &&& forall|id: nat| #[trigger] c.valid_ULT(id) <==> c.ULT2core.contains_key(id)
Trusted            | Code(Spec Impl Body(Spec       |         &&& forall|id: nat|
Trusted            | Code(Spec Impl Body(Spec       |             c.valid_ULT(id) ==> #[trigger] hardware::valid_core(c.hw, c.ULT2core.index(id))
Trusted            | Code(Spec Impl Body(Spec       |         &&& forall|core: Core|
Trusted            | Code(Spec Impl Body(Spec       |             hardware::valid_core(c.hw, core) <==> #[trigger] self.core_states.contains_key(core)
Trusted            | Code(Spec Impl Body(Spec       |         &&& forall|core1: Core, core2: Core|
Trusted            | Code(Spec Impl Body(Spec       |             (hardware::valid_core(c.hw, core1) && #[trigger] self.core_states[core1].holds_lock()
Trusted            | Code(Spec Impl Body(Spec       |                 && #[trigger] hardware::valid_core(c.hw, core2)
Trusted            | Code(Spec Impl Body(Spec       |                 && self.core_states[core2].holds_lock()) ==> core1 === core2
Trusted            | Code(Spec Impl Body(Spec       |     }
                   | Impl                           | 
Spec               | Code(S Impl Signat Body(S      |     pub open spec fn basic_inv(self, c: OSConstants) -> bool { // $line_count$Spec${$
Spec               | Code(Spec Impl Body(Spec       |         &&& self.wf(c)
Spec               | Code(Spec Impl Body(Spec       |         &&& self.valid_ids(c)
Comment            | Comment                        |         //&&& self.inflight_pte_above_zero_pte_result_consistant(c)
Spec               | Code(Spec Impl Body(Spec       |         &&& self.successful_unmaps(c)
Comment            | Comment                        |         //&&& self.tlb_inv(c)
Spec               | Code(Spec Impl Body(Spec       |     }
Comment            | Comment                        |     // $line_count$}$
                   | Impl                           | 
Spec               | Code(S Impl Signat Body(S      |     pub open spec fn inv(self, c: OSConstants) -> bool { // $line_count$Spec${$
Spec               | Code(Spec Impl Body(Spec       |         &&& self.basic_inv(c)
Comment            | Comment                        |         //&&& self.tlb_inv(c)
Comment            | Comment                        |         //&&& self.overlapping_inv(c)
Spec               | Code(Spec Impl Body(Spec       |         &&& self.overlapping_vmem_inv(c)
Spec               | Code(Spec Impl Body(Spec       |     }
Comment            | Comment                        |     // $line_count$}$
                   | Impl                           | 
Comment            | Comment                        |     ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Comment            | Comment                        |     // Invariants about the TLB
Comment            | Comment                        |     ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Spec               | Code(S Impl Signat Body(S      |     pub open spec fn shootdown_cores_valid(self, c: OSConstants) -> bool { // $line_count$Spec${$
Spec               | Code(Spec Impl Body(Spec       |         forall|core| #[trigger]
Spec               | Code(Spec Impl Body(Spec       |             self.TLB_Shootdown.open_requests.contains(core) ==> hardware::valid_core(c.hw, core)
Spec               | Code(Spec Impl Body(Spec       |     }
                   | Impl                           | 
Spec               | Code(S Impl Signat Body(S      |     pub open spec fn successful_IPI(self, c: OSConstants) -> bool { // $line_count$Spec${$
Spec               | Code(Spec Impl Body(Spec       |         forall|dispatcher: Core|
Spec               | Code(Spec Impl Body(Spec       |             {
Spec               | Code(Spec Impl Body(Spec       |                 hardware::valid_core(c.hw, dispatcher) ==> match self.core_states[dispatcher] {
Spec               | Code(Spec Impl Body(Spec       |                     CoreState::UnmapShootdownWaiting { vaddr, .. } => {
Spec               | Code(Spec Impl Body(Spec       |                         forall|handler: Core|
Spec               | Code(Spec Impl Body(Spec       |                             !(#[trigger] self.TLB_Shootdown.open_requests.contains(handler))
Spec               | Code(Spec Impl Body(Spec       |                                 ==> !self.hw.NUMAs[handler.NUMA_id].cores[handler.core_id].tlb.dom().contains(
Spec               | Code(Spec Impl Body(Spec       |                             vaddr)
Spec               | Code(Spec Impl Body(Spec       |                     },
Spec               | Code(Spec Impl Body(Spec       |                     _ => true,
Spec               | Code(Spec Impl Body(Spec       |                 }
Spec               | Code(Spec Impl Body(Spec       |             }
Spec               | Code(Spec Impl Body(Spec       |     }
                   | Impl                           | 
Comment            | Comment                        |     //returns set with the vaddr that is currently unmapped.
Spec               | Code(S Impl Signat Body(S      |     pub open spec fn Unmap_vaddr(self) -> Set<nat> {
Spec               | Code(Spec Impl Body(Spec       |         Set::new(
Spec               | Code(Spec Impl Body(Spec       |             |v_address: nat|
Spec               | Code(Spec Impl Body(Spec       |                 {
Spec               | Code(Spec Impl Body(Spec       |                     &&& exists|core: Core|
Spec               | Code(Spec Impl Body(Spec       |                         self.core_states.dom().contains(core) && match self.core_states[core] {
Spec               | Code(Spec Impl Body(Spec       |                             CoreState::UnmapOpDone { vaddr, result, .. }
Spec               | Code(Spec Impl Body(Spec       |                             | CoreState::UnmapShootdownWaiting { vaddr, result, .. } => {
Spec               | Code(Spec Impl Body(Spec       |                                 (result is Ok) && (vaddr === v_address)
Spec               | Code(Spec Impl Body(Spec       |                             },
Spec               | Code(Spec Impl Body(Spec       |                             _ => false,
Spec               | Code(Spec Impl Body(Spec       |                         }
Spec               | Code(Spec Impl Body(Spec       |                 },
Spec               | Code(Spec Impl Body(Spec       |         )
Spec               | Code(Spec Impl Body(Spec       |     }
                   | Impl                           | 
Spec               | Code(S Impl Signat Body(S      |     pub open spec fn TLB_dom_subset_of_pt_and_inflight_unmap_vaddr(self, c: OSConstants) -> bool {
Spec               | Code(Spec Impl Body(Spec       |         forall|core: Core|
Spec               | Code(Spec Impl Body(Spec       |             {
Spec               | Code(Spec Impl Body(Spec       |                 #[trigger] hardware::valid_core(c.hw, core)
Spec               | Code(Spec Impl Body(Spec       |                     ==> self.hw.NUMAs[core.NUMA_id].cores[core.core_id].tlb.dom().subset_of(
Spec               | Code(Spec Impl Body(Spec       |                     self.interp_pt_mem().dom().union(self.Unmap_vaddr()),
Spec               | Code(Spec Impl Body(Spec       |                 )
Spec               | Code(Spec Impl Body(Spec       |             }
Spec               | Code(Spec Impl Body(Spec       |     }
                   | Impl                           | 
Comment            | Comment                        |     // pub open spec fn shootdown_exists(self, c: OSConstants) -> bool {
Comment            | Comment                        |     //     !(self.TLB_Shootdown.open_requests === Set::<Core>::empty()) ==> exists|core|
Comment            | Comment                        |     //         hardware::valid_core(c.hw, core)
Comment            | Comment                        |     //             && self.core_states[core] matches (CoreState::UnmapShootdownWaiting { vaddr, .. })
Comment            | Comment                        |     // }
                   | Impl                           | 
Spec               | Code(S Impl Signat Body(S      |     pub open spec fn tlb_inv(self, c: OSConstants) -> bool {
Spec               | Code(Spec Impl Body(Spec       |         &&& self.shootdown_cores_valid(c)
Spec               | Code(Spec Impl Body(Spec       |         &&& self.successful_IPI(c)
Spec               | Code(Spec Impl Body(Spec       |         &&& self.TLB_dom_subset_of_pt_and_inflight_unmap_vaddr(c)
Trusted            | Code(Spec Impl Body(Spec       |     } // $line_count$}$
                   | Impl                           | 
Comment            | Comment                        |     ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Comment            | Comment                        |     // Invariants about overlapping
Comment            | Comment                        |     ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Spec               | Impl Signature(Spec            |     pub open spec fn set_core_idle(self, c: OSConstants, core: Core) -> OSVariables // $line_count$Spec${$
Spec               | Impl Signature(Spec            |         recommends
Spec               | Impl Signature(Spec            |             hardware::valid_core(c.hw, core),
Spec               | Code(Spec Impl Body(Spec       |     {
Spec               | Code(Spec Impl Body(Spec       |         OSVariables {
Spec               | Code(Spec Impl Body(Spec       |             hw: self.hw,
Spec               | Code(Spec Impl Body(Spec       |             core_states: self.core_states.insert(core, CoreState::Idle),
Spec               | Code(Spec Impl Body(Spec       |             TLB_Shootdown: self.TLB_Shootdown,
Spec               | Code(Spec Impl Body(Spec       |             sound: self.sound,
Spec               | Code(Spec Impl Body(Spec       |         }
Spec               | Code(Spec Impl Body(Spec       |     }
                   | Impl                           | 
Spec               | Code(S Impl Signat Body(S      |     pub open spec fn inflight_map_no_overlap_inflight_vmem(self, c: OSConstants) -> bool {
Spec               | Code(Spec Impl Body(Spec       |         forall|core1: Core, core2: Core|
Spec               | Code(Spec Impl Body(Spec       |             (hardware::valid_core(c.hw, core1) && hardware::valid_core(c.hw, core2)
Spec               | Code(Spec Impl Body(Spec       |                 && !self.core_states[core1].is_idle() && !self.core_states[core2].is_idle()
Spec               | Code(Spec Impl Body(Spec       |                 && overlap(
Spec               | Code(Spec Impl Body(Spec       |                 MemRegion {
Spec               | Code(Spec Impl Body(Spec       |                     base: self.core_states[core1].vaddr(),
Spec               | Code(Spec Impl Body(Spec       |                     size: self.core_states[core1].vmem_pte_size(self.interp_pt_mem()),
Spec               | Code(Spec Impl Body(Spec       |                 },
Spec               | Code(Spec Impl Body(Spec       |                 MemRegion {
Spec               | Code(Spec Impl Body(Spec       |                     base: self.core_states[core2].vaddr(),
Spec               | Code(Spec Impl Body(Spec       |                     size: self.core_states[core2].vmem_pte_size(self.interp_pt_mem()),
Spec               | Code(Spec Impl Body(Spec       |                 },
Spec               | Code(Spec Impl Body(Spec       |             )) ==> core1 === core2
Spec               | Code(Spec Impl Body(Spec       |     }
                   | Impl                           | 
Spec               | Code(S Impl Signat Body(S      |     pub open spec fn existing_map_no_overlap_existing_vmem(self, c: OSConstants) -> bool {
Spec               | Code(Spec Impl Body(Spec       |         forall|vaddr| #[trigger]
Spec               | Code(Spec Impl Body(Spec       |             self.interp_pt_mem().dom().contains(vaddr)
Spec               | Code(Spec Impl Body(Spec       |                 ==> !candidate_mapping_overlaps_existing_vmem(
Spec               | Code(Spec Impl Body(Spec       |                 self.interp_pt_mem().remove(vaddr),
Spec               | Code(Spec Impl Body(Spec       |                 vaddr,
Spec               | Code(Spec Impl Body(Spec       |                 self.interp_pt_mem()[vaddr],
Spec               | Code(Spec Impl Body(Spec       |             )
Spec               | Code(Spec Impl Body(Spec       |     }
                   | Impl                           | 
Spec               | Code(S Impl Signat Body(S      |     pub open spec fn overlapping_vmem_inv(self, c: OSConstants) -> bool {
Spec               | Code(Spec Impl Body(Spec       |         self.sound ==> {
Spec               | Code(Spec Impl Body(Spec       |             &&& self.inflight_map_no_overlap_inflight_vmem(c)
Spec               | Code(Spec Impl Body(Spec       |             &&& self.existing_map_no_overlap_existing_vmem(c)
Spec               | Code(Spec Impl Body(Spec       |         }
Spec               | Code(Spec Impl Body(Spec       |     }
Comment            | Comment                        |     // $line_count$}$
                   | Impl                           | 
Comment            | Comment                        |     ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Comment            | Comment                        |     // Interpretation functions
Comment            | Comment                        |     ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Spec               | Code(S Impl Signat Body(S      |     pub open spec fn pt_variables(self, core: Core) -> spec_pt::PageTableVariables { // $line_count$Spec${$
Spec               | Code(Spec Impl Body(Spec       |         spec_pt::PageTableVariables { pt_mem: self.hw.global_pt }
Spec               | Code(Spec Impl Body(Spec       |     }
                   | Impl                           | 
Spec               | Code(S Impl Signat Body(S      |     pub open spec fn interp_pt_mem(self) -> Map<nat, PageTableEntry> {
Spec               | Code(Spec Impl Body(Spec       |         hardware::interp_pt_mem(self.hw.global_pt)
Spec               | Code(Spec Impl Body(Spec       |     }
                   | Impl                           | 
Spec               | Code(S Impl Signat Body(S      |     pub open spec fn inflight_unmap_vaddr(self) -> Set<nat> {
Spec               | Code(Spec Impl Body(Spec       |         Set::new(
Spec               | Code(Spec Impl Body(Spec       |             |v_address: nat|
Spec               | Code(Spec Impl Body(Spec       |                 {
Spec               | Code(Spec Impl Body(Spec       |                     &&& self.interp_pt_mem().dom().contains(v_address)
Spec               | Code(Spec Impl Body(Spec       |                     &&& exists|core: Core|
Spec               | Code(Spec Impl Body(Spec       |                         self.core_states.dom().contains(core) && match self.core_states[core] {
Spec               | Code(Spec Impl Body(Spec       |                             CoreState::UnmapWaiting { ULT_id, vaddr }
Spec               | Code(Spec Impl Body(Spec       |                             | CoreState::UnmapOpExecuting { ULT_id, vaddr, .. }
Spec               | Code(Spec Impl Body(Spec       |                             | CoreState::UnmapOpDone { ULT_id, vaddr, .. }
Spec               | Code(Spec Impl Body(Spec       |                             | CoreState::UnmapShootdownWaiting { ULT_id, vaddr, .. } => {
Spec               | Code(Spec Impl Body(Spec       |                                 vaddr === v_address
Spec               | Code(Spec Impl Body(Spec       |                             },
Spec               | Code(Spec Impl Body(Spec       |                             _ => false,
Spec               | Code(Spec Impl Body(Spec       |                         }
Spec               | Code(Spec Impl Body(Spec       |                 },
Spec               | Code(Spec Impl Body(Spec       |         )
Spec               | Code(Spec Impl Body(Spec       |     }
                   | Impl                           | 
Spec               | Code(S Impl Signat Body(S      |     pub open spec fn effective_mappings(self) -> Map<nat, PageTableEntry> {
Spec               | Code(Spec Impl Body(Spec       |         let effective_mappings = self.interp_pt_mem();
Spec               | Code(Spec Impl Body(Spec       |         let unmap_dom = self.inflight_unmap_vaddr();
Spec               | Code(Spec Impl Body(Spec       |         Map::new(
Spec               | Code(Spec Impl Body(Spec       |             |vmem_idx: nat|
Spec               | Code(Spec Impl Body(Spec       |                 effective_mappings.dom().contains(vmem_idx) && !unmap_dom.contains(vmem_idx),
Spec               | Code(Spec Impl Body(Spec       |             |vmem_idx: nat| effective_mappings[vmem_idx],
Spec               | Code(Spec Impl Body(Spec       |         )
Spec               | Code(Spec Impl Body(Spec       |     }
                   | Impl                           | 
Spec               | Code(S Impl Signat Body(S      |     pub open spec fn interp_vmem(self, c: OSConstants) -> Map<nat, nat> {
Spec               | Code(Spec Impl Body(Spec       |         let phys_mem_size = c.interp().phys_mem_size;
Spec               | Code(Spec Impl Body(Spec       |         let mappings: Map<nat, PageTableEntry> = self.effective_mappings();
Spec               | Code(Spec Impl Body(Spec       |         Map::new(
Spec               | Code(Spec Impl Body(Spec       |             |vmem_idx: nat|
Spec               | Code(Spec Impl Body(Spec       |                 hlspec::mem_domain_from_mappings_contains(phys_mem_size, vmem_idx, mappings),
Spec               | Code(Spec Impl Body(Spec       |             |vmem_idx: nat|
Spec               | Code(Spec Impl Body(Spec       |                 {
Spec               | Code(Spec Impl Body(Spec       |                     let vaddr = vmem_idx * WORD_SIZE as nat;
Spec               | Code(Spec Impl Body(Spec       |                     let (base, pte): (nat, PageTableEntry) = choose|base: nat, pte: PageTableEntry|
Spec               | Code(Spec Impl Body(Spec       |                         #![auto]
Spec               | Code(Spec Impl Body(Spec       |                         mappings.contains_pair(base, pte) && between(
Spec               | Code(Spec Impl Body(Spec       |                             vaddr,
Spec               | Code(Spec Impl Body(Spec       |                             base,
Spec               | Code(Spec Impl Body(Spec       |                             base + pte.frame.size,
Spec               | Code(Spec Impl Body(Spec       |                         );
Spec               | Code(Spec Impl Body(Spec       |                     let paddr = (pte.frame.base + (vaddr - base)) as nat;
Spec               | Code(Spec Impl Body(Spec       |                     let pmem_idx = mem::word_index_spec(paddr);
Spec               | Code(Spec Impl Body(Spec       |                     self.hw.mem[pmem_idx as int]
Spec               | Code(Spec Impl Body(Spec       |                 },
Spec               | Code(Spec Impl Body(Spec       |         )
Spec               | Code(Spec Impl Body(Spec       |     }
                   | Impl                           | 
Spec               | Impl Signature(Spec            |     pub open spec fn interp_thread_state(self, c: OSConstants) -> Map<
Spec               | Impl Signature(Spec            |         nat,
Spec               | Impl Signature(Spec            |         hlspec::AbstractArguments,
Spec               | Code(S Impl Signat Body(S      |     > {
Spec               | Code(Spec Impl Body(Spec       |         Map::new(
Spec               | Code(Spec Impl Body(Spec       |             |ult_id: nat| c.valid_ULT(ult_id),
Spec               | Code(Spec Impl Body(Spec       |             |ult_id: nat|
Spec               | Code(Spec Impl Body(Spec       |                 {
Spec               | Code(Spec Impl Body(Spec       |                     match self.core_states[c.ULT2core[ult_id]] {
Spec               | Code(Spec Impl Body(Spec       |                         CoreState::MapWaiting { ULT_id, vaddr, pte }
Spec               | Code(Spec Impl Body(Spec       |                         | CoreState::MapExecuting { ULT_id, vaddr, pte } => {
Spec               | Code(Spec Impl Body(Spec       |                             if ULT_id == ult_id {
Spec               | Code(Spec Impl Body(Spec       |                                 hlspec::AbstractArguments::Map { vaddr, pte }
Spec               | Code(Spec Impl Body(Spec       |                             } else {
Spec               | Code(Spec Impl Body(Spec       |                                 hlspec::AbstractArguments::Empty
Spec               | Code(Spec Impl Body(Spec       |                             }
Spec               | Code(Spec Impl Body(Spec       |                         },
Spec               | Code(Spec Impl Body(Spec       |                         CoreState::UnmapWaiting { ULT_id, vaddr } => {
Spec               | Code(Spec Impl Body(Spec       |                             let pte = if self.interp_pt_mem().dom().contains(vaddr) {
Spec               | Code(Spec Impl Body(Spec       |                                 Some(self.interp_pt_mem().index(vaddr))
Spec               | Code(Spec Impl Body(Spec       |                             } else {
Spec               | Code(Spec Impl Body(Spec       |                                 None
Spec               | Code(Spec Impl Body(Spec       |                             };
Spec               | Code(Spec Impl Body(Spec       |                             if ULT_id == ult_id {
Spec               | Code(Spec Impl Body(Spec       |                                 hlspec::AbstractArguments::Unmap { vaddr, pte }
Spec               | Code(Spec Impl Body(Spec       |                             } else {
Spec               | Code(Spec Impl Body(Spec       |                                 hlspec::AbstractArguments::Empty
Spec               | Code(Spec Impl Body(Spec       |                             }
Spec               | Code(Spec Impl Body(Spec       |                         },
Spec               | Code(Spec Impl Body(Spec       |                         CoreState::UnmapOpExecuting { ULT_id, vaddr, result }
Spec               | Code(Spec Impl Body(Spec       |                         | CoreState::UnmapOpDone { ULT_id, vaddr, result }
Spec               | Code(Spec Impl Body(Spec       |                         | CoreState::UnmapShootdownWaiting { ULT_id, vaddr, result } => {
Spec               | Code(Spec Impl Body(Spec       |                             if ULT_id == ult_id {
Spec               | Code(Spec Impl Body(Spec       |                                 hlspec::AbstractArguments::Unmap { vaddr, pte:
Spec               | Code(Spec Impl Body(Spec       |                                     match result {
Spec               | Code(Spec Impl Body(Spec       |                                         Ok(pte) => Some(pte),
Spec               | Code(Spec Impl Body(Spec       |                                         Err(_) => None,
Spec               | Code(Spec Impl Body(Spec       |                                     }
Spec               | Code(Spec Impl Body(Spec       |                                 }
Spec               | Code(Spec Impl Body(Spec       |                             } else {
Spec               | Code(Spec Impl Body(Spec       |                                 hlspec::AbstractArguments::Empty
Spec               | Code(Spec Impl Body(Spec       |                             }
Spec               | Code(Spec Impl Body(Spec       |                         },
Spec               | Code(Spec Impl Body(Spec       |                         CoreState::Idle => hlspec::AbstractArguments::Empty,
Spec               | Code(Spec Impl Body(Spec       |                     }
Spec               | Code(Spec Impl Body(Spec       |                 },
Spec               | Code(Spec Impl Body(Spec       |         )
Spec               | Code(Spec Impl Body(Spec       |     }
                   | Impl                           | 
Spec               | Code(S Impl Signat Body(S      |     pub open spec fn interp(self, c: OSConstants) -> hlspec::AbstractVariables {
Spec               | Code(Spec Impl Body(Spec       |         let mappings: Map<nat, PageTableEntry> = self.effective_mappings();
Spec               | Code(Spec Impl Body(Spec       |         let mem: Map<nat, nat> = self.interp_vmem(c);
Spec               | Code(Spec Impl Body(Spec       |         let thread_state: Map<nat, hlspec::AbstractArguments> = self.interp_thread_state(c);
Spec               | Code(Spec Impl Body(Spec       |         let sound: bool = self.sound;
Spec               | Code(Spec Impl Body(Spec       |         hlspec::AbstractVariables { mem, mappings, thread_state, sound }
Spec               | Code(Spec Impl Body(Spec       |     }
Comment            | Comment                        |     // $line_count$}$
                   | Impl                           | }
                   |                                | 
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Comment            | Comment                        | // Overlapping inflight memory helper functions for HL-soundness
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Trusted            | Signature(Spec)                | pub open spec fn candidate_mapping_overlaps_inflight_pmem(
Trusted            | Signature(Spec)                |     pt: Map<nat, PageTableEntry>,
Trusted            | Signature(Spec)                |     inflightargs: Set<CoreState>,
Trusted            | Signature(Spec)                |     candidate: PageTableEntry,
Trusted            | Code(Spec Signature Body(Spec  | ) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     exists|b: CoreState|
Trusted            | Code(Spec) Body(Spec)          |         #![auto]
Trusted            | Code(Spec) Body(Spec)          |         {
Trusted            | Code(Spec) Body(Spec)          |             &&& inflightargs.contains(b)
Trusted            | Code(Spec) Body(Spec)          |             &&& match b {
Trusted            | Code(Spec) Body(Spec)          |                 CoreState::MapWaiting { vaddr, pte, .. }
Trusted            | Code(Spec) Body(Spec)          |                 | CoreState::MapExecuting { vaddr, pte, .. } => {
Trusted            | Code(Spec) Body(Spec)          |                     overlap(candidate.frame, pte.frame)
Trusted            | Code(Spec) Body(Spec)          |                 },
Trusted            | Code(Spec) Body(Spec)          |                 CoreState::UnmapWaiting { ULT_id, vaddr } => {
Trusted            | Code(Spec) Body(Spec)          |                     &&& pt.dom().contains(vaddr)
Trusted            | Code(Spec) Body(Spec)          |                     &&& overlap(candidate.frame, pt.index(vaddr).frame)
Trusted            | Code(Spec) Body(Spec)          |                 },
Trusted            | Code(Spec) Body(Spec)          |                 CoreState::UnmapOpExecuting { ULT_id, vaddr, result, .. }
Trusted            | Code(Spec) Body(Spec)          |                 | CoreState::UnmapOpDone { ULT_id, vaddr, result, .. }
Trusted            | Code(Spec) Body(Spec)          |                 | CoreState::UnmapShootdownWaiting { ULT_id, vaddr, result, .. } => {
Trusted            | Code(Spec) Body(Spec)          |                     &&& result is Ok
Trusted            | Code(Spec) Body(Spec)          |                     &&& overlap(candidate.frame, result.get_Ok_0().frame)
Trusted            | Code(Spec) Body(Spec)          |                 },
Trusted            | Code(Spec) Body(Spec)          |                 CoreState::Idle => false,
Trusted            | Code(Spec) Body(Spec)          |             }
Trusted            | Code(Spec) Body(Spec)          |         }
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Signature(Spec)                | pub open spec fn candidate_mapping_overlaps_inflight_vmem(
Trusted            | Signature(Spec)                |     pt: Map<nat, PageTableEntry>,
Trusted            | Signature(Spec)                |     inflightargs: Set<CoreState>,
Trusted            | Signature(Spec)                |     base: nat,
Trusted            | Signature(Spec)                |     candidate_size: nat,
Trusted            | Code(Spec Signature Body(Spec  | ) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     exists|b: CoreState|
Trusted            | Code(Spec) Body(Spec)          |         #![auto]
Trusted            | Code(Spec) Body(Spec)          |         {
Trusted            | Code(Spec) Body(Spec)          |             &&& inflightargs.contains(b)
Trusted            | Code(Spec) Body(Spec)          |             &&& match b {
Trusted            | Code(Spec) Body(Spec)          |                 CoreState::MapWaiting { vaddr, pte, .. }
Trusted            | Code(Spec) Body(Spec)          |                 | CoreState::MapExecuting { vaddr, pte, .. } => {
Trusted            | Code(Spec) Body(Spec)          |                     overlap(
Trusted            | Code(Spec) Body(Spec)          |                         MemRegion { base: vaddr, size: pte.frame.size },
Trusted            | Code(Spec) Body(Spec)          |                         MemRegion { base: base, size: candidate_size },
Trusted            | Code(Spec) Body(Spec)          |                     )
Trusted            | Code(Spec) Body(Spec)          |                 },
Trusted            | Code(Spec) Body(Spec)          |                 CoreState::UnmapWaiting { vaddr, .. } => {
Trusted            | Code(Spec) Body(Spec)          |                     let size = if pt.dom().contains(vaddr) {
Trusted            | Code(Spec) Body(Spec)          |                         pt.index(vaddr).frame.size
Trusted            | Code(Spec) Body(Spec)          |                     } else {
Trusted            | Code(Spec) Body(Spec)          |                         0
Trusted            | Code(Spec) Body(Spec)          |                     };
Trusted            | Code(Spec) Body(Spec)          |                     overlap(
Trusted            | Code(Spec) Body(Spec)          |                         MemRegion { base: vaddr, size: size },
Trusted            | Code(Spec) Body(Spec)          |                         MemRegion { base: base, size: candidate_size },
Trusted            | Code(Spec) Body(Spec)          |                     )
Trusted            | Code(Spec) Body(Spec)          |                 },
Trusted            | Code(Spec) Body(Spec)          |                 CoreState::UnmapOpExecuting { vaddr, result, .. }
Trusted            | Code(Spec) Body(Spec)          |                 | CoreState::UnmapOpDone { vaddr, result, .. }
Trusted            | Code(Spec) Body(Spec)          |                 | CoreState::UnmapShootdownWaiting { vaddr, result, .. } => {
Trusted            | Code(Spec) Body(Spec)          |                     let size = if result is Ok {
Trusted            | Code(Spec) Body(Spec)          |                         result.get_Ok_0().frame.size
Trusted            | Code(Spec) Body(Spec)          |                     } else {
Trusted            | Code(Spec) Body(Spec)          |                         0
Trusted            | Code(Spec) Body(Spec)          |                     };
Trusted            | Code(Spec) Body(Spec)          |                     overlap(
Trusted            | Code(Spec) Body(Spec)          |                         MemRegion { base: vaddr, size: size },
Trusted            | Code(Spec) Body(Spec)          |                         MemRegion { base: base, size: candidate_size },
Trusted            | Code(Spec) Body(Spec)          |                     )
Trusted            | Code(Spec) Body(Spec)          |                 },
Trusted            | Code(Spec) Body(Spec)          |                 _ => { false },
Trusted            | Code(Spec) Body(Spec)          |             }
Trusted            | Code(Spec) Body(Spec)          |         }
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Comment            | Comment                        | // HW-Statemachine steps
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Trusted            | Signature(Spec)                | pub open spec fn step_HW(
Trusted            | Signature(Spec)                |     c: OSConstants,
Trusted            | Signature(Spec)                |     s1: OSVariables,
Trusted            | Signature(Spec)                |     s2: OSVariables,
Trusted            | Signature(Spec)                |     ULT_id: nat,
Trusted            | Signature(Spec)                |     system_step: hardware::HWStep,
Trusted            | Code(Spec Signature Body(Spec  | ) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     let core = c.ULT2core.index(ULT_id);
Comment            | Comment                        |     //enabling conditions
Trusted            | Code(Spec) Body(Spec)          |     &&& c.valid_ULT(ULT_id)
Trusted            | Code(Spec) Body(Spec)          |     &&& s1.core_states[core] is Idle || system_step is TLBFill || system_step is TLBEvict
Trusted            | Code(Spec) Body(Spec)          |     &&& !(system_step is PTMemOp)
Comment            | Comment                        |     //hw/spec_pt-statemachine steps
Trusted            | Code(Spec) Body(Spec)          |     &&& hardware::next_step(c.hw, s1.hw, s2.hw, system_step)
Trusted            | Code(Spec) Body(Spec)          |     &&& spec_pt::step_Stutter(
Trusted            | Code(Spec) Body(Spec)          |         s1.pt_variables(core),
Trusted            | Code(Spec) Body(Spec)          |         s2.pt_variables(core),
Trusted            | Code(Spec) Body(Spec)          |     )
Comment            | Comment                        |     //new state
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.core_states == s1.core_states
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.TLB_Shootdown == s1.TLB_Shootdown
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.sound == s1.sound
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Comment            | Comment                        | // Map
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Trusted            | Signature(Spec)                | pub open spec fn step_Map_sound(
Trusted            | Signature(Spec)                |     pt: Map<nat, PageTableEntry>,
Trusted            | Signature(Spec)                |     inflightargs: Set<CoreState>,
Trusted            | Signature(Spec)                |     vaddr: nat,
Trusted            | Signature(Spec)                |     pte: PageTableEntry,
Trusted            | Code(Spec Signature Body(Spec  | ) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     &&& !candidate_mapping_overlaps_existing_pmem(pt, pte)
Trusted            | Code(Spec) Body(Spec)          |     &&& !candidate_mapping_overlaps_inflight_pmem(pt, inflightargs, pte)
Trusted            | Code(Spec) Body(Spec)          |     &&& !candidate_mapping_overlaps_inflight_vmem(pt, inflightargs, vaddr, pte.frame.size)
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Signature(Spec)                | pub open spec fn step_Map_enabled(
Trusted            | Signature(Spec)                |     pt_mem: mem::PageTableMemory,
Trusted            | Signature(Spec)                |     vaddr: nat,
Trusted            | Signature(Spec)                |     pte: PageTableEntry,
Trusted            | Code(Spec Signature Body(Spec  | ) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     &&& aligned(vaddr, pte.frame.size)
Trusted            | Code(Spec) Body(Spec)          |     &&& aligned(pte.frame.base, pte.frame.size)
Trusted            | Code(Spec) Body(Spec)          |     &&& pte.frame.base <= MAX_PHYADDR
Trusted            | Code(Spec) Body(Spec)          |     &&& candidate_mapping_in_bounds(vaddr, pte)
Trusted            | Code(Spec) Body(Spec)          |     &&& {  // The size of the frame must be the entry_size of a layer that supports page mappings
Trusted            | Code(Spec) Body(Spec)          |         ||| pte.frame.size == L3_ENTRY_SIZE
Trusted            | Code(Spec) Body(Spec)          |         ||| pte.frame.size == L2_ENTRY_SIZE
Trusted            | Code(Spec) Body(Spec)          |         ||| pte.frame.size == L1_ENTRY_SIZE
Trusted            | Code(Spec) Body(Spec)          |     }
Trusted            | Code(Spec) Body(Spec)          |     &&& pt_mem.alloc_available_pages() >= 3
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Signature(Spec)                | pub open spec fn step_Map_Start(
Trusted            | Signature(Spec)                |     c: OSConstants,
Trusted            | Signature(Spec)                |     s1: OSVariables,
Trusted            | Signature(Spec)                |     s2: OSVariables,
Trusted            | Signature(Spec)                |     ULT_id: nat,
Trusted            | Signature(Spec)                |     vaddr: nat,
Trusted            | Signature(Spec)                |     pte: PageTableEntry,
Trusted            | Code(Spec Signature Body(Spec  | ) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     let core = c.ULT2core.index(ULT_id);
Comment            | Comment                        |     //enabling conditions
Trusted            | Code(Spec) Body(Spec)          |     &&& c.valid_ULT(ULT_id)
Trusted            | Code(Spec) Body(Spec)          |     &&& s1.core_states[core] is Idle
Trusted            | Code(Spec) Body(Spec)          |     &&& step_Map_enabled(
Trusted            | Code(Spec) Body(Spec)          |         s1.hw.global_pt,
Trusted            | Code(Spec) Body(Spec)          |         vaddr,
Trusted            | Code(Spec) Body(Spec)          |         pte,
Trusted            | Code(Spec) Body(Spec)          |     )
Comment            | Comment                        |     //hw/spec_pt-statemachine steps
Trusted            | Code(Spec) Body(Spec)          |     &&& hardware::step_PTMemOp(c.hw, s1.hw, s2.hw)
Trusted            | Code(Spec) Body(Spec)          |     &&& spec_pt::step_Stutter(
Trusted            | Code(Spec) Body(Spec)          |         s1.pt_variables(core),
Trusted            | Code(Spec) Body(Spec)          |         s2.pt_variables(core),
Trusted            | Code(Spec) Body(Spec)          |     )
Comment            | Comment                        |     //new state
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.core_states == s1.core_states.insert(core, CoreState::MapWaiting { ULT_id, vaddr, pte })
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.TLB_Shootdown == s1.TLB_Shootdown
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.sound == s1.sound && step_Map_sound(
Trusted            | Code(Spec) Body(Spec)          |         s1.interp_pt_mem(),
Comment            | Comment                        |         //TODO reallllllly think about this
Trusted            | Code(Spec) Body(Spec)          |         s1.core_states.values(),
Trusted            | Code(Spec) Body(Spec)          |         vaddr,
Trusted            | Code(Spec) Body(Spec)          |         pte,
Trusted            | Code(Spec) Body(Spec)          |     )
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Signature(Spec)                | pub open spec fn step_Map_op_Start(
Trusted            | Signature(Spec)                |     c: OSConstants,
Trusted            | Signature(Spec)                |     s1: OSVariables,
Trusted            | Signature(Spec)                |     s2: OSVariables,
Trusted            | Signature(Spec)                |     core: Core,
Trusted            | Code(Spec Signature Body(Spec  | ) -> bool {
Comment            | Comment                        |     //enabling conditions
Trusted            | Code(Spec) Body(Spec)          |     &&& hardware::valid_core(c.hw, core)
Trusted            | Code(Spec) Body(Spec)          |     &&& s1.core_states[core] matches CoreState::MapWaiting { ULT_id, vaddr, pte }
Trusted            | Code(Spec) Body(Spec)          |     &&& s1.kernel_lock(c) is None
Comment            | Comment                        |     //hw/spec_pt-statemachine steps
Trusted            | Code(Spec) Body(Spec)          |     &&& hardware::step_PTMemOp(c.hw, s1.hw, s2.hw)
Trusted            | Code(Spec) Body(Spec)          |     &&& spec_pt::step_Map_Start(
Trusted            | Code(Spec) Body(Spec)          |         s1.pt_variables(core),
Trusted            | Code(Spec) Body(Spec)          |         s2.pt_variables(core),
Trusted            | Code(Spec) Body(Spec)          |         vaddr,
Trusted            | Code(Spec) Body(Spec)          |         pte,
Trusted            | Code(Spec) Body(Spec)          |     )
Comment            | Comment                        |     //new state
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.core_states == s1.core_states.insert(
Trusted            | Code(Spec) Body(Spec)          |         core,
Trusted            | Code(Spec) Body(Spec)          |         CoreState::MapExecuting { ULT_id, vaddr, pte },
Trusted            | Code(Spec) Body(Spec)          |     )
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.TLB_Shootdown == s1.TLB_Shootdown
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.sound == s1.sound
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Signature(Spec)                | pub open spec fn step_Map_End(
Trusted            | Signature(Spec)                |     c: OSConstants,
Trusted            | Signature(Spec)                |     s1: OSVariables,
Trusted            | Signature(Spec)                |     s2: OSVariables,
Trusted            | Signature(Spec)                |     core: Core,
Trusted            | Signature(Spec)                |     result: Result<(), ()>,
Trusted            | Code(Spec Signature Body(Spec  | ) -> bool {
Comment            | Comment                        |     //enabling conditions
Trusted            | Code(Spec) Body(Spec)          |     &&& hardware::valid_core(c.hw, core)
Trusted            | Code(Spec) Body(Spec)          |     &&& s1.core_states[core] matches CoreState::MapExecuting {
Trusted            | Code(Spec) Body(Spec)          |         ULT_id,
Trusted            | Code(Spec) Body(Spec)          |         vaddr,
Trusted            | Code(Spec) Body(Spec)          |         pte,
Trusted            | Code(Spec) Body(Spec)          |     }
Comment            | Comment                        |     //hw/spec_pt-statemachine steps
Trusted            | Code(Spec) Body(Spec)          |     &&& hardware::step_PTMemOp(c.hw, s1.hw, s2.hw)
Trusted            | Code(Spec) Body(Spec)          |     &&& spec_pt::step_Map_End(
Trusted            | Code(Spec) Body(Spec)          |         s1.pt_variables(core),
Trusted            | Code(Spec) Body(Spec)          |         s2.pt_variables(core),
Trusted            | Code(Spec) Body(Spec)          |         vaddr,
Trusted            | Code(Spec) Body(Spec)          |         pte,
Trusted            | Code(Spec) Body(Spec)          |         result,
Trusted            | Code(Spec) Body(Spec)          |     )
Comment            | Comment                        |     //new state
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.TLB_Shootdown == s1.TLB_Shootdown
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.core_states == s1.core_states.insert(core, CoreState::Idle)
Trusted            | Code(Spec) Body(Spec)          |     &&& s1.sound == s2.sound
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Comment            | Comment                        | // Unmap
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Trusted            | Signature(Spec)                | pub open spec fn step_Unmap_sound(
Trusted            | Signature(Spec)                |     pt: Map<nat, PageTableEntry>,
Trusted            | Signature(Spec)                |     inflightargs: Set<CoreState>,
Trusted            | Signature(Spec)                |     vaddr: nat,
Trusted            | Signature(Spec)                |     pte_size: nat,
Trusted            | Code(Spec Signature Body(Spec  | ) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     !candidate_mapping_overlaps_inflight_vmem(pt, inflightargs, vaddr, pte_size)
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Code(Spec Signature Body(Spec  | pub open spec fn step_Unmap_enabled(vaddr: nat) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     &&& vaddr < x86_arch_spec.upper_vaddr(0, 0)
Trusted            | Code(Spec) Body(Spec)          |     &&& {  // The given vaddr must be aligned to some valid page size
Trusted            | Code(Spec) Body(Spec)          |         ||| aligned(vaddr, L3_ENTRY_SIZE as nat)
Trusted            | Code(Spec) Body(Spec)          |         ||| aligned(vaddr, L2_ENTRY_SIZE as nat)
Trusted            | Code(Spec) Body(Spec)          |         ||| aligned(vaddr, L1_ENTRY_SIZE as nat)
Trusted            | Code(Spec) Body(Spec)          |     }
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Signature(Spec)                | pub open spec fn step_Unmap_Start(
Trusted            | Signature(Spec)                |     c: OSConstants,
Trusted            | Signature(Spec)                |     s1: OSVariables,
Trusted            | Signature(Spec)                |     s2: OSVariables,
Trusted            | Signature(Spec)                |     ULT_id: nat,
Trusted            | Signature(Spec)                |     vaddr: nat,
Trusted            | Code(Spec Signature Body(Spec  | ) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     let pt = hardware::interp_pt_mem(s1.hw.global_pt);
Trusted            | Code(Spec) Body(Spec)          |     let core = c.ULT2core.index(ULT_id);
Trusted            | Code(Spec) Body(Spec)          |     let pte_size = if pt.contains_key(vaddr) {
Trusted            | Code(Spec) Body(Spec)          |         pt.index(vaddr).frame.size
Trusted            | Code(Spec) Body(Spec)          |     } else {
Trusted            | Code(Spec) Body(Spec)          |         0
Trusted            | Code(Spec) Body(Spec)          |     };
Comment            | Comment                        |     //enabling conditions
Trusted            | Code(Spec) Body(Spec)          |     &&& c.valid_ULT(ULT_id)
Trusted            | Code(Spec) Body(Spec)          |     &&& s1.core_states[core] is Idle
Trusted            | Code(Spec) Body(Spec)          |     &&& step_Unmap_enabled(vaddr)
Comment            | Comment                        |     //hw/spec_pt-statemachine steps
Trusted            | Code(Spec) Body(Spec)          |     &&& hardware::step_PTMemOp(c.hw, s1.hw, s2.hw)
Trusted            | Code(Spec) Body(Spec)          |     &&& spec_pt::step_Stutter(
Trusted            | Code(Spec) Body(Spec)          |         s1.pt_variables(core),
Trusted            | Code(Spec) Body(Spec)          |         s2.pt_variables(core),
Trusted            | Code(Spec) Body(Spec)          |     )
Comment            | Comment                        |     //new state
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.core_states == s1.core_states.insert(core, CoreState::UnmapWaiting { ULT_id, vaddr })
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.TLB_Shootdown == s1.TLB_Shootdown
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.sound == s1.sound && (step_Unmap_sound(
Trusted            | Code(Spec) Body(Spec)          |         hardware::interp_pt_mem(s1.hw.global_pt),
Trusted            | Code(Spec) Body(Spec)          |         s1.core_states.values(),
Trusted            | Code(Spec) Body(Spec)          |         vaddr,
Trusted            | Code(Spec) Body(Spec)          |         pte_size,
Trusted            | Code(Spec) Body(Spec)          |     ))
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Signature(Spec)                | pub open spec fn step_Unmap_Op_Start(
Trusted            | Signature(Spec)                |     c: OSConstants,
Trusted            | Signature(Spec)                |     s1: OSVariables,
Trusted            | Signature(Spec)                |     s2: OSVariables,
Trusted            | Signature(Spec)                |     core: Core,
Trusted            | Signature(Spec)                |     result: Result<(), ()>,
Trusted            | Code(Spec Signature Body(Spec  | ) -> bool {
Comment            | Comment                        |     //enabling conditions
Trusted            | Code(Spec) Body(Spec)          |     &&& hardware::valid_core(c.hw, core)
Trusted            | Code(Spec) Body(Spec)          |     &&& s1.core_states[core] matches CoreState::UnmapWaiting { ULT_id, vaddr }
Trusted            | Code(Spec) Body(Spec)          |     &&& s1.kernel_lock(c) is None
Comment            | Comment                        |     //hw/spec_pt-statemachine steps
Trusted            | Code(Spec) Body(Spec)          |     &&& hardware::step_PTMemOp(c.hw, s1.hw, s2.hw)
Trusted            | Code(Spec) Body(Spec)          |     &&& spec_pt::step_Unmap_Start(
Trusted            | Code(Spec) Body(Spec)          |         s1.pt_variables(core),
Trusted            | Code(Spec) Body(Spec)          |         s2.pt_variables(core),
Trusted            | Code(Spec) Body(Spec)          |         vaddr,
Trusted            | Code(Spec) Body(Spec)          |         result
Trusted            | Code(Spec) Body(Spec)          |     )
Comment            | Comment                        |     //new state
Trusted            | Code(Spec) Body(Spec)          |     &&& if result is Ok {
Trusted            | Code(Spec) Body(Spec)          |         s2.core_states == s1.core_states.insert(
Trusted            | Code(Spec) Body(Spec)          |             core,
Trusted            | Code(Spec) Body(Spec)          |             CoreState::UnmapOpExecuting {
Trusted            | Code(Spec) Body(Spec)          |                 ULT_id,
Trusted            | Code(Spec) Body(Spec)          |                 vaddr,
Trusted            | Code(Spec) Body(Spec)          |                 result: Ok(s1.interp_pt_mem()[vaddr]),
Trusted            | Code(Spec) Body(Spec)          |             },
Trusted            | Code(Spec) Body(Spec)          |         )
Trusted            | Code(Spec) Body(Spec)          |     } else {
Trusted            | Code(Spec) Body(Spec)          |         s2.core_states == s1.core_states.insert(
Trusted            | Code(Spec) Body(Spec)          |             core,
Trusted            | Code(Spec) Body(Spec)          |             CoreState::UnmapOpExecuting { ULT_id, vaddr, result: Err(()) },
Trusted            | Code(Spec) Body(Spec)          |         )
Trusted            | Code(Spec) Body(Spec)          |     }
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.TLB_Shootdown == s1.TLB_Shootdown
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.sound == s1.sound
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Signature(Spec)                | pub open spec fn step_Unmap_Op_End(
Trusted            | Signature(Spec)                |     c: OSConstants,
Trusted            | Signature(Spec)                |     s1: OSVariables,
Trusted            | Signature(Spec)                |     s2: OSVariables,
Trusted            | Signature(Spec)                |     core: Core,
Trusted            | Code(Spec Signature Body(Spec  | ) -> bool {
Comment            | Comment                        |     //enabling conditions
Trusted            | Code(Spec) Body(Spec)          |     &&& hardware::valid_core(c.hw, core)
Trusted            | Code(Spec) Body(Spec)          |     &&& s1.core_states[core] matches CoreState::UnmapOpExecuting {
Trusted            | Code(Spec) Body(Spec)          |         ULT_id,
Trusted            | Code(Spec) Body(Spec)          |         vaddr,
Trusted            | Code(Spec) Body(Spec)          |         result,
Trusted            | Code(Spec) Body(Spec)          |     }
Comment            | Comment                        |     //hw/spec_pt-statemachine steps
Trusted            | Code(Spec) Body(Spec)          |     &&& hardware::step_PTMemOp(c.hw, s1.hw, s2.hw)
Trusted            | Code(Spec) Body(Spec)          |     &&& spec_pt::step_Unmap_End(
Trusted            | Code(Spec) Body(Spec)          |         s1.pt_variables(core),
Trusted            | Code(Spec) Body(Spec)          |         s2.pt_variables(core),
Trusted            | Code(Spec) Body(Spec)          |     )
Comment            | Comment                        |     //new state
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.core_states == s1.core_states.insert(
Trusted            | Code(Spec) Body(Spec)          |         core,
Trusted            | Code(Spec) Body(Spec)          |         CoreState::UnmapOpDone { ULT_id, vaddr, result },
Trusted            | Code(Spec) Body(Spec)          |     )
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.TLB_Shootdown == s1.TLB_Shootdown
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.sound == s1.sound
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Signature(Spec)                | pub open spec fn step_Unmap_Initiate_Shootdown(
Trusted            | Signature(Spec)                |     c: OSConstants,
Trusted            | Signature(Spec)                |     s1: OSVariables,
Trusted            | Signature(Spec)                |     s2: OSVariables,
Trusted            | Signature(Spec)                |     core: Core,
Trusted            | Code(Spec Signature Body(Spec  | ) -> bool {
Comment            | Comment                        |     //enabling conditions
Trusted            | Code(Spec) Body(Spec)          |     &&& hardware::valid_core(c.hw, core)
Trusted            | Code(Spec) Body(Spec)          |     &&& s1.core_states[core] matches CoreState::UnmapOpDone { ULT_id: ult_id, vaddr, result }
Trusted            | Code(Spec) Body(Spec)          |     &&& result is Ok
Comment            | Comment                        |     //hw/spec_pt-statemachine steps
Trusted            | Code(Spec) Body(Spec)          |     &&& hardware::step_PTMemOp(c.hw, s1.hw, s2.hw)
Trusted            | Code(Spec) Body(Spec)          |     &&& spec_pt::step_Stutter(
Trusted            | Code(Spec) Body(Spec)          |         s1.pt_variables(core),
Trusted            | Code(Spec) Body(Spec)          |         s2.pt_variables(core),
Trusted            | Code(Spec) Body(Spec)          |     )
Comment            | Comment                        |     //new state
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.core_states == s1.core_states.insert(
Trusted            | Code(Spec) Body(Spec)          |         core,
Trusted            | Code(Spec) Body(Spec)          |         CoreState::UnmapShootdownWaiting { ULT_id: ult_id, vaddr, result },
Trusted            | Code(Spec) Body(Spec)          |     )
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.TLB_Shootdown == ShootdownVector {
Trusted            | Code(Spec) Body(Spec)          |         vaddr: vaddr,
Trusted            | Code(Spec) Body(Spec)          |         open_requests: Set::new(|core: Core| hardware::valid_core(c.hw, core)),
Trusted            | Code(Spec) Body(Spec)          |     }
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.sound == s1.sound
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Comment            | Comment                        | // Acknowledge TLB eviction to other core (in response to shootdown IPI)
Comment            | Comment                        | //check if tlb shootdown/unmap has happend and send ACK
Trusted            | Signature(Spec)                | pub open spec fn step_Ack_Shootdown_IPI(
Trusted            | Signature(Spec)                |     c: OSConstants,
Trusted            | Signature(Spec)                |     s1: OSVariables,
Trusted            | Signature(Spec)                |     s2: OSVariables,
Trusted            | Signature(Spec)                |     core: Core,
Trusted            | Code(Spec Signature Body(Spec  | ) -> bool {
Comment            | Comment                        |     //enabling conditions
Comment            | Comment                        |     //TODO discuss: only valid cores are in the open_requests
Trusted            | Code(Spec) Body(Spec)          |     &&& s1.TLB_Shootdown.open_requests.contains(core)
Trusted            | Code(Spec) Body(Spec)          |     &&& !s1.hw.NUMAs[core.NUMA_id].cores[core.core_id].tlb.dom().contains(s1.TLB_Shootdown.vaddr)
Trusted            | Code(Spec) Body(Spec)          |     &&& !s1.interp_pt_mem().contains_key(
Trusted            | Code(Spec) Body(Spec)          |         s1.TLB_Shootdown.vaddr,
Trusted            | Code(Spec) Body(Spec)          |     )
Comment            | Comment                        |     //hw/spec_pt-statemachine steps
Trusted            | Code(Spec) Body(Spec)          |     &&& hardware::step_PTMemOp(c.hw, s1.hw, s2.hw)
Trusted            | Code(Spec) Body(Spec)          |     &&& spec_pt::step_Stutter(
Trusted            | Code(Spec) Body(Spec)          |         s1.pt_variables(core),
Trusted            | Code(Spec) Body(Spec)          |         s2.pt_variables(core),
Trusted            | Code(Spec) Body(Spec)          |     )
Comment            | Comment                        |     //new state
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.core_states == s1.core_states
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.TLB_Shootdown == ShootdownVector {
Trusted            | Code(Spec) Body(Spec)          |         vaddr: s1.TLB_Shootdown.vaddr,
Trusted            | Code(Spec) Body(Spec)          |         open_requests: s1.TLB_Shootdown.open_requests.remove(core),
Trusted            | Code(Spec) Body(Spec)          |     }
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.sound == s1.sound
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Signature(Spec)                | pub open spec fn step_Unmap_End(
Trusted            | Signature(Spec)                |     c: OSConstants,
Trusted            | Signature(Spec)                |     s1: OSVariables,
Trusted            | Signature(Spec)                |     s2: OSVariables,
Trusted            | Signature(Spec)                |     core: Core,
Trusted            | Code(Spec Signature Body(Spec  | ) -> bool {
Comment            | Comment                        |     //enabling conditions
Trusted            | Code(Spec) Body(Spec)          |     &&& hardware::valid_core(c.hw, core)
Trusted            | Code(Spec) Body(Spec)          |     &&& match s1.core_states[core] {
Trusted            | Code(Spec) Body(Spec)          |         CoreState::UnmapShootdownWaiting { result, ULT_id, .. } => {
Trusted            | Code(Spec) Body(Spec)          |             s1.TLB_Shootdown.open_requests.is_empty()
Trusted            | Code(Spec) Body(Spec)          |         },
Trusted            | Code(Spec) Body(Spec)          |         CoreState::UnmapOpDone { result, ULT_id, .. } => { result is Err },
Trusted            | Code(Spec) Body(Spec)          |         _ => false,
Trusted            | Code(Spec) Body(Spec)          |     }
Comment            | Comment                        |     //hw/spec_pt-statemachine steps
Trusted            | Code(Spec) Body(Spec)          |     &&& hardware::step_PTMemOp(c.hw, s1.hw, s2.hw)
Trusted            | Code(Spec) Body(Spec)          |     &&& spec_pt::step_Stutter(
Trusted            | Code(Spec) Body(Spec)          |         s1.pt_variables(core),
Trusted            | Code(Spec) Body(Spec)          |         s2.pt_variables(core),
Trusted            | Code(Spec) Body(Spec)          |     )
Comment            | Comment                        |     //new state
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.core_states == s1.core_states.insert(core, CoreState::Idle)
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.TLB_Shootdown == s1.TLB_Shootdown
Trusted            | Code(Spec) Body(Spec)          |     &&& s1.sound == s2.sound
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Signature(Spec)                | pub open spec fn step_View_Stutter(
Trusted            | Signature(Spec)                |     c: OSConstants,
Trusted            | Signature(Spec)                |     s1: OSVariables,
Trusted            | Signature(Spec)                |     s2: OSVariables,
Trusted            | Signature(Spec)                |     core: Core,
Trusted            | Code(Spec Signature Body(Spec  | ) -> bool {
Comment            | Comment                        |     //enabling conditions
Trusted            | Code(Spec) Body(Spec)          |     &&& hardware::valid_core(c.hw, core)
Trusted            | Code(Spec) Body(Spec)          |     &&& s1.core_states[core] is UnmapOpExecuting || s1.core_states[core] is MapExecuting
Comment            | Comment                        |     //hw/spec_pt-statemachine steps
Trusted            | Code(Spec) Body(Spec)          |     &&& hardware::step_PTMemOp(c.hw, s1.hw, s2.hw)
Trusted            | Code(Spec) Body(Spec)          |     &&& spec_pt::step_View_Stutter(
Trusted            | Code(Spec) Body(Spec)          |         s1.pt_variables(core),
Trusted            | Code(Spec) Body(Spec)          |         s2.pt_variables(core),
Trusted            | Code(Spec) Body(Spec)          |     )
Comment            | Comment                        |     //new state
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.core_states == s1.core_states
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.TLB_Shootdown == s1.TLB_Shootdown
Trusted            | Code(Spec) Body(Spec)          |     &&& s2.sound == s1.sound
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Comment            | Comment                        | // Statemachine functions
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Trusted            | DatatypeDecl Directive         | #[allow(inconsistent_fields)]
Trusted            | DatatypeDecl                   | pub enum OSStep {
Trusted            | DatatypeDecl                   |     HW { ULT_id: nat, step: hardware::HWStep },
Comment            | Comment                        |     //map
Trusted            | DatatypeDecl                   |     MapStart { ULT_id: nat, vaddr: nat, pte: PageTableEntry },
Trusted            | DatatypeDecl                   |     MapOpStart { core: Core },
Trusted            | DatatypeDecl                   |     MapEnd { core: Core, result: Result<(), ()> },
Comment            | Comment                        |     //unmap
Trusted            | DatatypeDecl                   |     UnmapStart { ULT_id: nat, vaddr: nat },
Trusted            | DatatypeDecl                   |     UnmapOpStart { core: Core, result: Result<(), ()> },
Trusted            | DatatypeDecl                   |     UnmapOpEnd { core: Core },
Trusted            | DatatypeDecl                   |     UnmapInitiateShootdown { core: Core },
Trusted            | DatatypeDecl                   |     AckShootdownIPI { core: Core },
Trusted            | DatatypeDecl                   |     UnmapEnd { core: Core },
Trusted            | DatatypeDecl                   |     ViewStutter { core: Core },
Trusted            | DatatypeDecl                   | }
                   |                                | 
Comment            | Comment                        | //TODO simplify this
                   | Impl                           | impl OSStep {
Trusted            | Code(S Impl Signat Body(S      |     pub open spec fn interp(self, c: OSConstants, s: OSVariables) -> hlspec::AbstractStep {
Trusted            | Code(Spec Impl Body(Spec       |         match self {
Trusted            | Code(Spec Impl Body(Spec       |             OSStep::HW { ULT_id, step } => match step {
Trusted            | Code(Spec Impl Body(Spec       |                 hardware::HWStep::ReadWrite { vaddr, paddr, op, pte, core } => {
Trusted            | Code(Spec Impl Body(Spec       |                     let hl_pte = if pte is None || (pte matches Some((base, _))
Trusted            | Code(Spec Impl Body(Spec       |                         && !s.effective_mappings().dom().contains(base)) {
Trusted            | Code(Spec Impl Body(Spec       |                         None
Trusted            | Code(Spec Impl Body(Spec       |                     } else {
Trusted            | Code(Spec Impl Body(Spec       |                         pte
Trusted            | Code(Spec Impl Body(Spec       |                     };
Trusted            | Code(Spec Impl Body(Spec       |                     let rwop = match (op, hl_pte) {
Trusted            | Code(Spec Impl Body(Spec       |                         (
Trusted            | Code(Spec Impl Body(Spec       |                             HWRWOp::Store { new_value, result: HWStoreResult::Ok },
Trusted            | Code(Spec Impl Body(Spec       |                             Some(_),
Trusted            | Code(Spec Impl Body(Spec       |                         ) => RWOp::Store { new_value, result: StoreResult::Ok },
Trusted            | Code(Spec Impl Body(Spec       |                         (
Trusted            | Code(Spec Impl Body(Spec       |                             HWRWOp::Store { new_value, result: HWStoreResult::Ok },
Trusted            | Code(Spec Impl Body(Spec       |                             None,
Trusted            | Code(Spec Impl Body(Spec       |                         ) => RWOp::Store { new_value, result: StoreResult::Undefined },
Trusted            | Code(Spec Impl Body(Spec       |                         (
Trusted            | Code(Spec Impl Body(Spec       |                             HWRWOp::Store { new_value, result: HWStoreResult::Pagefault },
Trusted            | Code(Spec Impl Body(Spec       |                             _,
Trusted            | Code(Spec Impl Body(Spec       |                         ) => RWOp::Store { new_value, result: StoreResult::Undefined },
Trusted            | Code(Spec Impl Body(Spec       |                         (
Trusted            | Code(Spec Impl Body(Spec       |                             HWRWOp::Load { is_exec, result: HWLoadResult::Value(v) },
Trusted            | Code(Spec Impl Body(Spec       |                             Some(_),
Trusted            | Code(Spec Impl Body(Spec       |                         ) => RWOp::Load { is_exec, result: LoadResult::Value(v) },
Trusted            | Code(Spec Impl Body(Spec       |                         (
Trusted            | Code(Spec Impl Body(Spec       |                             HWRWOp::Load { is_exec, result: HWLoadResult::Value(v) },
Trusted            | Code(Spec Impl Body(Spec       |                             None,
Trusted            | Code(Spec Impl Body(Spec       |                         ) => RWOp::Load { is_exec, result: LoadResult::Undefined },
Trusted            | Code(Spec Impl Body(Spec       |                         (
Trusted            | Code(Spec Impl Body(Spec       |                             HWRWOp::Load { is_exec, result: HWLoadResult::Pagefault },
Trusted            | Code(Spec Impl Body(Spec       |                             _,
Trusted            | Code(Spec Impl Body(Spec       |                         ) => RWOp::Load { is_exec, result: LoadResult::Undefined },
Trusted            | Code(Spec Impl Body(Spec       |                     };
Trusted            | Code(Spec Impl Body(Spec       |                     hlspec::AbstractStep::ReadWrite {
Trusted            | Code(Spec Impl Body(Spec       |                         thread_id: ULT_id,
Trusted            | Code(Spec Impl Body(Spec       |                         vaddr,
Trusted            | Code(Spec Impl Body(Spec       |                         op: rwop,
Trusted            | Code(Spec Impl Body(Spec       |                         pte: hl_pte,
Trusted            | Code(Spec Impl Body(Spec       |                     }
Trusted            | Code(Spec Impl Body(Spec       |                 },
Trusted            | Code(Spec Impl Body(Spec       |                 hardware::HWStep::PTMemOp => arbitrary(),
Trusted            | Code(Spec Impl Body(Spec       |                 hardware::HWStep::TLBFill { vaddr, pte, core } => hlspec::AbstractStep::Stutter,
Trusted            | Code(Spec Impl Body(Spec       |                 hardware::HWStep::TLBEvict { vaddr, core } => hlspec::AbstractStep::Stutter,
Trusted            | Code(Spec Impl Body(Spec       |             },
Comment            | Comment                        |             //Map steps
Trusted            | Code(Spec Impl Body(Spec       |             OSStep::MapStart { ULT_id, vaddr, pte } => {
Trusted            | Code(Spec Impl Body(Spec       |                 hlspec::AbstractStep::MapStart { thread_id: ULT_id, vaddr, pte }
Trusted            | Code(Spec Impl Body(Spec       |             },
Trusted            | Code(Spec Impl Body(Spec       |             OSStep::MapOpStart { .. } => hlspec::AbstractStep::Stutter,
Trusted            | Code(Spec Impl Body(Spec       |             OSStep::MapEnd { core, result } => {
Trusted            | Code(Spec Impl Body(Spec       |                 match s.core_states[core] {
Trusted            | Code(Spec Impl Body(Spec       |                     CoreState::MapExecuting { ULT_id, .. } => {
Trusted            | Code(Spec Impl Body(Spec       |                         hlspec::AbstractStep::MapEnd { thread_id: ULT_id, result }
Trusted            | Code(Spec Impl Body(Spec       |                     },
Trusted            | Code(Spec Impl Body(Spec       |                     _ => { arbitrary() },
Trusted            | Code(Spec Impl Body(Spec       |                 }
Trusted            | Code(Spec Impl Body(Spec       |             },
Comment            | Comment                        |             //Unmap steps
Trusted            | Code(Spec Impl Body(Spec       |             OSStep::UnmapStart { ULT_id, vaddr } => {
Trusted            | Code(Spec Impl Body(Spec       |                 hlspec::AbstractStep::UnmapStart { thread_id: ULT_id, vaddr }
Trusted            | Code(Spec Impl Body(Spec       |             },
Trusted            | Code(Spec Impl Body(Spec       |             OSStep::UnmapOpStart { .. } => hlspec::AbstractStep::Stutter,
Trusted            | Code(Spec Impl Body(Spec       |             OSStep::UnmapOpEnd { .. } => hlspec::AbstractStep::Stutter,
Trusted            | Code(Spec Impl Body(Spec       |             OSStep::UnmapInitiateShootdown { .. } => hlspec::AbstractStep::Stutter,
Trusted            | Code(Spec Impl Body(Spec       |             OSStep::AckShootdownIPI { .. } => hlspec::AbstractStep::Stutter,
Trusted            | Code(Spec Impl Body(Spec       |             OSStep::UnmapEnd { core } => {
Trusted            | Code(Spec Impl Body(Spec       |                 match s.core_states[core] {
Trusted            | Code(Spec Impl Body(Spec       |                     CoreState::UnmapShootdownWaiting { result, ULT_id, .. } => {
Trusted            | Code(Spec Impl Body(Spec       |                         hlspec::AbstractStep::UnmapEnd { thread_id: ULT_id, result: result_map_ok(result, |r| ()) }
Trusted            | Code(Spec Impl Body(Spec       |                     },
Trusted            | Code(Spec Impl Body(Spec       |                     CoreState::UnmapOpDone { result, ULT_id, .. } => {
Trusted            | Code(Spec Impl Body(Spec       |                         hlspec::AbstractStep::UnmapEnd { thread_id: ULT_id, result: result_map_ok(result, |r| ()) }
Trusted            | Code(Spec Impl Body(Spec       |                     },
Trusted            | Code(Spec Impl Body(Spec       |                     _ => arbitrary(),
Trusted            | Code(Spec Impl Body(Spec       |                 }
Trusted            | Code(Spec Impl Body(Spec       |             },
Trusted            | Code(Spec Impl Body(Spec       |             OSStep::ViewStutter { .. } => hlspec::AbstractStep::Stutter,
Trusted            | Code(Spec Impl Body(Spec       |         }
Trusted            | Code(Spec Impl Body(Spec       |     }
                   | Impl                           | }
                   |                                | 
Trusted            | Code(Spec Signature Body(Spec  | pub open spec fn next_step(c: OSConstants, s1: OSVariables, s2: OSVariables, step: OSStep) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     match step {
Trusted            | Code(Spec) Body(Spec)          |         OSStep::HW { ULT_id, step }             => step_HW(c, s1, s2, ULT_id, step),
Comment            | Comment                        |         //Map steps
Trusted            | Code(Spec) Body(Spec)          |         OSStep::MapStart { ULT_id, vaddr, pte } => step_Map_Start(c, s1, s2, ULT_id, vaddr, pte),
Trusted            | Code(Spec) Body(Spec)          |         OSStep::MapOpStart { core }             => step_Map_op_Start(c, s1, s2, core),
Trusted            | Code(Spec) Body(Spec)          |         OSStep::MapEnd { core, result }         => step_Map_End(c, s1, s2, core, result),
Comment            | Comment                        |         //Unmap steps
Trusted            | Code(Spec) Body(Spec)          |         OSStep::UnmapStart { ULT_id, vaddr }    => step_Unmap_Start(c, s1, s2, ULT_id, vaddr),
Trusted            | Code(Spec) Body(Spec)          |         OSStep::UnmapOpStart { core, result }   => step_Unmap_Op_Start(c, s1, s2, core, result),
Trusted            | Code(Spec) Body(Spec)          |         OSStep::UnmapOpEnd { core }             => step_Unmap_Op_End(c, s1, s2, core),
Trusted            | Code(Spec) Body(Spec)          |         OSStep::UnmapInitiateShootdown { core } => step_Unmap_Initiate_Shootdown(c, s1, s2, core),
Trusted            | Code(Spec) Body(Spec)          |         OSStep::AckShootdownIPI { core }        => step_Ack_Shootdown_IPI(c, s1, s2, core),
Trusted            | Code(Spec) Body(Spec)          |         OSStep::UnmapEnd { core }               => step_Unmap_End(c, s1, s2, core),
Trusted            | Code(Spec) Body(Spec)          |         OSStep::ViewStutter { core }            => step_View_Stutter(c, s1, s2, core),
Trusted            | Code(Spec) Body(Spec)          |     }
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Code(Spec Signature Body(Spec  | pub open spec fn next(c: OSConstants, s1: OSVariables, s2: OSVariables) -> bool {
Trusted            | Code(Spec) Body(Spec)          |     exists|step: OSStep| next_step(c, s1, s2, step)
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Trusted            | Code(Spec Signature Body(Spec  | pub open spec fn init(c: OSConstants, s: OSVariables) -> bool {
Comment            | Comment                        |     // hardware stuff
Trusted            | Code(Spec) Body(Spec)          |     &&& hardware::interp_pt_mem(s.hw.global_pt) === Map::empty()
Trusted            | Code(Spec) Body(Spec)          |     &&& hardware::init(c.hw, s.hw)
Comment            | Comment                        |     //spec_pt
Trusted            | Code(Spec) Body(Spec)          |     &&& forall|core: Core| #[trigger] hardware::valid_core(c.hw, core) ==> spec_pt::init(s.pt_variables(core))
Comment            | Comment                        |     //wf of ULT2core mapping
Trusted            | Code(Spec) Body(Spec)          |     &&& forall|id: nat| #[trigger] c.valid_ULT(id) <==> c.ULT2core.contains_key(id)
Trusted            | Code(Spec) Body(Spec)          |     &&& forall|id: nat|
Trusted            | Code(Spec) Body(Spec)          |         c.valid_ULT(id) ==> #[trigger] hardware::valid_core(
Trusted            | Code(Spec) Body(Spec)          |             c.hw,
Trusted            | Code(Spec) Body(Spec)          |             c.ULT2core.index(id),
Trusted            | Code(Spec) Body(Spec)          |         )
Comment            | Comment                        |     //core_state
Trusted            | Code(Spec) Body(Spec)          |     &&& forall|core: Core|
Trusted            | Code(Spec) Body(Spec)          |         hardware::valid_core(c.hw, core) <==> #[trigger] s.core_states.contains_key(core)
Trusted            | Code(Spec) Body(Spec)          |     &&& forall|core: Core| #[trigger]
Trusted            | Code(Spec) Body(Spec)          |         hardware::valid_core(c.hw, core) ==> s.core_states[core]
Trusted            | Code(Spec) Body(Spec)          |             === CoreState::Idle
Comment            | Comment                        |         //shootdown
Trusted            | Code(Spec) Body(Spec)          |     &&& s.TLB_Shootdown.open_requests === Set::empty()
Comment            | Comment                        |     //sound
Trusted            | Code(Spec) Body(Spec)          |     &&& s.sound
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
                   |                                | } // verus!

# spec_t/hlproof.rs
                   |                                | use crate::definitions_t::{
                   |                                |     above_zero, between, candidate_mapping_overlaps_existing_pmem, overlap, MemRegion,
                   |                                |     PageTableEntry, WORD_SIZE,
                   |                                | };
                   |                                | use crate::spec_t::mem;
                   |                                | use vstd::prelude::*;
                   |                                | 
                   |                                | use crate::extra::{lemma_set_of_first_n_nat_is_finite, lemma_subset_is_finite};
                   |                                | 
                   |                                | use crate::spec_t::hlspec::{
                   |                                |     candidate_mapping_overlaps_inflight_pmem, if_map_then_unique, inflight_maps_unique,
                   |                                |     inflight_mem_size_over_zero, inv, mappings_frame_sizes_over_zero, mem_domain_from_entry,
                   |                                |     mem_domain_from_entry_contains, mem_domain_from_mappings, mem_domain_from_mappings_contains,
                   |                                |     pmem_no_overlap, step_Map_end, step_Map_start, step_Unmap_start, AbstractArguments,
                   |                                |     AbstractConstants, AbstractVariables,
                   |                                | };
                   |                                | 
                   |                                | verus! {
                   |                                | 
Comment            | Comment                        | //ensures that if a new mapping is added the old ones are still in there and no new other mappings appear
Proof              | Signature(Proof)               | pub proof fn lemma_mem_domain_from_mappings(
Proof              | Signature(Proof)               |     phys_mem_size: nat,
Proof              | Signature(Proof)               |     mappings: Map<nat, PageTableEntry>,
Proof              | Signature(Proof)               |     base: nat,
Proof              | Signature(Proof)               |     pte: PageTableEntry,
Proof              | Signature(Proof)               | )
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         !mappings.dom().contains(base),
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         (forall|word_idx: nat|
Spec               | Signature(Proo FunctionSpec    |             mem_domain_from_mappings_contains(phys_mem_size, word_idx, mappings)
Spec               | Signature(Proo FunctionSpec    |                 ==> #[trigger] mem_domain_from_mappings_contains(
Spec               | Signature(Proo FunctionSpec    |                 phys_mem_size,
Spec               | Signature(Proo FunctionSpec    |                 word_idx,
Spec               | Signature(Proo FunctionSpec    |                 mappings.insert(base, pte),
Spec               | Signature(Proo FunctionSpec    |             )),
Spec               | Signature(Proo FunctionSpec    |         (forall|word_idx: nat|
Spec               | Signature(Proo FunctionSpec    |             !mem_domain_from_mappings_contains(phys_mem_size, word_idx, mappings)
Spec               | Signature(Proo FunctionSpec    |                 && #[trigger] mem_domain_from_mappings_contains(
Spec               | Signature(Proo FunctionSpec    |                 phys_mem_size,
Spec               | Signature(Proo FunctionSpec    |                 word_idx,
Spec               | Signature(Proo FunctionSpec    |                 mappings.insert(base, pte),
Spec               | Signature(Proo FunctionSpec    |             ) ==> between(word_idx * WORD_SIZE as nat, base, base + pte.frame.size)),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proo ProofDire Body(Proo  |     assert forall|word_idx: nat|
Proof              | Code(Proo ProofDire Body(Proo  |         mem_domain_from_mappings_contains(
Proof              | Code(Proo ProofDire Body(Proo  |             phys_mem_size,
Proof              | Code(Proo ProofDire Body(Proo  |             word_idx,
Proof              | Code(Proo ProofDire Body(Proo  |             mappings,
Proof              | Code(Proo ProofDire Body(Proo  |         ) implies #[trigger] mem_domain_from_mappings_contains(
Proof              | Code(Proo ProofDire Body(Proo  |         phys_mem_size,
Proof              | Code(Proo ProofDire Body(Proo  |         word_idx,
Proof              | Code(Proo ProofDire Body(Proo  |         mappings.insert(base, pte),
Proof              | Code(Proo ProofDire Body(Proo  |     ) by {
Proof              | Code(Proo ProofDire Body(Proo  |         let vaddr = word_idx * WORD_SIZE as nat;
Proof              | Code(Proo ProofDire Body(Proo  |         let (base2, pte2) = choose|base: nat, pte: PageTableEntry|
Proof              | Code(Proo ProofDire Body(Proo  |             {
Proof              | Code(Proo ProofDire Body(Proo  |                 let paddr = (pte.frame.base + (vaddr - base)) as nat;
Proof              | Code(Proo ProofDire Body(Proo  |                 let pmem_idx = mem::word_index_spec(paddr);
Proof              | Code(Proo ProofDire Body(Proo  |                 &&& #[trigger] mappings.contains_pair(base, pte)
Proof              | Code(Proo ProofDire Body(Proo  |                 &&& between(vaddr, base, base + pte.frame.size)
Proof              | Code(Proo ProofDire Body(Proo  |                 &&& pmem_idx < phys_mem_size
Proof              | Code(Proo ProofDire Body(Proo  |             };
Proof              | Code(Proo ProofDire Body(Proo  |         assert(mappings.insert(base, pte).contains_pair(base2, pte2));
Proof              | Code(Proo ProofDire Body(Proo  |     };
Proof              | Code(Proo ProofDire Body(Proo  |     assert forall|word_idx: nat|
Proof              | Code(Proo ProofDire Body(Proo  |         !mem_domain_from_mappings_contains(phys_mem_size, word_idx, mappings)
Proof              | Code(Proo ProofDire Body(Proo  |             && #[trigger] mem_domain_from_mappings_contains(
Proof              | Code(Proo ProofDire Body(Proo  |             phys_mem_size,
Proof              | Code(Proo ProofDire Body(Proo  |             word_idx,
Proof              | Code(Proo ProofDire Body(Proo  |             mappings.insert(base, pte),
Proof              | Code(Proo ProofDire Body(Proo  |         ) implies between(word_idx * WORD_SIZE as nat, base, base + pte.frame.size) by {
Proof              | Code(Proo ProofDire Body(Proo  |         let vaddr = word_idx * WORD_SIZE as nat;
Proof              | Code(Proo ProofDire Body(Proo  |         let (base2, pte2) = choose|base2: nat, pte2: PageTableEntry|
Proof              | Code(Proo ProofDire Body(Proo  |             {
Proof              | Code(Proo ProofDire Body(Proo  |                 let paddr = (pte2.frame.base + (vaddr - base2)) as nat;
Proof              | Code(Proo ProofDire Body(Proo  |                 let pmem_idx = mem::word_index_spec(paddr);
Proof              | Code(Proo ProofDire Body(Proo  |                 &&& #[trigger] mappings.insert(base, pte).contains_pair(base2, pte2)
Proof              | Code(Proo ProofDire Body(Proo  |                 &&& between(vaddr, base2, base2 + pte2.frame.size)
Proof              | Code(Proo ProofDire Body(Proo  |                 &&& pmem_idx < phys_mem_size
Proof              | Code(Proo ProofDire Body(Proo  |             };
Proof              | Code(Proo ProofDire Body(Proo  |         assert(mappings.insert(base, pte).contains_pair(base2, pte2));
Proof              | Code(Proo ProofDire Body(Proo  |         assert(between(vaddr, base2, base2 + pte2.frame.size));
Proof              | Code(Proo ProofDire Body(Proo  |         if !between(vaddr, base, base + pte.frame.size) {
Proof              | Code(Proo ProofDire Body(Proo  |             assert(base2 != base || pte2 !== pte);
Proof              | Code(Proo ProofDire Body(Proo  |             if base2 != base {
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(mappings.contains_pair(base2, pte2));
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(mem_domain_from_mappings_contains(phys_mem_size, word_idx, mappings));
Proof              | Code(Proo ProofDire Body(Proo  |             }
Proof              | Code(Proo ProofDire Body(Proo  |             assert(false);
Proof              | Code(Proo ProofDire Body(Proo  |         } else {
Proof              | Code(Proo ProofDire Body(Proo  |         }
Proof              | Code(Proo ProofDire Body(Proo  |     };
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Proof              | Signature(Proof)               | pub proof fn lemma_mem_domain_from_entry_finite(phys_mem_size: nat, base: nat, pte: PageTableEntry)
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         mem_domain_from_entry(phys_mem_size, base, pte).finite(),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proof) Body(Proof)        |     let bound = base + pte.frame.size;
Proof              | Code(Proof) Body(Proof)        |     let vaddrs = mem_domain_from_entry(phys_mem_size, base, pte);
Proof              | Code(Proof) Body(Proof)        |     let n_nats = Set::new(|i: nat| i < (bound + 1 as nat));
Proof              | Code(Proo ProofDire Body(Proo  |     assert(vaddrs.subset_of(n_nats));
Proof              | Code(Proof) Body(Proof)        |     lemma_set_of_first_n_nat_is_finite(bound + 1);
Proof              | Code(Proof) Body(Proof)        |     lemma_subset_is_finite(n_nats, vaddrs);
Proof              | Code(Proo ProofDire Body(Proo  |     assert(vaddrs.finite());
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Proof              | Signature(Proof)               | pub proof fn lemma_mem_domain_from_empty_mappings_finite(
Proof              | Signature(Proof)               |     phys_mem_size: nat,
Proof              | Signature(Proof)               |     mappings: Map<nat, PageTableEntry>,
Proof              | Signature(Proof)               | )
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         mappings.dom() === Set::empty(),
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         mem_domain_from_mappings(phys_mem_size, mappings).finite(),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proo ProofDire Body(Proo  |     assert(mem_domain_from_mappings(phys_mem_size, mappings) === Set::empty())
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Proof              | Signature(Proof)               | pub proof fn lemma_mem_domain_from_mapping_finite(
Proof              | Signature(Proof)               |     phys_mem_size: nat,
Proof              | Signature(Proof)               |     mappings: Map<nat, PageTableEntry>,
Proof              | Signature(Proof)               | )
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         mappings.dom().finite(),
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         mem_domain_from_mappings(phys_mem_size, mappings).finite(),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proof) Body(Proof)        |     if (exists|bs: nat| mappings.dom().contains(bs)) {
Proof              | Code(Proof) Body(Proof)        |         let bs = choose|bs: nat| mappings.dom().contains(bs);
Proof              | Code(Proof) Body(Proof)        |         let pt = mappings[bs];
Proof              | Code(Proof) Body(Proof)        |         let mappings_reduc = mappings.remove(bs);
Proof              | Code(Proo ProofDire Body(Proo  |         assert(!mappings_reduc.dom().contains(bs));
Proof              | Code(Proo ProofDire Body(Proo  |         assert(mappings_reduc.insert(bs, pt) == mappings);
Proof              | Code(Proo ProofDire Body(Proo  |         assert(mappings_reduc.dom().subset_of(mappings.dom()));
Proof              | Code(Proof) Body(Proof)        |         lemma_subset_is_finite(mappings.dom(), mappings_reduc.dom());
Proof              | Code(Proof) Body(Proof)        |         lemma_mem_domain_from_mappings_finite_induction(phys_mem_size, mappings_reduc, bs, pt);
Proof              | Code(Proof) Body(Proof)        |     } else {
Proof              | Code(Proo ProofDire Body(Proo  |         assert(mappings.dom() === Set::empty());
Proof              | Code(Proof) Body(Proof)        |         lemma_mem_domain_from_empty_mappings_finite(phys_mem_size, mappings);
Proof              | Code(Proof) Body(Proof)        |     }
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Proof              | Signature(Proof)               | pub proof fn lemma_mem_domain_from_mappings_finite_induction(
Proof              | Signature(Proof)               |     phys_mem_size: nat,
Proof              | Signature(Proof)               |     mappings: Map<nat, PageTableEntry>,
Proof              | Signature(Proof)               |     base: nat,
Proof              | Signature(Proof)               |     pte: PageTableEntry,
Proof              | Signature(Proof)               | )
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         mappings.dom().finite(),
Spec               | Signature(Proo FunctionSpec    |         !mappings.dom().contains(base),
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         mem_domain_from_mappings(phys_mem_size, mappings.insert(base, pte)).finite(),
Spec               | Signature(Proo FunctionSpec    |     decreases mappings.dom().len(),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proof) Body(Proof)        |     if (exists|bs: nat| mappings.dom().contains(bs)) {
Proof              | Code(Proof) Body(Proof)        |         let bs = choose|bs: nat| mappings.dom().contains(bs);
Proof              | Code(Proof) Body(Proof)        |         let pt = mappings[bs];
Proof              | Code(Proof) Body(Proof)        |         let mappings_reduc = mappings.remove(bs);
Proof              | Code(Proo ProofDire Body(Proo  |         assert(!mappings_reduc.dom().contains(bs));
Proof              | Code(Proo ProofDire Body(Proo  |         assert(mappings_reduc.insert(bs, pt) == mappings);
Proof              | Code(Proo ProofDire Body(Proo  |         assert(mappings_reduc.dom().subset_of(mappings.dom()));
Proof              | Code(Proof) Body(Proof)        |         lemma_subset_is_finite(mappings.dom(), mappings_reduc.dom());
Proof              | Code(Proof) Body(Proof)        |         lemma_mem_domain_from_mappings_finite_induction(phys_mem_size, mappings_reduc, bs, pt);
Proof              | Code(Proof) Body(Proof)        |     } else {
Proof              | Code(Proo ProofDire Body(Proo  |         assert(mappings.dom() === Set::empty());
Proof              | Code(Proof) Body(Proof)        |         lemma_mem_domain_from_empty_mappings_finite(phys_mem_size, mappings);
Proof              | Code(Proof) Body(Proof)        |     }
Proof              | Code(Proof) Body(Proof)        |     lemma_finite_step(phys_mem_size, mappings, base, pte);
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Proof              | Signature(Proof)               | pub proof fn lemma_finite_step(
Proof              | Signature(Proof)               |     phys_mem_size: nat,
Proof              | Signature(Proof)               |     mappings: Map<nat, PageTableEntry>,
Proof              | Signature(Proof)               |     base: nat,
Proof              | Signature(Proof)               |     pte: PageTableEntry,
Proof              | Signature(Proof)               | )
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         mem_domain_from_mappings(phys_mem_size, mappings).finite(),
Spec               | Signature(Proo FunctionSpec    |         mappings.dom().finite(),
Spec               | Signature(Proo FunctionSpec    |         !mappings.dom().contains(base),
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         mem_domain_from_mappings(phys_mem_size, mappings.insert(base, pte)).finite(),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proof) Body(Proof)        |     let mem_dom_ext = mem_domain_from_mappings(phys_mem_size, mappings.insert(base, pte));
Proof              | Code(Proof) Body(Proof)        |     let mem_dom_union = mem_domain_from_mappings(phys_mem_size, mappings).union(
Proof              | Code(Proof) Body(Proof)        |         mem_domain_from_entry(phys_mem_size, base, pte),
Proof              | Code(Proof) Body(Proof)        |     );
Proof              | Code(Proo ProofDire Body(Proo  |     assert forall|wrd: nat| mem_dom_ext.contains(wrd) implies mem_dom_union.contains(wrd) by {
Proof              | Code(Proo ProofDire Body(Proo  |         lemma_mem_domain_from_new_mappings_subset(phys_mem_size, mappings, base, pte, wrd);
Proof              | Code(Proo ProofDire Body(Proo  |     }
Proof              | Code(Proo ProofDire Body(Proo  |     assert(mem_dom_ext.subset_of(mem_dom_union));
Proof              | Code(Proof) Body(Proof)        |     lemma_mem_domain_from_entry_finite(phys_mem_size, base, pte);
Proof              | Code(Proo ProofDire Body(Proo  |     assert(mem_dom_union.finite());
Proof              | Code(Proof) Body(Proof)        |     lemma_subset_is_finite(mem_dom_union, mem_dom_ext);
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Proof              | Signature(Proof)               | pub proof fn lemma_mem_domain_from_new_mappings_subset(
Proof              | Signature(Proof)               |     phys_mem_size: nat,
Proof              | Signature(Proof)               |     mappings: Map<nat, PageTableEntry>,
Proof              | Signature(Proof)               |     bs: nat,
Proof              | Signature(Proof)               |     pt: PageTableEntry,
Proof              | Signature(Proof)               |     word_idx: nat,
Proof              | Signature(Proof)               | )
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         mem_domain_from_mappings(phys_mem_size, mappings.insert(bs, pt)).contains(word_idx),
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         mem_domain_from_mappings(phys_mem_size, mappings).union(
Spec               | Signature(Proo FunctionSpec    |             mem_domain_from_entry(phys_mem_size, bs, pt),
Spec               | Signature(Proo FunctionSpec    |         ).contains(word_idx),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proof) Body(Proof)        |     let mappings_ext = mappings.insert(bs, pt);
Proof              | Code(Proof) Body(Proof)        |     let vaddr = word_idx * WORD_SIZE as nat;
Proof              | Code(Proof) Body(Proof)        |     let (base, pte): (nat, PageTableEntry) = choose|base: nat, pte: PageTableEntry|
Proof              | Code(Proof) Body(Proof)        |         {
Proof              | Code(Proof) Body(Proof)        |             &&& #[trigger] mappings_ext.contains_pair(base, pte)
Proof              | Code(Proof) Body(Proof)        |             &&& mem_domain_from_entry_contains(phys_mem_size, vaddr, base, pte)
Proof              | Code(Proof) Body(Proof)        |         };
Proof              | Code(Proof) Body(Proof)        |     if (base === bs && pte === pt) {
Proof              | Code(Proo ProofDire Body(Proo  |         assert(mem_domain_from_entry(phys_mem_size, bs, pt).contains(word_idx));
Proof              | Code(Proof) Body(Proof)        |     } else {
Proof              | Code(Proo ProofDire Body(Proo  |         assert(mappings.contains_pair(base, pte));
Proof              | Code(Proo ProofDire Body(Proo  |         assert(mem_domain_from_mappings(phys_mem_size, mappings).contains(word_idx));
Proof              | Code(Proof) Body(Proof)        |     }
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Comment            | Comment                        | //                                                                                                               //
Comment            | Comment                        | //                                        Step preserves inv lemmata                                             //
Comment            | Comment                        | //                                                                                                               //
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Proof              | Signature(Proof)               | pub proof fn lemma_overlap_sym(region1: MemRegion, region2: MemRegion)
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         !overlap(region1, region2),
Spec               | Signature(Proo FunctionSpec    |         region1.size > 0,
Spec               | Signature(Proo FunctionSpec    |         region2.size > 0,
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         !overlap(region2, region1),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Proof              | Signature(Proof)               | pub proof fn lemma_overlap(mappings: Map<nat, PageTableEntry>, base: nat, pte: PageTableEntry)
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         pmem_no_overlap(mappings),
Spec               | Signature(Proo FunctionSpec    |         !candidate_mapping_overlaps_existing_pmem(mappings, pte),
Spec               | Signature(Proo FunctionSpec    |         mappings_frame_sizes_over_zero(mappings),
Spec               | Signature(Proo FunctionSpec    |         above_zero(pte.frame.size),
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         pmem_no_overlap(mappings.insert(base, pte)),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proo ProofDire Body(Proo  |     assert(forall|bs1: nat|
Proof              | Code(Proo ProofDire Body(Proo  |         #![auto]
Proof              | Code(Proo ProofDire Body(Proo  |         mappings.dom().contains(bs1) ==> !overlap(pte.frame, mappings.index(bs1).frame));
Proof              | Code(Proo ProofDire Body(Proo  |     assert forall|bs1: nat| #![auto] mappings.dom().contains(bs1) implies !overlap(
Proof              | Code(Proo ProofDire Body(Proo  |         mappings.index(bs1).frame,
Proof              | Code(Proo ProofDire Body(Proo  |         pte.frame,
Proof              | Code(Proo ProofDire Body(Proo  |     ) by {
Proof              | Code(Proo ProofDire Body(Proo  |         lemma_overlap_sym(pte.frame, mappings.index(bs1).frame);
Proof              | Code(Proo ProofDire Body(Proo  |     }
Proof              | Code(Proo ProofDire Body(Proo  |     assert(pmem_no_overlap(mappings.insert(base, pte)));
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Proof              | Signature(Proof)               | pub proof fn insert_non_map_preserves_unique(
Proof              | Signature(Proof)               |     thread_state: Map<nat, AbstractArguments>,
Proof              | Signature(Proof)               |     base: nat,
Proof              | Signature(Proof)               |     arg: AbstractArguments,
Proof              | Signature(Proof)               | )
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         inflight_maps_unique(thread_state),
Spec               | Signature(Proo FunctionSpec    |         !is_map(arg),
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         inflight_maps_unique(thread_state.insert(base, arg)),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proof) Body(Proof)        |     let args = thread_state.insert(base, arg);
Proof              | Code(Proo ProofDire Body(Proo  |     assert forall|id: nat| #[trigger] args.dom().contains(id) implies if_map_then_unique(
Proof              | Code(Proo ProofDire Body(Proo  |         args,
Proof              | Code(Proo ProofDire Body(Proo  |         id,
Proof              | Code(Proo ProofDire Body(Proo  |     ) by {
Proof              | Code(Proo ProofDire Body(Proo  |         if (args.dom().contains(id)) {
Proof              | Code(Proo ProofDire Body(Proo  |             if (id == base) {
Proof              | Code(Proo ProofDire Body(Proo  |             } else {
Proof              | Code(Proo ProofDire Body(Proo  |                 if let AbstractArguments::Map { vaddr, pte } = thread_state.index(id) {
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(args.remove(id) == thread_state.remove(id).insert(base, arg));
Proof              | Code(Proo ProofDire Body(Proo  |                 } else {
Proof              | Code(Proo ProofDire Body(Proo  |                 }
Proof              | Code(Proo ProofDire Body(Proo  |             }
Proof              | Code(Proo ProofDire Body(Proo  |         } else {
Proof              | Code(Proo ProofDire Body(Proo  |         }
Proof              | Code(Proo ProofDire Body(Proo  |     }
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Proof              | Signature(Proof)               | pub proof fn insert_map_preserves_unique(
Proof              | Signature(Proof)               |     thread_state: Map<nat, AbstractArguments>,
Proof              | Signature(Proof)               |     thread_id: nat,
Proof              | Signature(Proof)               |     vaddr: nat,
Proof              | Signature(Proof)               |     pte: PageTableEntry,
Proof              | Signature(Proof)               | )
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         inflight_maps_unique(thread_state),
Spec               | Signature(Proo FunctionSpec    |         !candidate_mapping_overlaps_inflight_pmem(thread_state.values(), pte),
Spec               | Signature(Proo FunctionSpec    |         above_zero(pte.frame.size),
Spec               | Signature(Proo FunctionSpec    |         inflight_mem_size_over_zero(thread_state.values()),
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         inflight_maps_unique(thread_state.insert(thread_id, AbstractArguments::Map { vaddr, pte })),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proof) Body(Proof)        |     let arg = AbstractArguments::Map { vaddr, pte };
Proof              | Code(Proof) Body(Proof)        |     let args = thread_state.insert(thread_id, arg);
Proof              | Code(Proof) Body(Proof)        |     let p = pte;
Proof              | Code(Proo ProofDire Body(Proo  |     assume(inflight_mem_size_over_zero(args.values()));
Proof              | Code(Proo ProofDire Body(Proo  |     assert forall|id: nat| #[trigger] args.dom().contains(id) implies if_map_then_unique(
Proof              | Code(Proo ProofDire Body(Proo  |         args,
Proof              | Code(Proo ProofDire Body(Proo  |         id,
Proof              | Code(Proo ProofDire Body(Proo  |     ) by {
Proof              | Code(Proo ProofDire Body(Proo  |         if (args.dom().contains(id)) {
Proof              | Code(Proo ProofDire Body(Proo  |             if (id == thread_id) {
Proof              | Code(Proo ProofDire Body(Proo  |                 assert forall|other_id: nat| #[trigger]
Proof              | Code(Proo ProofDire Body(Proo  |                     thread_state.dom().contains(other_id) implies arg != thread_state.index(
Proof              | Code(Proo ProofDire Body(Proo  |                     other_id,
Proof              | Code(Proo ProofDire Body(Proo  |                 ) by {
Proof              | Code(Proo ProofDire Body(Proo  |                     if let AbstractArguments::Map { vaddr: x, pte: y } = thread_state.index(
Proof              | Code(Proo ProofDire Body(Proo  |                         other_id,
Proof              | Code(Proo ProofDire Body(Proo  |                     ) {
Proof              | Code(Proo ProofDire Body(Proo  |                         assert(thread_state.values().contains(
Proof              | Code(Proo ProofDire Body(Proo  |                             AbstractArguments::Map { vaddr: x, pte: y },
Proof              | Code(Proo ProofDire Body(Proo  |                         ));
Proof              | Code(Proo ProofDire Body(Proo  |                         assert(!overlap(pte.frame, y.frame));
Proof              | Code(Proo ProofDire Body(Proo  |                     } else {
Proof              | Code(Proo ProofDire Body(Proo  |                     }
Proof              | Code(Proo ProofDire Body(Proo  |                 }
Proof              | Code(Proo ProofDire Body(Proo  |             } else {
Proof              | Code(Proo ProofDire Body(Proo  |                 if let AbstractArguments::Map { vaddr: x, pte: y } = thread_state.index(id) {
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(thread_state.dom().contains(id));
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(thread_state.values().contains(
Proof              | Code(Proo ProofDire Body(Proo  |                         AbstractArguments::Map { vaddr: x, pte: y },
Proof              | Code(Proo ProofDire Body(Proo  |                     ));
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(!overlap(pte.frame, y.frame));
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(args.index(id) != arg);
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(args.remove(id) == thread_state.remove(id).insert(thread_id, arg));
Proof              | Code(Proo ProofDire Body(Proo  |                 } else {
Proof              | Code(Proo ProofDire Body(Proo  |                 }
Proof              | Code(Proo ProofDire Body(Proo  |             }
Proof              | Code(Proo ProofDire Body(Proo  |         } else {
Proof              | Code(Proo ProofDire Body(Proo  |         }
Proof              | Code(Proo ProofDire Body(Proo  |     }
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Spec               | Code(Spec Signature Body(Spec  | pub open spec fn is_map(arg: AbstractArguments) -> bool {
Spec               | Code(Spec) Body(Spec)          |     if let AbstractArguments::Map { vaddr, pte } = arg {
Spec               | Code(Spec) Body(Spec)          |         true
Spec               | Code(Spec) Body(Spec)          |     } else {
Spec               | Code(Spec) Body(Spec)          |         false
Spec               | Code(Spec) Body(Spec)          |     }
Spec               | Code(Spec) Body(Spec)          | }
                   |                                | 
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Comment            | Comment                        | //                                                                                                               //
Comment            | Comment                        | //                                        Step preserves inv proofs                                              //
Comment            | Comment                        | //                                                                                                               //
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Proof              | Signature(Proof)               | pub proof fn unmap_start_preserves_inv(
Proof              | Signature(Proof)               |     c: AbstractConstants,
Proof              | Signature(Proof)               |     s1: AbstractVariables,
Proof              | Signature(Proof)               |     s2: AbstractVariables,
Proof              | Signature(Proof)               |     thread_id: nat,
Proof              | Signature(Proof)               |     vaddr: nat,
Proof              | Signature(Proof)               | )
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         step_Unmap_start(c, s1, s2, thread_id, vaddr),
Spec               | Signature(Proo FunctionSpec    |         s1.sound ==> inv(c, s1),
Spec               | Signature(Proo FunctionSpec    |         s1.sound,
Spec               | Signature(Proo FunctionSpec    |         s1.thread_state.dom().contains(thread_id),
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         s2.sound ==> inv(c, s2),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proof) Body(Proof)        |     if (s2.sound) {
Proof              | Code(Proof) Body(Proof)        |         lemma_mem_domain_from_mapping_finite(c.phys_mem_size, s1.mappings.remove(vaddr));
Proof              | Code(Proo ProofDire Body(Proo  |         assert(forall|id: nat|
Proof              | Code(Proo ProofDire Body(Proo  |             #![auto]
Proof              | Code(Proo ProofDire Body(Proo  |             s2.mappings.dom().contains(id) ==> s1.mappings.index(id) == s2.mappings.index(id));
Proof              | Code(Proof) Body(Proof)        |         let pte = if (s1.mappings.dom().contains(vaddr)) {
Proof              | Code(Proof) Body(Proof)        |             Some(s1.mappings.index(vaddr))
Proof              | Code(Proof) Body(Proof)        |         } else {
Proof              | Code(Proof) Body(Proof)        |             Option::None
Proof              | Code(Proof) Body(Proof)        |         };
Proof              | Code(Proo ProofDire Body(Proo  |         assert(s2.thread_state.values().subset_of(
Proof              | Code(Proo ProofDire Body(Proo  |             s1.thread_state.values().insert(AbstractArguments::Unmap { vaddr, pte }),
Proof              | Code(Proo ProofDire Body(Proo  |         ));
Proof              | Code(Proof) Body(Proof)        |         insert_non_map_preserves_unique(
Proof              | Code(Proof) Body(Proof)        |             s1.thread_state,
Proof              | Code(Proof) Body(Proof)        |             thread_id,
Proof              | Code(Proof) Body(Proof)        |             AbstractArguments::Unmap { vaddr, pte },
Proof              | Code(Proof) Body(Proof)        |         );
Proof              | Code(Proof) Body(Proof)        |     } else {
Proof              | Code(Proof) Body(Proof)        |     }
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Proof              | Signature(Proof)               | pub proof fn map_start_preserves_inv(
Proof              | Signature(Proof)               |     c: AbstractConstants,
Proof              | Signature(Proof)               |     s1: AbstractVariables,
Proof              | Signature(Proof)               |     s2: AbstractVariables,
Proof              | Signature(Proof)               |     thread_id: nat,
Proof              | Signature(Proof)               |     vaddr: nat,
Proof              | Signature(Proof)               |     pte: PageTableEntry,
Proof              | Signature(Proof)               | )
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         step_Map_start(c, s1, s2, thread_id, vaddr, pte),
Spec               | Signature(Proo FunctionSpec    |         s1.sound ==> inv(c, s1),
Spec               | Signature(Proo FunctionSpec    |         s1.sound,
Spec               | Signature(Proo FunctionSpec    |         s1.thread_state.dom().contains(thread_id),
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         s2.sound ==> inv(c, s2),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proof) Body(Proof)        |     if (s2.sound) {
Proof              | Code(Proof) Body(Proof)        |         lemma_mem_domain_from_mapping_finite(c.phys_mem_size, s2.mappings);
Proof              | Code(Proo ProofDire Body(Proo  |         assert(forall|id: nat|
Proof              | Code(Proo ProofDire Body(Proo  |             #![auto]
Proof              | Code(Proo ProofDire Body(Proo  |             s2.mappings.dom().contains(id) ==> s1.mappings.index(id) == s2.mappings.index(id));
Proof              | Code(Proo ProofDire Body(Proo  |         assert(s2.thread_state.values().subset_of(
Proof              | Code(Proo ProofDire Body(Proo  |             s1.thread_state.values().insert(AbstractArguments::Map { vaddr, pte }),
Proof              | Code(Proo ProofDire Body(Proo  |         ));
Proof              | Code(Proof) Body(Proof)        |         insert_map_preserves_unique(s1.thread_state, thread_id, vaddr, pte);
Proof              | Code(Proof) Body(Proof)        |     } else {
Proof              | Code(Proof) Body(Proof)        |     }
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Proof              | Signature(Proof)               | pub proof fn map_end_preserves_inv(
Proof              | Signature(Proof)               |     c: AbstractConstants,
Proof              | Signature(Proof)               |     s1: AbstractVariables,
Proof              | Signature(Proof)               |     s2: AbstractVariables,
Proof              | Signature(Proof)               |     thread_id: nat,
Proof              | Signature(Proof)               |     result: Result<(), ()>,
Proof              | Signature(Proof)               | )
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         step_Map_end(c, s1, s2, thread_id, result),
Spec               | Signature(Proo FunctionSpec    |         s1.sound ==> inv(c, s1),
Spec               | Signature(Proo FunctionSpec    |         s1.sound,
Spec               | Signature(Proo FunctionSpec    |         s1.thread_state.dom().contains(thread_id),
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         s2.sound ==> inv(c, s2),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proof) Body(Proof)        |     if let AbstractArguments::Map { vaddr, pte } = s1.thread_state.index(thread_id) {
Proof              | Code(Proof) Body(Proof)        |         lemma_mem_domain_from_mapping_finite(c.phys_mem_size, s2.mappings);
Proof              | Code(Proo ProofDire Body(Proo  |         assert(s2.thread_state.values().subset_of(
Proof              | Code(Proo ProofDire Body(Proo  |             s1.thread_state.values().insert(AbstractArguments::Empty),
Proof              | Code(Proo ProofDire Body(Proo  |         ));
Proof              | Code(Proof) Body(Proof)        |         insert_non_map_preserves_unique(s1.thread_state, thread_id, AbstractArguments::Empty);
Proof              | Code(Proof) Body(Proof)        |         if (result is Ok) {
Proof              | Code(Proo ProofDire Body(Proo  |             assert(s1.thread_state.values().contains(AbstractArguments::Map { vaddr, pte }));
Proof              | Code(Proo ProofDire Body(Proo  |             assert(s2.thread_state == s1.thread_state.remove(thread_id).insert(
Proof              | Code(Proo ProofDire Body(Proo  |                 thread_id,
Proof              | Code(Proo ProofDire Body(Proo  |                 AbstractArguments::Empty,
Proof              | Code(Proo ProofDire Body(Proo  |             ));
Proof              | Code(Proof) Body(Proof)        |         } else {
Proof              | Code(Proof) Body(Proof)        |         }
Proof              | Code(Proof) Body(Proof)        |     } else {
Proof              | Code(Proof) Body(Proof)        |     }
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
                   |                                | } // verus!

# spec_t/mem.rs
                   |                                | #![verus::trusted]
Comment            | Comment                        | // trusted:
Comment            | Comment                        | // these are wrappers for the interface with the memory
Comment            | Comment                        | // `check_overflow` is a proof to harden the specification, it reduces the overall
Comment            | Comment                        | // trusted-ness of this file, but not in a quantifiable fashion; for this reason we deem
Comment            | Comment                        | // it appropriate to exclude it from P:C accounting
                   |                                | 
                   |                                | use vstd::prelude::*;
                   |                                | 
                   |                                | use crate::definitions_t::{
                   |                                |     aligned, new_seq, overlap, MemRegion, MemRegionExec, MAX_PHYADDR, PAGE_SIZE,
                   |                                |     WORD_SIZE,
                   |                                | };
                   |                                | 
                   |                                | verus! {
                   |                                | 
Trusted            | Signature(Exec)                | pub fn word_index(addr: usize) -> (res: usize)
Trusted            | Signature(Exec FunctionSpec    |     requires
Trusted            | Signature(Exec FunctionSpec    |         aligned(addr as nat, 8),
Trusted            | Signature(Exec FunctionSpec    |     ensures
Trusted            | Signature(Exec FunctionSpec    |         res as nat === word_index_spec(addr as nat),
Comment            | Comment                        |         // Prove this equivalence to use the indexing lemmas
Trusted            | Signature(Exec FunctionSpec    |         res as nat === crate::definitions_t::index_from_offset(addr as nat, WORD_SIZE as nat),
Trusted            | Signature(Exec FunctionSpec    |         word_index_spec(addr as nat) === crate::definitions_t::index_from_offset(
Trusted            | Signature(Exec FunctionSpec    |             addr as nat,
Trusted            | Signature(Exec FunctionSpec    |             WORD_SIZE as nat,
Trusted            | Signature(Exec FunctionSpec    |         ),
Trusted            | Code(Exec) Body(Exec)          | {
Trusted            | Code(Exec) Body(Exec)          |     addr / WORD_SIZE
Trusted            | Code(Exec) Body(Exec)          | }
                   |                                | 
Trusted            | Signature(Spec)                | pub open spec fn word_index_spec(addr: nat) -> nat
Trusted            | Signature(Spec)                |     recommends
Trusted            | Signature(Spec)                |         aligned(addr, 8),
Trusted            | Code(Spec) Body(Spec)          | {
Trusted            | Code(Spec) Body(Spec)          |     addr / (WORD_SIZE as nat)
Trusted            | Code(Spec) Body(Spec)          | }
                   |                                | 
Comment            | Comment                        | // FIXME: We need to allow the dirty and accessed bits to change in the memory.
Comment            | Comment                        | // Or maybe we just specify reads to return those bits as arbitrary?
Trusted            | DatatypeDecl Directive         | #[verifier(external_body)]
Trusted            | DatatypeDecl                   | pub struct PageTableMemory {
Comment            | Comment                        |     /// `phys_mem_ref` is the starting address of the physical memory linear mapping
Trusted            | DatatypeDecl                   |     phys_mem_ref: *mut u64,
Trusted            | DatatypeDecl                   |     cr3: u64,
Trusted            | DatatypeDecl                   | }
                   |                                | 
                   | Impl                           | impl PageTableMemory {
Trusted            | Code(S Impl Signat Body(S      |     pub spec fn alloc_available_pages(self) -> nat;
                   | Impl                           | 
Trusted            | Code(S Impl Signat Body(S      |     pub spec fn regions(self) -> Set<MemRegion>;
                   | Impl                           | 
Trusted            | Code(S Impl Signat Body(S      |     pub spec fn region_view(self, r: MemRegion) -> Seq<u64>;
                   | Impl                           | 
Trusted            | Code(S Impl Signat Body(S      |     pub open spec fn inv(self) -> bool {
Trusted            | Code(Spec Impl Body(Spec       |         &&& self.phys_mem_ref_as_usize_spec() <= 0x7FE0_0000_0000_0000
Trusted            | Code(Spec Impl Body(Spec       |         &&& forall|s1: MemRegion, s2: MemRegion|
Trusted            | Code(Spec Impl Body(Spec       |             self.regions().contains(s1) && self.regions().contains(s2) && s1 !== s2 ==> !overlap(
Trusted            | Code(Spec Impl Body(Spec       |                 s1,
Trusted            | Code(Spec Impl Body(Spec       |                 s2,
Trusted            | Code(Spec Impl Body(Spec       |             )
Trusted            | Code(Spec Impl Body(Spec       |         &&& aligned(self.cr3_spec().base as nat, PAGE_SIZE as nat)
Trusted            | Code(Spec Impl Body(Spec       |         &&& self.cr3_spec().size == PAGE_SIZE
Trusted            | Code(Spec Impl Body(Spec       |     }
                   | Impl                           | 
Trusted            | Code(S Impl Signat Body(S      |     pub open spec fn init(self) -> bool {
Trusted            | Code(Spec Impl Body(Spec       |         &&& self.inv()
Trusted            | Code(Spec Impl Body(Spec       |     }
                   | Impl                           | 
Comment            | Comment                        |     /// `cr3` returns a MemRegion whose base is the address at which the layer 0 page directory is mapped
Trusted            | Impl Directive                 |     #[verifier(external_body)]
Trusted            | Impl Signature(Exec            |     pub fn cr3(&self) -> (res: MemRegionExec)
Trusted            | Impl Signature FunctionS       |         ensures
Trusted            | Impl Signature FunctionS       |             res === self.cr3_spec(),
Trusted            | Code(Exec Impl Body(Exec       |     {
Trusted            | Code(Exec Impl Body(Exec       |         MemRegionExec { base: self.cr3 as usize, size: PAGE_SIZE }
Trusted            | Code(Exec Impl Body(Exec       |     }
                   | Impl                           | 
Trusted            | Code(S Impl Signat Body(S      |     pub open spec fn cr3_spec(&self) -> MemRegionExec;
                   | Impl                           | 
Comment            | Comment                        |     // We assume that alloc_page never fails. In practice we can just keep a buffer of 3+ pages
Comment            | Comment                        |     // that are allocated before we use map_frame.
Comment            | Comment                        |     /// Allocates one page and returns its physical address
Trusted            | Impl Directive                 |     #[verifier(external_body)]
Trusted            | Impl Signature(Exec            |     pub fn alloc_page(&mut self) -> (r: MemRegionExec)
Trusted            | Impl Signature FunctionS       |         requires
Trusted            | Impl Signature FunctionS       |             old(self).inv(),
Trusted            | Impl Signature FunctionS       |             0 < old(self).alloc_available_pages(),
Trusted            | Impl Signature FunctionS       |         ensures
Trusted            | Impl Signature FunctionS       |             self.alloc_available_pages() == old(self).alloc_available_pages() - 1,
Trusted            | Impl Signature FunctionS       |             r@.size == PAGE_SIZE,
Trusted            | Impl Signature FunctionS       |             r@.base + PAGE_SIZE <= MAX_PHYADDR,
Trusted            | Impl Signature FunctionS       |             aligned(r@.base, PAGE_SIZE as nat),
Trusted            | Impl Signature FunctionS       |             !old(self).regions().contains(r@),
Trusted            | Impl Signature FunctionS       |             self.regions() === old(self).regions().insert(r@),
Trusted            | Impl Signature FunctionS       |             self.region_view(r@) === new_seq::<u64>(512nat, 0u64),
Trusted            | Impl Signature FunctionS       |             forall|r2: MemRegion|
Trusted            | Impl Signature FunctionS       |                 r2 !== r@ ==> #[trigger] self.region_view(r2) === old(self).region_view(r2),
Trusted            | Impl Signature FunctionS       |             self.cr3_spec() == old(self).cr3_spec(),
Trusted            | Impl Signature FunctionS       |             self.phys_mem_ref_as_usize_spec() == old(self).phys_mem_ref_as_usize_spec(),
Trusted            | Impl Signature FunctionS       |             self.inv(),
Trusted            | Code(Exec Impl Body(Exec       |     {
Trusted            | Code(Exec Impl Body(Exec       |         unimplemented!()
Trusted            | Code(Exec Impl Body(Exec       |     }
                   | Impl                           | 
Comment            | Comment                        |     /// Deallocates a page
Trusted            | Impl Directive                 |     #[verifier(external_body)]
Trusted            | Impl Signature(Exec            |     pub fn dealloc_page(&mut self, r: MemRegionExec)
Trusted            | Impl Signature FunctionS       |         requires
Trusted            | Impl Signature FunctionS       |             old(self).inv(),
Trusted            | Impl Signature FunctionS       |             old(self).regions().contains(r@),
Trusted            | Impl Signature FunctionS       |         ensures
Trusted            | Impl Signature FunctionS       |             self.regions() === old(self).regions().remove(r@),
Trusted            | Impl Signature FunctionS       |             forall|r2: MemRegion|
Trusted            | Impl Signature FunctionS       |                 r2 !== r@ ==> #[trigger] self.region_view(r2) === old(self).region_view(r2),
Trusted            | Impl Signature FunctionS       |             self.cr3_spec() == old(self).cr3_spec(),
Trusted            | Impl Signature FunctionS       |             self.phys_mem_ref_as_usize_spec() == old(self).phys_mem_ref_as_usize_spec(),
Trusted            | Impl Signature FunctionS       |             self.inv(),
Trusted            | Code(Exec Impl Body(Exec       |     {
Trusted            | Code(Exec Impl Body(Exec       |         unimplemented!()
Trusted            | Code(Exec Impl Body(Exec       |     }
                   | Impl                           | 
Trusted            | Impl Directive                 |     #[verifier(external_body)]
Comment            | Comment                        |     /// Write value to physical address `pbase + idx * WORD_SIZE`
Trusted            | Impl Signature(Exec            |     pub fn write(&mut self, pbase: usize, idx: usize, region: Ghost<MemRegion>, value: u64)
Trusted            | Impl Signature FunctionS       |         requires
Trusted            | Impl Signature FunctionS       |             pbase == region@.base,
Trusted            | Impl Signature FunctionS       |             aligned(pbase as nat, WORD_SIZE as nat),
Trusted            | Impl Signature FunctionS       |             old(self).inv(),
Trusted            | Impl Signature FunctionS       |             old(self).regions().contains(region@),
Trusted            | Impl Signature FunctionS       |             idx < 512,
Trusted            | Impl Signature FunctionS       |         ensures
Trusted            | Impl Signature FunctionS       |             self.region_view(region@) === old(self).region_view(region@).update(idx as int, value),
Trusted            | Impl Signature FunctionS       |             forall|r: MemRegion| r !== region@ ==> self.region_view(r) === old(self).region_view(r),
Trusted            | Impl Signature FunctionS       |             self.regions() === old(self).regions(),
Trusted            | Impl Signature FunctionS       |             self.alloc_available_pages() == old(self).alloc_available_pages(),
Trusted            | Impl Signature FunctionS       |             self.cr3_spec() == old(self).cr3_spec(),
Trusted            | Impl Signature FunctionS       |             self.phys_mem_ref_as_usize_spec() == old(self).phys_mem_ref_as_usize_spec(),
Trusted            | Code(Exec Impl Body(Exec       |     {
Trusted            | Code(Exec Impl Body(Exec       |         let word_offset: isize = (word_index(pbase) + idx) as isize;
Trusted            | Code(Exec Impl Body(Exec       |         unsafe {
Trusted            | Code(Exec Impl Body(Exec       |             self.phys_mem_ref.offset(word_offset).write(value);
Trusted            | Code(Exec Impl Body(Exec       |         }
Trusted            | Code(Exec Impl Body(Exec       |     }
                   | Impl                           | 
Trusted            | Impl Directive                 |     #[verifier(external_body)]
Comment            | Comment                        |     /// Read value at physical address `pbase + idx * WORD_SIZE`
Trusted            | Impl Signature(Exec            |     pub fn read(&self, pbase: usize, idx: usize, region: Ghost<MemRegion>) -> (res: u64)
Trusted            | Impl Signature FunctionS       |         requires
Trusted            | Impl Signature FunctionS       |             pbase == region@.base,
Trusted            | Impl Signature FunctionS       |             aligned(pbase as nat, WORD_SIZE as nat),
Trusted            | Impl Signature FunctionS       |             self.regions().contains(region@),
Trusted            | Impl Signature FunctionS       |             idx < 512,
Trusted            | Impl Signature FunctionS       |         ensures
Trusted            | Impl Signature FunctionS       |             res == self.spec_read(idx as nat, region@),
Trusted            | Code(Exec Impl Body(Exec       |     {
Trusted            | Code(Exec Impl Body(Exec       |         let word_offset: isize = (word_index(pbase) + idx) as isize;
Trusted            | Code(Exec Impl Body(Exec       |         unsafe { self.phys_mem_ref.offset(word_offset).read() }
Trusted            | Code(Exec Impl Body(Exec       |     }
                   | Impl                           | 
Trusted            | Code(S Impl Signat Body(S      |     pub open spec fn spec_read(self, idx: nat, region: MemRegion) -> (res: u64) {
Trusted            | Code(Spec Impl Body(Spec       |         self.region_view(region)[idx as int]
Trusted            | Code(Spec Impl Body(Spec       |     }
                   | Impl                           | 
Comment            | Comment                        |     /// This function manually does the address computation which `read` and `write` rely on not
Comment            | Comment                        |     /// overflowing. Since this function is not `external_body`, Verus checks that there's no
Comment            | Comment                        |     /// overflow. The preconditions are those of `read`, which are a subset of the `write`
Comment            | Comment                        |     /// preconditions.
Comment            | Comment                        |     /// (This is an exec function so it generates the normal overflow VCs.)
                   | Impl                           |     #[verus::line_count::ignore]
                   | Impl                           |     fn check_overflow(&self, pbase: usize, idx: usize, region: Ghost<MemRegion>)
                   | Impl                           |         requires
                   | Impl                           |             pbase <= MAX_PHYADDR,
                   | Impl                           |             self.phys_mem_ref_as_usize_spec() <= 0x7FE0_0000_0000_0000,
                   | Impl                           |             pbase == region@.base,
                   | Impl                           |             aligned(pbase as nat, WORD_SIZE as nat),
                   | Impl                           |             self.regions().contains(region@),
                   | Impl                           |             idx < 512,
                   | Impl                           |     {
                   | Impl                           |         proof {
                   | Impl                           |             crate::definitions_u::lemma_maxphyaddr_facts();
                   | Impl                           |         }
Comment            | Comment                        |         // https://dev-doc.rust-lang.org/beta/std/primitive.pointer.html#method.offset
Comment            | Comment                        |         // The raw pointer offset computation needs to fit in an isize.
Comment            | Comment                        |         // isize::MAX is   0x7FFF_FFFF_FFFF_FFFF
Comment            | Comment                        |         //
Comment            | Comment                        |         // `pbase` is a physical address, so we know it's <= MAX_PHYADDR (2^52-1).
Comment            | Comment                        |         // The no-overflow assertions below require phys_mem_ref <= 0x7FEFFFFFFFFFF009.
Comment            | Comment                        |         // In the invariant we require the (arbitrarily chosen) nicer number
Comment            | Comment                        |         // 0x7FE0_0000_0000_0000 as an upper bound for phys_mem_ref.
Comment            | Comment                        |         // (In practice the address has to be smaller anyway, because the address space
Comment            | Comment                        |         // isn't that large.) NrOS uses 0x4000_0000_0000.
                   | Impl                           |         assert(word_index_spec(pbase as nat) < 0x2_0000_0000_0000) by (nonlinear_arith)
                   | Impl                           |             requires
                   | Impl                           |                 aligned(pbase as nat, WORD_SIZE as nat),
                   | Impl                           |                 pbase <= MAX_PHYADDR,
                   | Impl                           |                 MAX_PHYADDR <= 0xFFFFFFFFFFFFF,
                   | Impl                           |         ;
                   | Impl                           |         let word_offset: isize = (word_index(pbase) + idx) as isize;
                   | Impl                           |         assert(word_offset < 0x2_0000_0000_01FF) by (nonlinear_arith)
                   | Impl                           |             requires
                   | Impl                           |                 idx < 512,
                   | Impl                           |                 word_offset == word_index_spec(pbase as nat) + idx,
                   | Impl                           |                 word_index_spec(pbase as nat) < 0x2_0000_0000_0000,
                   | Impl                           |         ;
                   | Impl                           |         let phys_mem_ref: isize = self.phys_mem_ref_as_usize() as isize;
                   | Impl                           | 
                   | Impl                           |         assert(word_offset * WORD_SIZE < 0x10_0000_0000_0FF8) by (nonlinear_arith)
                   | Impl                           |             requires
                   | Impl                           |                 word_offset < 0x2_0000_0000_01FF,
                   | Impl                           |         ;
                   | Impl                           |         let byte_offset: isize = word_offset * (WORD_SIZE as isize);
                   | Impl                           |         let raw_ptr_offset = phys_mem_ref + word_offset * (WORD_SIZE as isize);
                   | Impl                           |     }
                   | Impl                           | 
Trusted            | Impl Directive                 |     #[verifier(external_body)]
Trusted            | Code(S Impl Signat Body(S      |     pub spec fn phys_mem_ref_as_usize_spec(&self) -> usize;
                   | Impl                           | 
Trusted            | Impl Directive                 |     #[verifier(external_body)]
Trusted            | Impl Signature(Exec            |     fn phys_mem_ref_as_usize(&self) -> (res: usize)
Trusted            | Impl Signature FunctionS       |         ensures
Trusted            | Impl Signature FunctionS       |             res == self.phys_mem_ref_as_usize_spec(),
Trusted            | Code(Exec Impl Body(Exec       |     {
Trusted            | Code(Exec Impl Body(Exec       |         unsafe { self.phys_mem_ref as usize }
Trusted            | Code(Exec Impl Body(Exec       |     }
                   | Impl                           | }
                   |                                | 
                   |                                | } // verus!

# spec_t/os_invariant.rs
                   |                                | use vstd::prelude::*;
                   |                                | 
Comment            | Comment                        | //use crate::impl_u::spec_pt;
Comment            | Comment                        | //use crate::spec_t::hardware::Core;
                   |                                | use crate::definitions_t::{
                   |                                |     above_zero, candidate_mapping_overlaps_existing_vmem, overlap, MemRegion, PageTableEntry,
                   |                                | };
                   |                                | use crate::impl_u::os_refinement::{
                   |                                |     lemma_map_insert_values_equality, map_values_contain_value_of_contained_key,
                   |                                | };
                   |                                | use crate::spec_t::{hardware, hlspec, os};
                   |                                | 
                   |                                | verus! {
                   |                                | 
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Comment            | Comment                        | // Proof of Invariant
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Proof              | Signature(Proof)               | pub proof fn init_implies_inv(c: os::OSConstants, s: os::OSVariables)
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         os::init(c, s),
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         s.inv(c),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proo ProofDire Body(Proo  |     assert(s.basic_inv(c));
Proof              | Code(Proof) Body(Proof)        |     init_implies_tlb_inv(c, s);
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Proof              | Signature(Proof)               | pub proof fn next_preserves_inv(c: os::OSConstants, s1: os::OSVariables, s2: os::OSVariables)
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         s1.inv(c),
Spec               | Signature(Proo FunctionSpec    |         os::next(c, s1, s2),
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         s2.inv(c),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proof) Body(Proof)        |     let step = choose|step| os::next_step(c, s1, s2, step);
Proof              | Code(Proof) Body(Proof)        |     next_step_preserves_inv(c, s1, s2, step);
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Proof              | Signature(Proof)               | pub proof fn next_step_preserves_inv(
Proof              | Signature(Proof)               |     c: os::OSConstants,
Proof              | Signature(Proof)               |     s1: os::OSVariables,
Proof              | Signature(Proof)               |     s2: os::OSVariables,
Proof              | Signature(Proof)               |     step: os::OSStep,
Proof              | Signature(Proof)               | )
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         s1.inv(c),
Spec               | Signature(Proo FunctionSpec    |         os::next_step(c, s1, s2, step),
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         s2.inv(c),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proo ProofDire Body(Proo  |     assert forall|core1, core2|
Proof              | Code(Proo ProofDire Body(Proo  |         (hardware::valid_core(c.hw, core1) && #[trigger] s2.core_states[core1].holds_lock()
Proof              | Code(Proo ProofDire Body(Proo  |             && hardware::valid_core(c.hw, core2)
Proof              | Code(Proo ProofDire Body(Proo  |             && #[trigger] s2.core_states[core2].holds_lock()) implies core1 === core2 by {
Proof              | Code(Proo ProofDire Body(Proo  |         let _ = s1.core_states[core1].holds_lock();
Proof              | Code(Proo ProofDire Body(Proo  |         let _ = s1.core_states[core2].holds_lock();
Proof              | Code(Proo ProofDire Body(Proo  |     }
Proof              | Code(Proo ProofDire Body(Proo  |     assert forall|core| hardware::valid_core(c.hw, core) implies {
Proof              | Code(Proo ProofDire Body(Proo  |         match s2.core_states[core] {
Proof              | Code(Proo ProofDire Body(Proo  |             os::CoreState::UnmapOpExecuting { vaddr,.. }
Proof              | Code(Proo ProofDire Body(Proo  |             | os::CoreState::UnmapOpDone { vaddr, .. }
Proof              | Code(Proo ProofDire Body(Proo  |             | os::CoreState::UnmapShootdownWaiting { vaddr, .. } => {
Proof              | Code(Proo ProofDire Body(Proo  |                 !s2.interp_pt_mem().dom().contains(vaddr)
Proof              | Code(Proo ProofDire Body(Proo  |             },
Proof              | Code(Proo ProofDire Body(Proo  |             _ => { true },
Proof              | Code(Proo ProofDire Body(Proo  |         }
Proof              | Code(Proo ProofDire Body(Proo  |     } by {
Proof              | Code(Proo ProofDire Body(Proo  |         let _ = s1.core_states[core].holds_lock();
Proof              | Code(Proo ProofDire Body(Proo  |     }
Proof              | Code(Proo ProofDire Body(Proo  |     assert(s2.basic_inv(c));
Comment            | Comment                        |     //next_step_preserves_tlb_inv(c, s1, s2, step);
Proof              | Code(Proof) Body(Proof)        |     next_step_preserves_overlap_vmem_inv(c, s1, s2, step);
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Comment            | Comment                        | // Proof of TLB Invariants
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Proof              | Signature(Proof)               | pub proof fn init_implies_tlb_inv(c: os::OSConstants, s: os::OSVariables)
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         os::init(c, s),
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         s.tlb_inv(c),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proo ProofDire Body(Proo  |     assert(s.TLB_Shootdown.open_requests.is_empty());
Proof              | Code(Proof) Body(Proof)        |     Set::lemma_len0_is_empty(s.TLB_Shootdown.open_requests);
Proof              | Code(Proo ProofDire Body(Proo  |     assert(s.TLB_Shootdown.open_requests === Set::empty());
Proof              | Code(Proo ProofDire Body(Proo  |     assert(forall|core| #[trigger]
Proof              | Code(Proo ProofDire Body(Proo  |         hardware::valid_core(c.hw, core)
Proof              | Code(Proo ProofDire Body(Proo  |             ==> s.hw.NUMAs[core.NUMA_id].cores[core.core_id].tlb.dom().is_empty());
Proof              | Code(Proo ProofDire Body(Proo  |     assert(s.shootdown_cores_valid(c));
Proof              | Code(Proo ProofDire Body(Proo  |     assert(s.successful_IPI(c));
Comment            | Comment                        |     //assert(s.successful_shootdown(c));
Proof              | Code(Proo ProofDire Body(Proo  |     assert(s.TLB_dom_subset_of_pt_and_inflight_unmap_vaddr(c));
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Comment            | Comment                        | /*
Comment            | Comment                        |     assert (s2.shootdown_cores_valid(c));
Comment            | Comment                        |     assert (s2.successful_IPI(c));
Comment            | Comment                        |     assert (s2.TLB_dom_subset_of_pt_and_inflight_unmap_vaddr(c));
Layout             | Comment                        | 
Layout             | Comment                        | 
Comment            | Comment                        |     pub open spec fn Unmap_vaddr(self) -> Set<nat> {
Comment            | Comment                        |         Set::new(
Comment            | Comment                        |             |v_address: nat|
Comment            | Comment                        |                 {
Comment            | Comment                        |                     &&& exists|core: Core|
Comment            | Comment                        |                         self.core_states.dom().contains(core) && match self.core_states[core] {
Comment            | Comment                        |                             CoreState::UnmapOpDone { vaddr, result, .. }
Comment            | Comment                        |                             | CoreState::UnmapShootdownWaiting { vaddr, result, .. } => {
Comment            | Comment                        |                                 (result is Ok) && (vaddr === v_address)
Comment            | Comment                        |                             },
Comment            | Comment                        |                             _ => false,
Comment            | Comment                        |                         }
Comment            | Comment                        |                 },
Comment            | Comment                        |         )
Comment            | Comment                        |     }
Comment            | Comment                        | */
                   |                                | 
Proof              | Signature(Proof)               | pub proof fn next_step_preserves_tlb_inv(
Proof              | Signature(Proof)               |     c: os::OSConstants,
Proof              | Signature(Proof)               |     s1: os::OSVariables,
Proof              | Signature(Proof)               |     s2: os::OSVariables,
Proof              | Signature(Proof)               |     step: os::OSStep,
Proof              | Signature(Proof)               | )
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         s1.tlb_inv(c),
Spec               | Signature(Proo FunctionSpec    |         s1.basic_inv(c),
Spec               | Signature(Proo FunctionSpec    |         s2.basic_inv(c),
Spec               | Signature(Proo FunctionSpec    |         os::next_step(c, s1, s2, step),
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         s2.tlb_inv(c),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proof) Body(Proof)        |     match step {
Proof              | Code(Proof) Body(Proof)        |         os::OSStep::HW { ULT_id, step } => {
Proof              | Code(Proo ProofDire Body(Proo  |             assert(s2.shootdown_cores_valid(c));
Proof              | Code(Proo ProofDire Body(Proo  |             assume(s2.successful_IPI(c));
Proof              | Code(Proo ProofDire Body(Proo  |             assume(s2.TLB_dom_subset_of_pt_and_inflight_unmap_vaddr(c));
Layout             | Code(Proof) Body(Proof)        | 
Proof              | Code(Proof) Body(Proof)        |         },
Comment            | Comment                        |         //Map steps
Proof              | Code(Proof) Body(Proof)        |         os::OSStep::MapStart { ULT_id, vaddr, pte } => {
Proof              | Code(Proo ProofDire Body(Proo  |             assert(s2.shootdown_cores_valid(c));
Proof              | Code(Proo ProofDire Body(Proo  |             assert(s2.successful_IPI(c));
Proof              | Code(Proo ProofDire Body(Proo  |             assume(s2.TLB_dom_subset_of_pt_and_inflight_unmap_vaddr(c));
Layout             | Code(Proof) Body(Proof)        | 
Proof              | Code(Proof) Body(Proof)        |         },
Proof              | Code(Proof) Body(Proof)        |         os::OSStep::MapOpStart { core } => {
Proof              | Code(Proo ProofDire Body(Proo  |             assume(s2.Unmap_vaddr() == Set::<nat>::empty());
Proof              | Code(Proo ProofDire Body(Proo  |             assume(s1.Unmap_vaddr() == Set::<nat>::empty());
Proof              | Code(Proo ProofDire Body(Proo  |             assert(s1.interp_pt_mem() =~= s2.interp_pt_mem());
Proof              | Code(Proo ProofDire Body(Proo  |             assert(s2.shootdown_cores_valid(c));
Proof              | Code(Proo ProofDire Body(Proo  |             assert(s2.successful_IPI(c));
Proof              | Code(Proo ProofDire Body(Proo  |             assert(s2.TLB_dom_subset_of_pt_and_inflight_unmap_vaddr(c));
Layout             | Code(Proof) Body(Proof)        | 
Proof              | Code(Proof) Body(Proof)        |         },
Proof              | Code(Proof) Body(Proof)        |         os::OSStep::MapEnd { core, result } => {
Proof              | Code(Proo ProofDire Body(Proo  |             assert(s2.shootdown_cores_valid(c));
Proof              | Code(Proo ProofDire Body(Proo  |             assume(s2.successful_IPI(c));
Proof              | Code(Proo ProofDire Body(Proo  |             assume(s2.Unmap_vaddr() == Set::<nat>::empty());
Proof              | Code(Proo ProofDire Body(Proo  |             assume(s1.Unmap_vaddr() == Set::<nat>::empty());
Comment            | Comment                        |             //assert(s1.interp_pt_mem().dom().subset_of(s2.interp_pt_mem().dom()));
Proof              | Code(Proo ProofDire Body(Proo  |             assume(s2.TLB_dom_subset_of_pt_and_inflight_unmap_vaddr(c));
Layout             | Code(Proof) Body(Proof)        | 
Proof              | Code(Proof) Body(Proof)        |         },
Comment            | Comment                        |         //Unmap steps
Proof              | Code(Proof) Body(Proof)        |         os::OSStep::UnmapStart { ULT_id, vaddr } => {
Proof              | Code(Proo ProofDire Body(Proo  |             assert(s2.shootdown_cores_valid(c));
Proof              | Code(Proo ProofDire Body(Proo  |             assert(s2.successful_IPI(c));
Proof              | Code(Proo ProofDire Body(Proo  |             assume(s2.TLB_dom_subset_of_pt_and_inflight_unmap_vaddr(c));
Layout             | Code(Proof) Body(Proof)        | 
Proof              | Code(Proof) Body(Proof)        |         },
Proof              | Code(Proof) Body(Proof)        |         os::OSStep::UnmapOpStart { core, result } => {
Proof              | Code(Proo ProofDire Body(Proo  |             assume(false);
Proof              | Code(Proof) Body(Proof)        |         },
Proof              | Code(Proof) Body(Proof)        |         os::OSStep::UnmapOpEnd { core } => {
Proof              | Code(Proo ProofDire Body(Proo  |             assert(s2.shootdown_cores_valid(c));
Proof              | Code(Proo ProofDire Body(Proo  |             assume(s2.successful_IPI(c));
Proof              | Code(Proo ProofDire Body(Proo  |             assume(s2.TLB_dom_subset_of_pt_and_inflight_unmap_vaddr(c));
Layout             | Code(Proof) Body(Proof)        | 
Proof              | Code(Proof) Body(Proof)        |         },
Proof              | Code(Proof) Body(Proof)        |         os::OSStep::UnmapInitiateShootdown { core } => {
Proof              | Code(Proo ProofDire Body(Proo  |             assert(s2.shootdown_cores_valid(c));
Proof              | Code(Proo ProofDire Body(Proo  |             assume(s2.successful_IPI(c));
Proof              | Code(Proo ProofDire Body(Proo  |             assume(s2.TLB_dom_subset_of_pt_and_inflight_unmap_vaddr(c));
Proof              | Code(Proof) Body(Proof)        |         },
Proof              | Code(Proof) Body(Proof)        |         os::OSStep::UnmapEnd { core } => {
Proof              | Code(Proo ProofDire Body(Proo  |             assert(s2.shootdown_cores_valid(c));
Proof              | Code(Proo ProofDire Body(Proo  |             assert(s2.successful_IPI(c));
Proof              | Code(Proo ProofDire Body(Proo  |             assume(s2.TLB_dom_subset_of_pt_and_inflight_unmap_vaddr(c));
Layout             | Code(Proof) Body(Proof)        | 
Proof              | Code(Proof) Body(Proof)        |         },
Proof              | Code(Proof) Body(Proof)        |         os::OSStep::AckShootdownIPI { core } => {
Proof              | Code(Proo ProofDire Body(Proo  |             assert(s2.shootdown_cores_valid(c));
Proof              | Code(Proo ProofDire Body(Proo  |             assume(s2.successful_IPI(c));
Proof              | Code(Proo ProofDire Body(Proo  |             assert(s2.TLB_dom_subset_of_pt_and_inflight_unmap_vaddr(c));
Layout             | Code(Proof) Body(Proof)        | 
Proof              | Code(Proof) Body(Proof)        |         },
Proof              | Code(Proof) Body(Proof)        |         os::OSStep::ViewStutter { .. } => {
Proof              | Code(Proo ProofDire Body(Proo  |             assume(false);
Proof              | Code(Proof) Body(Proof)        |         },
Proof              | Code(Proof) Body(Proof)        |     }
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Comment            | Comment                        | // Proof of overlapping virtual memory Invariants
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Proof              | Signature(Proof)               | pub proof fn next_step_preserves_overlap_vmem_inv(
Proof              | Signature(Proof)               |     c: os::OSConstants,
Proof              | Signature(Proof)               |     s1: os::OSVariables,
Proof              | Signature(Proof)               |     s2: os::OSVariables,
Proof              | Signature(Proof)               |     step: os::OSStep,
Proof              | Signature(Proof)               | )
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         s1.inv(c),
Spec               | Signature(Proo FunctionSpec    |         s2.basic_inv(c),
Spec               | Signature(Proo FunctionSpec    |         os::next_step(c, s1, s2, step),
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         s2.overlapping_vmem_inv(c),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proof) Body(Proof)        |     if s2.sound {
Proof              | Code(Proof) Body(Proof)        |         match step {
Proof              | Code(Proof) Body(Proof)        |             os::OSStep::HW { ULT_id, step } => {
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(s2.existing_map_no_overlap_existing_vmem(c));
Proof              | Code(Proof) Body(Proof)        |             },
Comment            | Comment                        |             //Map steps
Proof              | Code(Proof) Body(Proof)        |             os::OSStep::MapStart { ULT_id, vaddr, pte } => {
Proof              | Code(Proof) Body(Proof)        |                 let core = c.ULT2core[ULT_id];
Proof              | Code(Proof) Body(Proof)        |                 let corestate = os::CoreState::MapWaiting { ULT_id, vaddr, pte };
Proof              | Code(Proof) Body(Proof)        |                 Lemma_insert_no_overlap_preserves_no_overlap(
Proof              | Code(Proof) Body(Proof)        |                     c,
Proof              | Code(Proof) Body(Proof)        |                     s1.core_states,
Proof              | Code(Proof) Body(Proof)        |                     s1.interp_pt_mem(),
Proof              | Code(Proof) Body(Proof)        |                     core,
Proof              | Code(Proof) Body(Proof)        |                     corestate,
Proof              | Code(Proof) Body(Proof)        |                 );
Proof              | Code(Proof) Body(Proof)        |                 Lemma_unique_and_overlap_values_implies_overlap_vmem(c, s2);
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(s2.existing_map_no_overlap_existing_vmem(c));
Proof              | Code(Proof) Body(Proof)        |             },
Proof              | Code(Proof) Body(Proof)        |             os::OSStep::MapOpStart { core } => {
Proof              | Code(Proof) Body(Proof)        |                 let vaddr = s1.core_states[core]->MapWaiting_vaddr;
Proof              | Code(Proof) Body(Proof)        |                 let pte = s1.core_states[core]->MapWaiting_pte;
Proof              | Code(Proof) Body(Proof)        |                 let ULT_id = s1.core_states[core]->MapWaiting_ULT_id;
Proof              | Code(Proof) Body(Proof)        |                 let corestate = os::CoreState::MapExecuting { ULT_id, vaddr, pte };
Proof              | Code(Proof) Body(Proof)        |                 Lemma_insert_preserves_no_overlap(
Proof              | Code(Proof) Body(Proof)        |                     c,
Proof              | Code(Proof) Body(Proof)        |                     s1.core_states,
Proof              | Code(Proof) Body(Proof)        |                     s1.interp_pt_mem(),
Proof              | Code(Proof) Body(Proof)        |                     core,
Proof              | Code(Proof) Body(Proof)        |                     corestate,
Proof              | Code(Proof) Body(Proof)        |                 );
Proof              | Code(Proof) Body(Proof)        |                 Lemma_unique_and_overlap_values_implies_overlap_vmem(c, s2);
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(s2.existing_map_no_overlap_existing_vmem(c));
Proof              | Code(Proof) Body(Proof)        |             },
Proof              | Code(Proof) Body(Proof)        |             os::OSStep::MapEnd { core, result } => {
Proof              | Code(Proof) Body(Proof)        |                 let vaddr = s1.core_states[core]->MapWaiting_vaddr;
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(unique_CoreStates(s2.core_states));
Proof              | Code(Proo ProofDire Body(Proo  |                 assert forall|state1: os::CoreState, state2: os::CoreState|
Proof              | Code(Proo ProofDire Body(Proo  |                     s2.core_states.values().contains(state1) && s2.core_states.values().contains(
Proof              | Code(Proo ProofDire Body(Proo  |                         state2,
Proof              | Code(Proo ProofDire Body(Proo  |                     ) && !state1.is_idle() && !state2.is_idle() && overlap(
Proof              | Code(Proo ProofDire Body(Proo  |                         MemRegion {
Proof              | Code(Proo ProofDire Body(Proo  |                             base: state1.vaddr(),
Proof              | Code(Proo ProofDire Body(Proo  |                             size: state1.vmem_pte_size(s2.interp_pt_mem()),
Proof              | Code(Proo ProofDire Body(Proo  |                         },
Proof              | Code(Proo ProofDire Body(Proo  |                         MemRegion {
Proof              | Code(Proo ProofDire Body(Proo  |                             base: state2.vaddr(),
Proof              | Code(Proo ProofDire Body(Proo  |                             size: state2.vmem_pte_size(s2.interp_pt_mem()),
Proof              | Code(Proo ProofDire Body(Proo  |                         },
Proof              | Code(Proo ProofDire Body(Proo  |                     ) implies state1 == state2 by {
Proof              | Code(Proo ProofDire Body(Proo  |                     if (state1.vaddr() == vaddr || state2.vaddr() == vaddr) {
Proof              | Code(Proo ProofDire Body(Proo  |                         admit();
Proof              | Code(Proo ProofDire Body(Proo  |                     } else {
Proof              | Code(Proo ProofDire Body(Proo  |                         if (s1.interp_pt_mem().dom().contains(state1.vaddr())) {
Proof              | Code(Proo ProofDire Body(Proo  |                             assert(overlap(
Proof              | Code(Proo ProofDire Body(Proo  |                                 MemRegion {
Proof              | Code(Proo ProofDire Body(Proo  |                                     base: state1.vaddr(),
Proof              | Code(Proo ProofDire Body(Proo  |                                     size: state1.vmem_pte_size(s1.interp_pt_mem()),
Proof              | Code(Proo ProofDire Body(Proo  |                                 },
Proof              | Code(Proo ProofDire Body(Proo  |                                 MemRegion {
Proof              | Code(Proo ProofDire Body(Proo  |                                     base: state2.vaddr(),
Proof              | Code(Proo ProofDire Body(Proo  |                                     size: state2.vmem_pte_size(s1.interp_pt_mem()),
Proof              | Code(Proo ProofDire Body(Proo  |                                 },
Proof              | Code(Proo ProofDire Body(Proo  |                             ));
Proof              | Code(Proo ProofDire Body(Proo  |                         } else {
Proof              | Code(Proo ProofDire Body(Proo  |                             assume(s2.interp_pt_mem().dom().subset_of(
Proof              | Code(Proo ProofDire Body(Proo  |                                 s1.interp_pt_mem().dom().insert(vaddr),
Proof              | Code(Proo ProofDire Body(Proo  |                             ));
Proof              | Code(Proo ProofDire Body(Proo  |                             assert(!s2.interp_pt_mem().dom().contains(state1.vaddr()));
Proof              | Code(Proo ProofDire Body(Proo  |                         }
Proof              | Code(Proo ProofDire Body(Proo  |                     }
Proof              | Code(Proo ProofDire Body(Proo  |                 }
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(no_overlap_vmem_values(c, s2.core_states, s2.interp_pt_mem()));
Layout             | Code(Proof) Body(Proof)        | 
Proof              | Code(Proof) Body(Proof)        |                 Lemma_unique_and_overlap_values_implies_overlap_vmem(c, s2);
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(s2.inflight_map_no_overlap_inflight_vmem(c));
Layout             | Code(Proof) Body(Proof)        | 
Proof              | Code(Proo ProofDire Body(Proo  |                 assume(s2.existing_map_no_overlap_existing_vmem(c));
Proof              | Code(Proof) Body(Proof)        |             },
Comment            | Comment                        |             //Unmap steps
Proof              | Code(Proof) Body(Proof)        |             os::OSStep::UnmapStart { ULT_id, vaddr } => {
Proof              | Code(Proof) Body(Proof)        |                 let core = c.ULT2core[ULT_id];
Proof              | Code(Proof) Body(Proof)        |                 let corestate = os::CoreState::UnmapWaiting { ULT_id, vaddr };
Proof              | Code(Proof) Body(Proof)        |                 Lemma_insert_no_overlap_preserves_no_overlap(
Proof              | Code(Proof) Body(Proof)        |                     c,
Proof              | Code(Proof) Body(Proof)        |                     s1.core_states,
Proof              | Code(Proof) Body(Proof)        |                     s1.interp_pt_mem(),
Proof              | Code(Proof) Body(Proof)        |                     core,
Proof              | Code(Proof) Body(Proof)        |                     corestate,
Proof              | Code(Proof) Body(Proof)        |                 );
Proof              | Code(Proof) Body(Proof)        |                 Lemma_unique_and_overlap_values_implies_overlap_vmem(c, s2);
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(s2.existing_map_no_overlap_existing_vmem(c));
Proof              | Code(Proof) Body(Proof)        |             },
Proof              | Code(Proof) Body(Proof)        |             os::OSStep::UnmapOpStart { core, result } => {
Proof              | Code(Proof) Body(Proof)        |                 let vaddr = s1.core_states[core]->UnmapWaiting_vaddr;
Proof              | Code(Proof) Body(Proof)        |                 let ULT_id = s1.core_states[core]->UnmapWaiting_ULT_id;
Proof              | Code(Proof) Body(Proof)        |                 let result = match result {
Proof              | Code(Proof) Body(Proof)        |                     Ok(_) => Ok(s1.interp_pt_mem()[vaddr]),
Proof              | Code(Proof) Body(Proof)        |                     Err(_) => Err(()),
Proof              | Code(Proof) Body(Proof)        |                 };
Proof              | Code(Proof) Body(Proof)        |                 let corestate = os::CoreState::UnmapOpExecuting { ULT_id, vaddr, result };
Proof              | Code(Proof) Body(Proof)        |                 Lemma_insert_preserves_no_overlap(
Proof              | Code(Proof) Body(Proof)        |                     c,
Proof              | Code(Proof) Body(Proof)        |                     s1.core_states,
Proof              | Code(Proof) Body(Proof)        |                     s1.interp_pt_mem(),
Proof              | Code(Proof) Body(Proof)        |                     core,
Proof              | Code(Proof) Body(Proof)        |                     corestate,
Proof              | Code(Proof) Body(Proof)        |                 );
Proof              | Code(Proof) Body(Proof)        |                 Lemma_submap_preserves_no_overlap(
Proof              | Code(Proof) Body(Proof)        |                     c,
Proof              | Code(Proof) Body(Proof)        |                     s2.core_states,
Proof              | Code(Proof) Body(Proof)        |                     s1.interp_pt_mem(),
Proof              | Code(Proof) Body(Proof)        |                     s2.interp_pt_mem(),
Proof              | Code(Proof) Body(Proof)        |                 );
Proof              | Code(Proof) Body(Proof)        |                 Lemma_unique_and_overlap_values_implies_overlap_vmem(c, s2);
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(s2.interp_pt_mem().submap_of(s1.interp_pt_mem()));
Layout             | Code(Proof) Body(Proof)        | 
Proof              | Code(Proo ProofDire Body(Proo  |                 assert forall|base| #[trigger]
Proof              | Code(Proo ProofDire Body(Proo  |                     s2.interp_pt_mem().dom().contains(
Proof              | Code(Proo ProofDire Body(Proo  |                         base,
Proof              | Code(Proo ProofDire Body(Proo  |                     ) implies !candidate_mapping_overlaps_existing_vmem(
Proof              | Code(Proo ProofDire Body(Proo  |                     s2.interp_pt_mem().remove(base),
Proof              | Code(Proo ProofDire Body(Proo  |                     base,
Proof              | Code(Proo ProofDire Body(Proo  |                     s2.interp_pt_mem()[base],
Proof              | Code(Proo ProofDire Body(Proo  |                 ) by {
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(s2.interp_pt_mem().dom().contains(base));
Proof              | Code(Proo ProofDire Body(Proo  |                     if (candidate_mapping_overlaps_existing_vmem(
Proof              | Code(Proo ProofDire Body(Proo  |                         s2.interp_pt_mem().remove(base),
Proof              | Code(Proo ProofDire Body(Proo  |                         base,
Proof              | Code(Proo ProofDire Body(Proo  |                         s2.interp_pt_mem()[base],
Proof              | Code(Proo ProofDire Body(Proo  |                     )) {
Proof              | Code(Proo ProofDire Body(Proo  |                         let overlap_vaddr = choose|b: nat|
Proof              | Code(Proo ProofDire Body(Proo  |                             #![auto]
Proof              | Code(Proo ProofDire Body(Proo  |                             {
Proof              | Code(Proo ProofDire Body(Proo  |                                 &&& s2.interp_pt_mem().remove(base).dom().contains(b)
Proof              | Code(Proo ProofDire Body(Proo  |                                 &&& overlap(
Proof              | Code(Proo ProofDire Body(Proo  |                                     MemRegion {
Proof              | Code(Proo ProofDire Body(Proo  |                                         base: base,
Proof              | Code(Proo ProofDire Body(Proo  |                                         size: s2.interp_pt_mem()[base].frame.size,
Proof              | Code(Proo ProofDire Body(Proo  |                                     },
Proof              | Code(Proo ProofDire Body(Proo  |                                     MemRegion { base: b, size: s2.interp_pt_mem()[b].frame.size },
Proof              | Code(Proo ProofDire Body(Proo  |                                 )
Proof              | Code(Proo ProofDire Body(Proo  |                             };
Proof              | Code(Proo ProofDire Body(Proo  |                         assert(s1.interp_pt_mem().remove(base).dom().contains(overlap_vaddr));
Comment            | Comment                        |                         // assert(s1.existing_map_no_overlap_existing_vmem(c));
Proof              | Code(Proo ProofDire Body(Proo  |                         assert(false);
Proof              | Code(Proo ProofDire Body(Proo  |                     }
Proof              | Code(Proo ProofDire Body(Proo  |                 }
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(s2.existing_map_no_overlap_existing_vmem(c));
Layout             | Code(Proof) Body(Proof)        | 
Proof              | Code(Proof) Body(Proof)        |             },
Proof              | Code(Proof) Body(Proof)        |             os::OSStep::UnmapOpEnd { core } => {
Proof              | Code(Proof) Body(Proof)        |                 let vaddr = s1.core_states[core]->UnmapOpExecuting_vaddr;
Proof              | Code(Proof) Body(Proof)        |                 let ULT_id = s1.core_states[core]->UnmapOpExecuting_ULT_id;
Proof              | Code(Proof) Body(Proof)        |                 let result = s1.core_states[core]->UnmapOpExecuting_result;
Proof              | Code(Proof) Body(Proof)        |                 let corestate = os::CoreState::UnmapOpDone { ULT_id, vaddr, result };
Proof              | Code(Proof) Body(Proof)        |                 Lemma_insert_preserves_no_overlap(
Proof              | Code(Proof) Body(Proof)        |                     c,
Proof              | Code(Proof) Body(Proof)        |                     s1.core_states,
Proof              | Code(Proof) Body(Proof)        |                     s1.interp_pt_mem(),
Proof              | Code(Proof) Body(Proof)        |                     core,
Proof              | Code(Proof) Body(Proof)        |                     corestate,
Proof              | Code(Proof) Body(Proof)        |                 );
Proof              | Code(Proof) Body(Proof)        |                 Lemma_unique_and_overlap_values_implies_overlap_vmem(c, s2);
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(s2.existing_map_no_overlap_existing_vmem(c));
Proof              | Code(Proof) Body(Proof)        |             },
Proof              | Code(Proof) Body(Proof)        |             os::OSStep::UnmapInitiateShootdown { core } => {
Proof              | Code(Proof) Body(Proof)        |                 let vaddr = s1.core_states[core]->UnmapOpDone_vaddr;
Proof              | Code(Proof) Body(Proof)        |                 let ULT_id = s1.core_states[core]->UnmapOpDone_ULT_id;
Proof              | Code(Proof) Body(Proof)        |                 let result = s1.core_states[core]->UnmapOpDone_result;
Proof              | Code(Proof) Body(Proof)        |                 let corestate = os::CoreState::UnmapShootdownWaiting { ULT_id, vaddr, result };
Proof              | Code(Proof) Body(Proof)        |                 Lemma_insert_preserves_no_overlap(
Proof              | Code(Proof) Body(Proof)        |                     c,
Proof              | Code(Proof) Body(Proof)        |                     s1.core_states,
Proof              | Code(Proof) Body(Proof)        |                     s1.interp_pt_mem(),
Proof              | Code(Proof) Body(Proof)        |                     core,
Proof              | Code(Proof) Body(Proof)        |                     corestate,
Proof              | Code(Proof) Body(Proof)        |                 );
Proof              | Code(Proof) Body(Proof)        |                 Lemma_unique_and_overlap_values_implies_overlap_vmem(c, s2);
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(s2.existing_map_no_overlap_existing_vmem(c));
Proof              | Code(Proof) Body(Proof)        |             },
Proof              | Code(Proof) Body(Proof)        |             os::OSStep::UnmapEnd { core } => {
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(s2.overlapping_vmem_inv(c));
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(s2.existing_map_no_overlap_existing_vmem(c));
Proof              | Code(Proof) Body(Proof)        |             },
Proof              | Code(Proof) Body(Proof)        |             _ => {
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(s2.overlapping_vmem_inv(c));
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(s2.existing_map_no_overlap_existing_vmem(c));
Proof              | Code(Proof) Body(Proof)        |             },
Proof              | Code(Proof) Body(Proof)        |         }
Proof              | Code(Proof) Body(Proof)        |     }
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Comment            | Comment                        | // Alternative Definition for inflight_map_no_overlap_inflight_vmem and Equivalence proof
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Spec               | Code(Spec Signature Body(Spec  | pub open spec fn unique_CoreStates(map: Map<hardware::Core, os::CoreState>) -> bool {
Spec               | Code(Spec) Body(Spec)          |     forall|a|
Spec               | Code(Spec) Body(Spec)          |         #![auto]
Spec               | Code(Spec) Body(Spec)          |         map.dom().contains(a) && !map.index(a).is_idle() ==> !map.remove(a).values().contains(
Spec               | Code(Spec) Body(Spec)          |             map.index(a),
Spec               | Code(Spec) Body(Spec)          |         )
Spec               | Code(Spec) Body(Spec)          | }
                   |                                | 
Spec               | Signature(Spec)                | pub open spec fn no_overlap_vmem_values(
Spec               | Signature(Spec)                |     c: os::OSConstants,
Spec               | Signature(Spec)                |     core_states: Map<hardware::Core, os::CoreState>,
Spec               | Signature(Spec)                |     pt: Map<nat, PageTableEntry>,
Spec               | Code(Spec Signature Body(Spec  | ) -> bool {
Spec               | Code(Spec) Body(Spec)          |     forall|state1: os::CoreState, state2: os::CoreState|
Spec               | Code(Spec) Body(Spec)          |         core_states.values().contains(state1) && core_states.values().contains(state2)
Spec               | Code(Spec) Body(Spec)          |             && !state1.is_idle() && !state2.is_idle() && overlap(
Spec               | Code(Spec) Body(Spec)          |             MemRegion { base: state1.vaddr(), size: state1.vmem_pte_size(pt) },
Spec               | Code(Spec) Body(Spec)          |             MemRegion { base: state2.vaddr(), size: state2.vmem_pte_size(pt) },
Spec               | Code(Spec) Body(Spec)          |         ) ==> state1 == state2
Spec               | Code(Spec) Body(Spec)          | }
                   |                                | 
Proof              | Signature(Proof)               | pub proof fn Lemma_overlapping_inv_implies_unique_and_overlap_values(
Proof              | Signature(Proof)               |     c: os::OSConstants,
Proof              | Signature(Proof)               |     s: os::OSVariables,
Proof              | Signature(Proof)               | )
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         s.basic_inv(c),
Spec               | Signature(Proo FunctionSpec    |         s.inflight_map_no_overlap_inflight_vmem(c),
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         unique_CoreStates(s.core_states),
Spec               | Signature(Proo FunctionSpec    |         no_overlap_vmem_values(c, s.core_states, s.interp_pt_mem()),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Proof              | Signature(Proof)               | pub proof fn Lemma_unique_and_overlap_values_implies_overlap_vmem(
Proof              | Signature(Proof)               |     c: os::OSConstants,
Proof              | Signature(Proof)               |     s: os::OSVariables,
Proof              | Signature(Proof)               | )
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         unique_CoreStates(s.core_states),
Spec               | Signature(Proo FunctionSpec    |         no_overlap_vmem_values(c, s.core_states, s.interp_pt_mem()),
Spec               | Signature(Proo FunctionSpec    |         s.basic_inv(c),
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         s.inflight_map_no_overlap_inflight_vmem(c),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proo ProofDire Body(Proo  |     assert forall|core1: hardware::Core, core2: hardware::Core|
Proof              | Code(Proo ProofDire Body(Proo  |         (hardware::valid_core(c.hw, core1) && hardware::valid_core(c.hw, core2)
Proof              | Code(Proo ProofDire Body(Proo  |             && !s.core_states[core1].is_idle() && !s.core_states[core2].is_idle() && overlap(
Proof              | Code(Proo ProofDire Body(Proo  |             MemRegion {
Proof              | Code(Proo ProofDire Body(Proo  |                 base: s.core_states[core1].vaddr(),
Proof              | Code(Proo ProofDire Body(Proo  |                 size: s.core_states[core1].vmem_pte_size(s.interp_pt_mem()),
Proof              | Code(Proo ProofDire Body(Proo  |             },
Proof              | Code(Proo ProofDire Body(Proo  |             MemRegion {
Proof              | Code(Proo ProofDire Body(Proo  |                 base: s.core_states[core2].vaddr(),
Proof              | Code(Proo ProofDire Body(Proo  |                 size: s.core_states[core2].vmem_pte_size(s.interp_pt_mem()),
Proof              | Code(Proo ProofDire Body(Proo  |             },
Proof              | Code(Proo ProofDire Body(Proo  |         )) implies (core1 === core2) by {
Proof              | Code(Proo ProofDire Body(Proo  |         if (hardware::valid_core(c.hw, core1) && hardware::valid_core(c.hw, core2)
Proof              | Code(Proo ProofDire Body(Proo  |             && !s.core_states[core1].is_idle() && !s.core_states[core2].is_idle() && overlap(
Proof              | Code(Proo ProofDire Body(Proo  |             MemRegion {
Proof              | Code(Proo ProofDire Body(Proo  |                 base: s.core_states[core1].vaddr(),
Proof              | Code(Proo ProofDire Body(Proo  |                 size: s.core_states[core1].vmem_pte_size(s.interp_pt_mem()),
Proof              | Code(Proo ProofDire Body(Proo  |             },
Proof              | Code(Proo ProofDire Body(Proo  |             MemRegion {
Proof              | Code(Proo ProofDire Body(Proo  |                 base: s.core_states[core2].vaddr(),
Proof              | Code(Proo ProofDire Body(Proo  |                 size: s.core_states[core2].vmem_pte_size(s.interp_pt_mem()),
Proof              | Code(Proo ProofDire Body(Proo  |             },
Proof              | Code(Proo ProofDire Body(Proo  |         )) {
Proof              | Code(Proo ProofDire Body(Proo  |             map_values_contain_value_of_contained_key(s.core_states, core1);
Proof              | Code(Proo ProofDire Body(Proo  |             map_values_contain_value_of_contained_key(s.core_states, core2);
Proof              | Code(Proo ProofDire Body(Proo  |         }
Proof              | Code(Proo ProofDire Body(Proo  |     }
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Comment            | Comment                        | // Lemmata to help proof inflight_map_no_overlap_inflight_vmem
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Proof              | Signature(Proof)               | pub proof fn Lemma_insert_idle_corestate_preserves_no_overlap(
Proof              | Signature(Proof)               |     c: os::OSConstants,
Proof              | Signature(Proof)               |     core_states: Map<hardware::Core, os::CoreState>,
Proof              | Signature(Proof)               |     pt: Map<nat, PageTableEntry>,
Proof              | Signature(Proof)               |     core: hardware::Core,
Proof              | Signature(Proof)               | )
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         core_states.dom().contains(core),
Spec               | Signature(Proo FunctionSpec    |         unique_CoreStates(core_states),
Spec               | Signature(Proo FunctionSpec    |         no_overlap_vmem_values(c, core_states, pt),
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         unique_CoreStates(core_states.insert(core, os::CoreState::Idle)),
Spec               | Signature(Proo FunctionSpec    |         no_overlap_vmem_values(c, core_states.insert(core, os::CoreState::Idle), pt),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proo ProofDire Body(Proo  |     assert forall|a|
Proof              | Code(Proo ProofDire Body(Proo  |         #![auto]
Proof              | Code(Proo ProofDire Body(Proo  |         core_states.insert(core, os::CoreState::Idle).dom().contains(a) && !core_states.insert(
Proof              | Code(Proo ProofDire Body(Proo  |             core,
Proof              | Code(Proo ProofDire Body(Proo  |             os::CoreState::Idle,
Proof              | Code(Proo ProofDire Body(Proo  |         ).index(a).is_idle() implies !core_states.insert(core, os::CoreState::Idle).remove(
Proof              | Code(Proo ProofDire Body(Proo  |         a,
Proof              | Code(Proo ProofDire Body(Proo  |     ).values().contains(core_states.insert(core, os::CoreState::Idle).index(a)) by {
Proof              | Code(Proo ProofDire Body(Proo  |         if (core_states.insert(core, os::CoreState::Idle).dom().contains(a) && !core_states.insert(
Proof              | Code(Proo ProofDire Body(Proo  |             core,
Proof              | Code(Proo ProofDire Body(Proo  |             os::CoreState::Idle,
Proof              | Code(Proo ProofDire Body(Proo  |         ).index(a).is_idle() && a != core) {
Proof              | Code(Proo ProofDire Body(Proo  |             assert(core_states.dom().contains(a));
Proof              | Code(Proo ProofDire Body(Proo  |             assert(core_states.index(a) == core_states.insert(core, os::CoreState::Idle).index(a));
Proof              | Code(Proo ProofDire Body(Proo  |             assert(!core_states.index(a).is_idle());
Proof              | Code(Proo ProofDire Body(Proo  |             assert(!core_states.remove(a).values().contains(core_states.index(a)));
Layout             | Code(Proo ProofDire Body(Proo  | 
Proof              | Code(Proo ProofDire Body(Proo  |             assert(core_states.insert(core, os::CoreState::Idle).remove(a) =~= core_states.remove(
Proof              | Code(Proo ProofDire Body(Proo  |                 a,
Proof              | Code(Proo ProofDire Body(Proo  |             ).insert(core, os::CoreState::Idle));
Layout             | Code(Proo ProofDire Body(Proo  | 
Proof              | Code(Proo ProofDire Body(Proo  |             lemma_map_insert_values_equality(core_states.remove(a), core, os::CoreState::Idle);
Proof              | Code(Proo ProofDire Body(Proo  |         }
Proof              | Code(Proo ProofDire Body(Proo  |     };
Proof              | Code(Proo ProofDire Body(Proo  |     assert(no_overlap_vmem_values(c, core_states.insert(core, os::CoreState::Idle), pt));
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Proof              | Signature(Proof)               | pub proof fn Lemma_insert_preserves_no_overlap(
Proof              | Signature(Proof)               |     c: os::OSConstants,
Proof              | Signature(Proof)               |     core_states: Map<hardware::Core, os::CoreState>,
Proof              | Signature(Proof)               |     pt: Map<nat, PageTableEntry>,
Proof              | Signature(Proof)               |     core: hardware::Core,
Proof              | Signature(Proof)               |     corestate: os::CoreState,
Proof              | Signature(Proof)               | )
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         corestate.holds_lock(),
Spec               | Signature(Proo FunctionSpec    |         forall|cr|
Spec               | Signature(Proo FunctionSpec    |             #![auto]
Spec               | Signature(Proo FunctionSpec    |             core_states.dom().contains(cr) && core_states[cr].holds_lock() ==> cr == core,
Spec               | Signature(Proo FunctionSpec    |         core_states.dom().contains(core),
Spec               | Signature(Proo FunctionSpec    |         unique_CoreStates(core_states),
Spec               | Signature(Proo FunctionSpec    |         no_overlap_vmem_values(c, core_states, pt),
Spec               | Signature(Proo FunctionSpec    |         !core_states[core].is_idle(),
Spec               | Signature(Proo FunctionSpec    |         !corestate.is_idle(),
Spec               | Signature(Proo FunctionSpec    |         core_states[core].vaddr() == corestate.vaddr(),
Spec               | Signature(Proo FunctionSpec    |         core_states[core].vmem_pte_size(pt) >= corestate.vmem_pte_size(pt),
Spec               | Signature(Proo FunctionSpec    |         core_states[core] != corestate,
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         unique_CoreStates(core_states.insert(core, corestate)),
Spec               | Signature(Proo FunctionSpec    |         no_overlap_vmem_values(c, core_states.insert(core, corestate), pt),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proo ProofDire Body(Proo  |     assert forall|a|
Proof              | Code(Proo ProofDire Body(Proo  |         #![auto]
Proof              | Code(Proo ProofDire Body(Proo  |         core_states.insert(core, corestate).dom().contains(a) && !core_states.insert(
Proof              | Code(Proo ProofDire Body(Proo  |             core,
Proof              | Code(Proo ProofDire Body(Proo  |             corestate,
Proof              | Code(Proo ProofDire Body(Proo  |         ).index(a).is_idle() implies !core_states.insert(core, corestate).remove(
Proof              | Code(Proo ProofDire Body(Proo  |         a,
Proof              | Code(Proo ProofDire Body(Proo  |     ).values().contains(core_states.insert(core, corestate).index(a)) by {
Proof              | Code(Proo ProofDire Body(Proo  |         if (a != core) {
Proof              | Code(Proo ProofDire Body(Proo  |             assert(!core_states[a].holds_lock());
Proof              | Code(Proo ProofDire Body(Proo  |             if (core_states.insert(core, corestate).remove(a).values().contains(
Proof              | Code(Proo ProofDire Body(Proo  |                 core_states.insert(core, corestate).index(a),
Proof              | Code(Proo ProofDire Body(Proo  |             )) {
Proof              | Code(Proo ProofDire Body(Proo  |                 let same_core = choose|cr|
Proof              | Code(Proo ProofDire Body(Proo  |                     #![auto]
Proof              | Code(Proo ProofDire Body(Proo  |                     core_states.insert(core, corestate).dom().contains(cr) && core_states.insert(
Proof              | Code(Proo ProofDire Body(Proo  |                         core,
Proof              | Code(Proo ProofDire Body(Proo  |                         corestate,
Proof              | Code(Proo ProofDire Body(Proo  |                     )[cr] == core_states.insert(core, corestate)[a] && cr != a;
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(core_states.remove(a).dom().contains(same_core));
Proof              | Code(Proo ProofDire Body(Proo  |             }
Proof              | Code(Proo ProofDire Body(Proo  |         }
Proof              | Code(Proo ProofDire Body(Proo  |     }
Proof              | Code(Proo ProofDire Body(Proo  |     assert forall|state1: os::CoreState, state2: os::CoreState|
Proof              | Code(Proo ProofDire Body(Proo  |         core_states.insert(core, corestate).values().contains(state1) && core_states.insert(
Proof              | Code(Proo ProofDire Body(Proo  |             core,
Proof              | Code(Proo ProofDire Body(Proo  |             corestate,
Proof              | Code(Proo ProofDire Body(Proo  |         ).values().contains(state2) && !state1.is_idle() && !state2.is_idle() && overlap(
Proof              | Code(Proo ProofDire Body(Proo  |             MemRegion { base: state1.vaddr(), size: state1.vmem_pte_size(pt) },
Proof              | Code(Proo ProofDire Body(Proo  |             MemRegion { base: state2.vaddr(), size: state2.vmem_pte_size(pt) },
Proof              | Code(Proo ProofDire Body(Proo  |         ) implies state1 == state2 by {
Proof              | Code(Proo ProofDire Body(Proo  |         if (state1 == corestate || state2 == corestate) {
Proof              | Code(Proo ProofDire Body(Proo  |             let other = if (state1 != corestate) {
Proof              | Code(Proo ProofDire Body(Proo  |                 state1
Proof              | Code(Proo ProofDire Body(Proo  |             } else {
Proof              | Code(Proo ProofDire Body(Proo  |                 state2
Proof              | Code(Proo ProofDire Body(Proo  |             };
Proof              | Code(Proo ProofDire Body(Proo  |             if (other != corestate) {
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(overlap(
Proof              | Code(Proo ProofDire Body(Proo  |                     MemRegion { base: other.vaddr(), size: other.vmem_pte_size(pt) },
Proof              | Code(Proo ProofDire Body(Proo  |                     MemRegion {
Proof              | Code(Proo ProofDire Body(Proo  |                         base: core_states[core].vaddr(),
Proof              | Code(Proo ProofDire Body(Proo  |                         size: core_states[core].vmem_pte_size(pt),
Proof              | Code(Proo ProofDire Body(Proo  |                     },
Proof              | Code(Proo ProofDire Body(Proo  |                 ));
Proof              | Code(Proo ProofDire Body(Proo  |                 let other_core = choose|b|
Proof              | Code(Proo ProofDire Body(Proo  |                     #![auto]
Proof              | Code(Proo ProofDire Body(Proo  |                     core_states.insert(core, corestate).dom().contains(b) && core_states[b] == other
Proof              | Code(Proo ProofDire Body(Proo  |                         && b != core;
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(core_states.remove(core).dom().contains(other_core));
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(false);
Proof              | Code(Proo ProofDire Body(Proo  |             }
Proof              | Code(Proo ProofDire Body(Proo  |         }
Proof              | Code(Proo ProofDire Body(Proo  |     }
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Proof              | Signature(Proof)               | pub proof fn Lemma_insert_no_overlap_preserves_no_overlap(
Proof              | Signature(Proof)               |     c: os::OSConstants,
Proof              | Signature(Proof)               |     core_states: Map<hardware::Core, os::CoreState>,
Proof              | Signature(Proof)               |     pt: Map<nat, PageTableEntry>,
Proof              | Signature(Proof)               |     core: hardware::Core,
Proof              | Signature(Proof)               |     corestate: os::CoreState,
Proof              | Signature(Proof)               | )
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         core_states.dom().contains(core),
Spec               | Signature(Proo FunctionSpec    |         unique_CoreStates(core_states),
Spec               | Signature(Proo FunctionSpec    |         no_overlap_vmem_values(c, core_states, pt),
Spec               | Signature(Proo FunctionSpec    |         core_states[core].is_idle(),
Spec               | Signature(Proo FunctionSpec    |         !corestate.is_idle(),
Spec               | Signature(Proo FunctionSpec    |         !os::candidate_mapping_overlaps_inflight_vmem(
Spec               | Signature(Proo FunctionSpec    |             pt,
Spec               | Signature(Proo FunctionSpec    |             core_states.values(),
Spec               | Signature(Proo FunctionSpec    |             corestate.vaddr(),
Spec               | Signature(Proo FunctionSpec    |             corestate.vmem_pte_size(pt),
Spec               | Signature(Proo FunctionSpec    |         ),
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         unique_CoreStates(core_states.insert(core, corestate)),
Spec               | Signature(Proo FunctionSpec    |         no_overlap_vmem_values(c, core_states.insert(core, corestate), pt),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proo ProofDire Body(Proo  |     assert forall|a|
Proof              | Code(Proo ProofDire Body(Proo  |         #![auto]
Proof              | Code(Proo ProofDire Body(Proo  |         core_states.insert(core, corestate).dom().contains(a) && !core_states.insert(
Proof              | Code(Proo ProofDire Body(Proo  |             core,
Proof              | Code(Proo ProofDire Body(Proo  |             corestate,
Proof              | Code(Proo ProofDire Body(Proo  |         ).index(a).is_idle() implies !core_states.insert(core, corestate).remove(
Proof              | Code(Proo ProofDire Body(Proo  |         a,
Proof              | Code(Proo ProofDire Body(Proo  |     ).values().contains(core_states.insert(core, corestate).index(a)) by {
Proof              | Code(Proo ProofDire Body(Proo  |         if (core_states.insert(core, corestate).remove(a).values().contains(
Proof              | Code(Proo ProofDire Body(Proo  |             core_states.insert(core, corestate).index(a),
Proof              | Code(Proo ProofDire Body(Proo  |         )) {
Proof              | Code(Proo ProofDire Body(Proo  |             let some_core = choose|cr|
Proof              | Code(Proo ProofDire Body(Proo  |                 #![auto]
Proof              | Code(Proo ProofDire Body(Proo  |                 cr != a && core_states.insert(core, corestate).dom().contains(cr)
Proof              | Code(Proo ProofDire Body(Proo  |                     && core_states.insert(core, corestate)[cr] == core_states.insert(
Proof              | Code(Proo ProofDire Body(Proo  |                     core,
Proof              | Code(Proo ProofDire Body(Proo  |                     corestate,
Proof              | Code(Proo ProofDire Body(Proo  |                 )[a];
Proof              | Code(Proo ProofDire Body(Proo  |             if (a == core || some_core == core) {
Proof              | Code(Proo ProofDire Body(Proo  |                 let other = if (some_core != core) {
Proof              | Code(Proo ProofDire Body(Proo  |                     some_core
Proof              | Code(Proo ProofDire Body(Proo  |                 } else {
Proof              | Code(Proo ProofDire Body(Proo  |                     a
Proof              | Code(Proo ProofDire Body(Proo  |                 };
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(core_states.values().contains(core_states[other]));
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(overlap(
Proof              | Code(Proo ProofDire Body(Proo  |                     MemRegion {
Proof              | Code(Proo ProofDire Body(Proo  |                         base: core_states[other].vaddr(),
Proof              | Code(Proo ProofDire Body(Proo  |                         size: core_states[other].vmem_pte_size(pt),
Proof              | Code(Proo ProofDire Body(Proo  |                     },
Proof              | Code(Proo ProofDire Body(Proo  |                     MemRegion { base: corestate.vaddr(), size: corestate.vmem_pte_size(pt) },
Proof              | Code(Proo ProofDire Body(Proo  |                 ));
Proof              | Code(Proo ProofDire Body(Proo  |             } else {
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(core_states.remove(a).dom().contains(some_core));
Proof              | Code(Proo ProofDire Body(Proo  |             }
Proof              | Code(Proo ProofDire Body(Proo  |         }
Proof              | Code(Proo ProofDire Body(Proo  |     }
Proof              | Code(Proo ProofDire Body(Proo  |     assert forall|state1: os::CoreState, state2: os::CoreState|
Proof              | Code(Proo ProofDire Body(Proo  |         core_states.insert(core, corestate).values().contains(state1) && core_states.insert(
Proof              | Code(Proo ProofDire Body(Proo  |             core,
Proof              | Code(Proo ProofDire Body(Proo  |             corestate,
Proof              | Code(Proo ProofDire Body(Proo  |         ).values().contains(state2) && !state1.is_idle() && !state2.is_idle() && overlap(
Proof              | Code(Proo ProofDire Body(Proo  |             MemRegion { base: state1.vaddr(), size: state1.vmem_pte_size(pt) },
Proof              | Code(Proo ProofDire Body(Proo  |             MemRegion { base: state2.vaddr(), size: state2.vmem_pte_size(pt) },
Proof              | Code(Proo ProofDire Body(Proo  |         ) implies state1 == state2 by {
Proof              | Code(Proo ProofDire Body(Proo  |         if (state1 == corestate || state2 == corestate) {
Proof              | Code(Proo ProofDire Body(Proo  |             let other = if (state1 != corestate) {
Proof              | Code(Proo ProofDire Body(Proo  |                 state1
Proof              | Code(Proo ProofDire Body(Proo  |             } else {
Proof              | Code(Proo ProofDire Body(Proo  |                 state2
Proof              | Code(Proo ProofDire Body(Proo  |             };
Proof              | Code(Proo ProofDire Body(Proo  |             if (other != corestate) {
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(core_states.values().contains(other));
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(overlap(
Proof              | Code(Proo ProofDire Body(Proo  |                     MemRegion { base: other.vaddr(), size: other.vmem_pte_size(pt) },
Proof              | Code(Proo ProofDire Body(Proo  |                     MemRegion { base: corestate.vaddr(), size: corestate.vmem_pte_size(pt) },
Proof              | Code(Proo ProofDire Body(Proo  |                 ));
Proof              | Code(Proo ProofDire Body(Proo  |                 assert(false);
Proof              | Code(Proo ProofDire Body(Proo  |             }
Proof              | Code(Proo ProofDire Body(Proo  |         }
Proof              | Code(Proo ProofDire Body(Proo  |     }
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Proof              | Signature(Proof)               | pub proof fn Lemma_submap_preserves_no_overlap(
Proof              | Signature(Proof)               |     c: os::OSConstants,
Proof              | Signature(Proof)               |     core_states: Map<hardware::Core, os::CoreState>,
Proof              | Signature(Proof)               |     pt: Map<nat, PageTableEntry>,
Proof              | Signature(Proof)               |     sub_pt: Map<nat, PageTableEntry>,
Proof              | Signature(Proof)               | )
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         unique_CoreStates(core_states),
Spec               | Signature(Proo FunctionSpec    |         no_overlap_vmem_values(c, core_states, pt),
Spec               | Signature(Proo FunctionSpec    |         sub_pt.submap_of(pt),
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         no_overlap_vmem_values(c, core_states, sub_pt),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proo ProofDire Body(Proo  |     assert forall|state1: os::CoreState, state2: os::CoreState|
Proof              | Code(Proo ProofDire Body(Proo  |         core_states.values().contains(state1) && core_states.values().contains(state2)
Proof              | Code(Proo ProofDire Body(Proo  |             && !state1.is_idle() && !state2.is_idle() && overlap(
Proof              | Code(Proo ProofDire Body(Proo  |             MemRegion { base: state1.vaddr(), size: state1.vmem_pte_size(sub_pt) },
Proof              | Code(Proo ProofDire Body(Proo  |             MemRegion { base: state2.vaddr(), size: state2.vmem_pte_size(sub_pt) },
Proof              | Code(Proo ProofDire Body(Proo  |         ) implies state1 == state2 by {
Proof              | Code(Proo ProofDire Body(Proo  |         assert(overlap(
Proof              | Code(Proo ProofDire Body(Proo  |             MemRegion { base: state1.vaddr(), size: state1.vmem_pte_size(pt) },
Proof              | Code(Proo ProofDire Body(Proo  |             MemRegion { base: state2.vaddr(), size: state2.vmem_pte_size(pt) },
Proof              | Code(Proo ProofDire Body(Proo  |         ));
Proof              | Code(Proo ProofDire Body(Proo  |     }
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Comment            | Comment                        | // soundness lemmata
Comment            | Comment                        | ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Proof              | Signature(Proof)               | pub proof fn lemma_candidate_mapping_inflight_vmem_overlap_os_implies_hl(
Proof              | Signature(Proof)               |     c: os::OSConstants,
Proof              | Signature(Proof)               |     s: os::OSVariables,
Proof              | Signature(Proof)               |     base: nat,
Proof              | Signature(Proof)               |     candidate_size: nat,
Proof              | Signature(Proof)               | )
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         s.basic_inv(c),
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         os::candidate_mapping_overlaps_inflight_vmem(
Spec               | Signature(Proo FunctionSpec    |             s.interp_pt_mem(),
Spec               | Signature(Proo FunctionSpec    |             s.core_states.values(),
Spec               | Signature(Proo FunctionSpec    |             base,
Spec               | Signature(Proo FunctionSpec    |             candidate_size,
Spec               | Signature(Proo FunctionSpec    |         ) ==> hlspec::candidate_mapping_overlaps_inflight_vmem(
Spec               | Signature(Proo FunctionSpec    |             s.interp(c).thread_state.values(),
Spec               | Signature(Proo FunctionSpec    |             base,
Spec               | Signature(Proo FunctionSpec    |             candidate_size,
Spec               | Signature(Proo FunctionSpec    |         ),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proo ProofDire Body(Proo  |     assert(os::candidate_mapping_overlaps_inflight_vmem(
Proof              | Code(Proo ProofDire Body(Proo  |         s.interp_pt_mem(),
Proof              | Code(Proo ProofDire Body(Proo  |         s.core_states.values(),
Proof              | Code(Proo ProofDire Body(Proo  |         base,
Proof              | Code(Proo ProofDire Body(Proo  |         candidate_size,
Proof              | Code(Proo ProofDire Body(Proo  |     ) ==> hlspec::candidate_mapping_overlaps_inflight_vmem(
Proof              | Code(Proo ProofDire Body(Proo  |         s.interp(c).thread_state.values(),
Proof              | Code(Proo ProofDire Body(Proo  |         base,
Proof              | Code(Proo ProofDire Body(Proo  |         candidate_size,
Proof              | Code(Proo ProofDire Body(Proo  |     )) by {
Proof              | Code(Proo ProofDire Body(Proo  |         if (os::candidate_mapping_overlaps_inflight_vmem(
Proof              | Code(Proo ProofDire Body(Proo  |             s.interp_pt_mem(),
Proof              | Code(Proo ProofDire Body(Proo  |             s.core_states.values(),
Proof              | Code(Proo ProofDire Body(Proo  |             base,
Proof              | Code(Proo ProofDire Body(Proo  |             candidate_size,
Proof              | Code(Proo ProofDire Body(Proo  |         )) {
Proof              | Code(Proo ProofDire Body(Proo  |             let corestate = choose|b: os::CoreState| #![auto]
Proof              | Code(Proo ProofDire Body(Proo  |                 {
Proof              | Code(Proo ProofDire Body(Proo  |                     &&& s.core_states.values().contains(b)
Proof              | Code(Proo ProofDire Body(Proo  |                     &&& match b {
Proof              | Code(Proo ProofDire Body(Proo  |                         os::CoreState::MapWaiting { vaddr, pte, .. }
Proof              | Code(Proo ProofDire Body(Proo  |                         | os::CoreState::MapExecuting { vaddr, pte, .. } => {
Proof              | Code(Proo ProofDire Body(Proo  |                             overlap(
Proof              | Code(Proo ProofDire Body(Proo  |                                 MemRegion { base: vaddr, size: pte.frame.size },
Proof              | Code(Proo ProofDire Body(Proo  |                                 MemRegion { base: base, size: candidate_size },
Proof              | Code(Proo ProofDire Body(Proo  |                             )
Proof              | Code(Proo ProofDire Body(Proo  |                         },
Proof              | Code(Proo ProofDire Body(Proo  |                         os::CoreState::UnmapWaiting { vaddr, .. } => {
Proof              | Code(Proo ProofDire Body(Proo  |                             let size = if s.interp_pt_mem().dom().contains(vaddr) {
Proof              | Code(Proo ProofDire Body(Proo  |                                 s.interp_pt_mem().index(vaddr).frame.size
Proof              | Code(Proo ProofDire Body(Proo  |                             } else {
Proof              | Code(Proo ProofDire Body(Proo  |                                 0
Proof              | Code(Proo ProofDire Body(Proo  |                             };
Proof              | Code(Proo ProofDire Body(Proo  |                             overlap(
Proof              | Code(Proo ProofDire Body(Proo  |                                 MemRegion { base: vaddr, size: size },
Proof              | Code(Proo ProofDire Body(Proo  |                                 MemRegion { base: base, size: candidate_size },
Proof              | Code(Proo ProofDire Body(Proo  |                             )
Proof              | Code(Proo ProofDire Body(Proo  |                         },
Proof              | Code(Proo ProofDire Body(Proo  |                         os::CoreState::UnmapOpExecuting { vaddr, result, .. }
Proof              | Code(Proo ProofDire Body(Proo  |                         | os::CoreState::UnmapOpDone { vaddr, result, .. }
Proof              | Code(Proo ProofDire Body(Proo  |                         | os::CoreState::UnmapShootdownWaiting { vaddr, result, .. } => {
Proof              | Code(Proo ProofDire Body(Proo  |                             let size = if result is Ok {
Proof              | Code(Proo ProofDire Body(Proo  |                                 result.get_Ok_0().frame.size
Proof              | Code(Proo ProofDire Body(Proo  |                             } else {
Proof              | Code(Proo ProofDire Body(Proo  |                                 0
Proof              | Code(Proo ProofDire Body(Proo  |                             };
Proof              | Code(Proo ProofDire Body(Proo  |                             overlap(
Proof              | Code(Proo ProofDire Body(Proo  |                                 MemRegion { base: vaddr, size: size },
Proof              | Code(Proo ProofDire Body(Proo  |                                 MemRegion { base: base, size: candidate_size },
Proof              | Code(Proo ProofDire Body(Proo  |                             )
Proof              | Code(Proo ProofDire Body(Proo  |                         },
Proof              | Code(Proo ProofDire Body(Proo  |                         _ => { false },
Proof              | Code(Proo ProofDire Body(Proo  |                     }
Proof              | Code(Proo ProofDire Body(Proo  |                 };
Proof              | Code(Proo ProofDire Body(Proo  |             let core = choose|core|
Proof              | Code(Proo ProofDire Body(Proo  |                 hardware::valid_core(c.hw, core) && s.core_states[core] == corestate;
Proof              | Code(Proo ProofDire Body(Proo  |             match corestate {
Proof              | Code(Proo ProofDire Body(Proo  |                 os::CoreState::MapWaiting { ULT_id, vaddr, pte, .. }
Proof              | Code(Proo ProofDire Body(Proo  |                 | os::CoreState::MapExecuting { ULT_id, vaddr, pte, .. } => {
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(c.valid_ULT(ULT_id));
Proof              | Code(Proo ProofDire Body(Proo  |                     let thread_state = s.interp_thread_state(c)[ULT_id];
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(s.interp(c).thread_state[ULT_id] == thread_state);
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(s.interp(c).thread_state.dom().contains(ULT_id));
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(s.interp(c).thread_state.values().contains(thread_state));
Proof              | Code(Proo ProofDire Body(Proo  |                     assert({
Proof              | Code(Proo ProofDire Body(Proo  |                         &&& thread_state matches hlspec::AbstractArguments::Map {
Proof              | Code(Proo ProofDire Body(Proo  |                             vaddr: v_address,
Proof              | Code(Proo ProofDire Body(Proo  |                             pte: p_te,
Proof              | Code(Proo ProofDire Body(Proo  |                         }
Proof              | Code(Proo ProofDire Body(Proo  |                         &&& v_address === vaddr
Proof              | Code(Proo ProofDire Body(Proo  |                         &&& p_te === pte
Proof              | Code(Proo ProofDire Body(Proo  |                         &&& overlap(
Proof              | Code(Proo ProofDire Body(Proo  |                             MemRegion { base: v_address, size: p_te.frame.size },
Proof              | Code(Proo ProofDire Body(Proo  |                             MemRegion { base: base, size: candidate_size },
Proof              | Code(Proo ProofDire Body(Proo  |                         )
Proof              | Code(Proo ProofDire Body(Proo  |                     });
Proof              | Code(Proo ProofDire Body(Proo  |                 },
Proof              | Code(Proo ProofDire Body(Proo  |                 os::CoreState::UnmapWaiting { ULT_id, vaddr } => {
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(c.valid_ULT(ULT_id));
Proof              | Code(Proo ProofDire Body(Proo  |                     let thread_state = s.interp_thread_state(c)[ULT_id];
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(s.interp(c).thread_state.dom().contains(ULT_id));
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(s.interp(c).thread_state.values().contains(thread_state));
Proof              | Code(Proo ProofDire Body(Proo  |                     if (s.interp_pt_mem().dom().contains(vaddr)) {
Proof              | Code(Proo ProofDire Body(Proo  |                         assert({
Proof              | Code(Proo ProofDire Body(Proo  |                             &&& thread_state matches hlspec::AbstractArguments::Unmap {
Proof              | Code(Proo ProofDire Body(Proo  |                                 vaddr: v_address,
Proof              | Code(Proo ProofDire Body(Proo  |                                 pte: Some(p_te),
Proof              | Code(Proo ProofDire Body(Proo  |                             }
Proof              | Code(Proo ProofDire Body(Proo  |                             &&& v_address === vaddr
Proof              | Code(Proo ProofDire Body(Proo  |                             &&& s.interp_pt_mem()[vaddr] === p_te
Proof              | Code(Proo ProofDire Body(Proo  |                             &&& overlap(
Proof              | Code(Proo ProofDire Body(Proo  |                                 MemRegion { base: v_address, size: p_te.frame.size },
Proof              | Code(Proo ProofDire Body(Proo  |                                 MemRegion { base: base, size: candidate_size },
Proof              | Code(Proo ProofDire Body(Proo  |                             )
Proof              | Code(Proo ProofDire Body(Proo  |                         });
Proof              | Code(Proo ProofDire Body(Proo  |                     } else {
Proof              | Code(Proo ProofDire Body(Proo  |                         assert({
Proof              | Code(Proo ProofDire Body(Proo  |                             &&& thread_state matches hlspec::AbstractArguments::Unmap {
Proof              | Code(Proo ProofDire Body(Proo  |                                 vaddr: v_address,
Proof              | Code(Proo ProofDire Body(Proo  |                                 pte: None,
Proof              | Code(Proo ProofDire Body(Proo  |                             }
Proof              | Code(Proo ProofDire Body(Proo  |                             &&& v_address === vaddr
Proof              | Code(Proo ProofDire Body(Proo  |                             &&& overlap(
Proof              | Code(Proo ProofDire Body(Proo  |                                 MemRegion { base: v_address, size: 0 },
Proof              | Code(Proo ProofDire Body(Proo  |                                 MemRegion { base: base, size: candidate_size },
Proof              | Code(Proo ProofDire Body(Proo  |                             )
Proof              | Code(Proo ProofDire Body(Proo  |                         });
Proof              | Code(Proo ProofDire Body(Proo  |                     }
Proof              | Code(Proo ProofDire Body(Proo  |                 },
Proof              | Code(Proo ProofDire Body(Proo  |                 os::CoreState::UnmapOpExecuting { ULT_id, vaddr, result, .. }
Proof              | Code(Proo ProofDire Body(Proo  |                 | os::CoreState::UnmapOpDone { ULT_id, vaddr, result, .. }
Proof              | Code(Proo ProofDire Body(Proo  |                 | os::CoreState::UnmapShootdownWaiting { ULT_id, vaddr, result, .. } => {
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(c.valid_ULT(ULT_id));
Proof              | Code(Proo ProofDire Body(Proo  |                     let thread_state = s.interp_thread_state(c)[ULT_id];
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(s.interp(c).thread_state.dom().contains(ULT_id));
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(s.interp(c).thread_state.values().contains(thread_state));
Proof              | Code(Proo ProofDire Body(Proo  |                     if result is Ok {
Proof              | Code(Proo ProofDire Body(Proo  |                         assert({
Proof              | Code(Proo ProofDire Body(Proo  |                             &&& thread_state matches hlspec::AbstractArguments::Unmap {
Proof              | Code(Proo ProofDire Body(Proo  |                                 vaddr: v_address,
Proof              | Code(Proo ProofDire Body(Proo  |                                 pte: Some(pte),
Proof              | Code(Proo ProofDire Body(Proo  |                             }
Proof              | Code(Proo ProofDire Body(Proo  |                             &&& v_address === vaddr
Proof              | Code(Proo ProofDire Body(Proo  |                             &&& result.get_Ok_0() === pte
Proof              | Code(Proo ProofDire Body(Proo  |                             &&& overlap(
Proof              | Code(Proo ProofDire Body(Proo  |                                 MemRegion { base: v_address, size: pte.frame.size },
Proof              | Code(Proo ProofDire Body(Proo  |                                 MemRegion { base: base, size: candidate_size },
Proof              | Code(Proo ProofDire Body(Proo  |                             )
Proof              | Code(Proo ProofDire Body(Proo  |                         });
Proof              | Code(Proo ProofDire Body(Proo  |                     } else {
Proof              | Code(Proo ProofDire Body(Proo  |                         assert({
Proof              | Code(Proo ProofDire Body(Proo  |                             &&& thread_state matches hlspec::AbstractArguments::Unmap {
Proof              | Code(Proo ProofDire Body(Proo  |                                 vaddr: v_address,
Proof              | Code(Proo ProofDire Body(Proo  |                                 pte: None,
Proof              | Code(Proo ProofDire Body(Proo  |                             }
Proof              | Code(Proo ProofDire Body(Proo  |                             &&& v_address === vaddr
Proof              | Code(Proo ProofDire Body(Proo  |                             &&& overlap(
Proof              | Code(Proo ProofDire Body(Proo  |                                 MemRegion { base: v_address, size: 0 },
Proof              | Code(Proo ProofDire Body(Proo  |                                 MemRegion { base: base, size: candidate_size },
Proof              | Code(Proo ProofDire Body(Proo  |                             )
Proof              | Code(Proo ProofDire Body(Proo  |                         });
Proof              | Code(Proo ProofDire Body(Proo  |                     }
Proof              | Code(Proo ProofDire Body(Proo  |                 },
Proof              | Code(Proo ProofDire Body(Proo  |                 _ => {},
Proof              | Code(Proo ProofDire Body(Proo  |             };
Proof              | Code(Proo ProofDire Body(Proo  |         } else {
Proof              | Code(Proo ProofDire Body(Proo  |         };
Proof              | Code(Proo ProofDire Body(Proo  |     };
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Proof              | Signature(Proof)               | pub proof fn lemma_candidate_mapping_inflight_vmem_overlap_hl_implies_os(
Proof              | Signature(Proof)               |     c: os::OSConstants,
Proof              | Signature(Proof)               |     s: os::OSVariables,
Proof              | Signature(Proof)               |     base: nat,
Proof              | Signature(Proof)               |     candidate_size: nat,
Proof              | Signature(Proof)               | )
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         s.basic_inv(c),
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         hlspec::candidate_mapping_overlaps_inflight_vmem(
Spec               | Signature(Proo FunctionSpec    |             s.interp(c).thread_state.values(),
Spec               | Signature(Proo FunctionSpec    |             base,
Spec               | Signature(Proo FunctionSpec    |             candidate_size,
Spec               | Signature(Proo FunctionSpec    |         ) ==> os::candidate_mapping_overlaps_inflight_vmem(
Spec               | Signature(Proo FunctionSpec    |             s.interp_pt_mem(),
Spec               | Signature(Proo FunctionSpec    |             s.core_states.values(),
Spec               | Signature(Proo FunctionSpec    |             base,
Spec               | Signature(Proo FunctionSpec    |             candidate_size,
Spec               | Signature(Proo FunctionSpec    |         ),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proo ProofDire Body(Proo  |     assert(hlspec::candidate_mapping_overlaps_inflight_vmem(
Proof              | Code(Proo ProofDire Body(Proo  |         s.interp(c).thread_state.values(),
Proof              | Code(Proo ProofDire Body(Proo  |         base,
Proof              | Code(Proo ProofDire Body(Proo  |         candidate_size,
Proof              | Code(Proo ProofDire Body(Proo  |     ) ==> os::candidate_mapping_overlaps_inflight_vmem(
Proof              | Code(Proo ProofDire Body(Proo  |         s.interp_pt_mem(),
Proof              | Code(Proo ProofDire Body(Proo  |         s.core_states.values(),
Proof              | Code(Proo ProofDire Body(Proo  |         base,
Proof              | Code(Proo ProofDire Body(Proo  |         candidate_size,
Proof              | Code(Proo ProofDire Body(Proo  |     )) by {
Proof              | Code(Proo ProofDire Body(Proo  |         if (hlspec::candidate_mapping_overlaps_inflight_vmem(
Proof              | Code(Proo ProofDire Body(Proo  |             s.interp(c).thread_state.values(),
Proof              | Code(Proo ProofDire Body(Proo  |             base,
Proof              | Code(Proo ProofDire Body(Proo  |             candidate_size,
Proof              | Code(Proo ProofDire Body(Proo  |         )) {
Proof              | Code(Proo ProofDire Body(Proo  |             let thread_state = choose|b|
Proof              | Code(Proo ProofDire Body(Proo  |                 {
Proof              | Code(Proo ProofDire Body(Proo  |                     &&& s.interp(c).thread_state.values().contains(b)
Proof              | Code(Proo ProofDire Body(Proo  |                     &&& match b {
Proof              | Code(Proo ProofDire Body(Proo  |                         hlspec::AbstractArguments::Map { vaddr, pte } => {
Proof              | Code(Proo ProofDire Body(Proo  |                             overlap(
Proof              | Code(Proo ProofDire Body(Proo  |                                 MemRegion { base: vaddr, size: pte.frame.size },
Proof              | Code(Proo ProofDire Body(Proo  |                                 MemRegion { base: base, size: candidate_size },
Proof              | Code(Proo ProofDire Body(Proo  |                             )
Proof              | Code(Proo ProofDire Body(Proo  |                         },
Proof              | Code(Proo ProofDire Body(Proo  |                         hlspec::AbstractArguments::Unmap { vaddr, pte } => {
Proof              | Code(Proo ProofDire Body(Proo  |                             let size = if pte.is_some() {
Proof              | Code(Proo ProofDire Body(Proo  |                                 pte.unwrap().frame.size
Proof              | Code(Proo ProofDire Body(Proo  |                             } else {
Proof              | Code(Proo ProofDire Body(Proo  |                                 0
Proof              | Code(Proo ProofDire Body(Proo  |                             };
Proof              | Code(Proo ProofDire Body(Proo  |                             overlap(
Proof              | Code(Proo ProofDire Body(Proo  |                                 MemRegion { base: vaddr, size: size },
Proof              | Code(Proo ProofDire Body(Proo  |                                 MemRegion { base: base, size: candidate_size },
Proof              | Code(Proo ProofDire Body(Proo  |                             )
Proof              | Code(Proo ProofDire Body(Proo  |                         },
Proof              | Code(Proo ProofDire Body(Proo  |                         _ => { false },
Proof              | Code(Proo ProofDire Body(Proo  |                     }
Proof              | Code(Proo ProofDire Body(Proo  |                 };
Proof              | Code(Proo ProofDire Body(Proo  |             let ULT_id = choose|id| #[trigger]
Proof              | Code(Proo ProofDire Body(Proo  |                 c.valid_ULT(id) && s.interp(c).thread_state[id] == thread_state;
Proof              | Code(Proo ProofDire Body(Proo  |             assert(c.valid_ULT(ULT_id));
Proof              | Code(Proo ProofDire Body(Proo  |             let core = c.ULT2core[ULT_id];
Proof              | Code(Proo ProofDire Body(Proo  |             assert(hardware::valid_core(c.hw, core));
Proof              | Code(Proo ProofDire Body(Proo  |             assert(s.core_states.dom().contains(core));
Proof              | Code(Proo ProofDire Body(Proo  |             let core_state = s.core_states[core];
Proof              | Code(Proo ProofDire Body(Proo  |             assert(s.core_states.values().contains(core_state));
Proof              | Code(Proo ProofDire Body(Proo  |             match core_state {
Proof              | Code(Proo ProofDire Body(Proo  |                 os::CoreState::MapWaiting { ULT_id: ult_id, vaddr, pte, .. }
Proof              | Code(Proo ProofDire Body(Proo  |                 | os::CoreState::MapExecuting { ULT_id: ult_id, vaddr, pte, .. } => {
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(ult_id == ULT_id);
Comment            | Comment                        |                     //assert(above_zero(pte.frame.size));
Proof              | Code(Proo ProofDire Body(Proo  |                     assert({
Proof              | Code(Proo ProofDire Body(Proo  |                         &&& thread_state matches hlspec::AbstractArguments::Map {
Proof              | Code(Proo ProofDire Body(Proo  |                             vaddr: v_addr,
Proof              | Code(Proo ProofDire Body(Proo  |                             pte: entry,
Proof              | Code(Proo ProofDire Body(Proo  |                         }
Proof              | Code(Proo ProofDire Body(Proo  |                         &&& vaddr === v_addr
Proof              | Code(Proo ProofDire Body(Proo  |                         &&& entry === pte
Proof              | Code(Proo ProofDire Body(Proo  |                     });
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(overlap(
Proof              | Code(Proo ProofDire Body(Proo  |                         MemRegion { base: vaddr, size: pte.frame.size },
Proof              | Code(Proo ProofDire Body(Proo  |                         MemRegion { base: base, size: candidate_size },
Proof              | Code(Proo ProofDire Body(Proo  |                     ));
Proof              | Code(Proo ProofDire Body(Proo  |                 },
Proof              | Code(Proo ProofDire Body(Proo  |                 os::CoreState::UnmapWaiting { ULT_id: ult_id, vaddr } => {
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(ult_id == ULT_id);
Proof              | Code(Proo ProofDire Body(Proo  |                     if s.interp_pt_mem().dom().contains(vaddr) {
Proof              | Code(Proo ProofDire Body(Proo  |                         let pte = s.interp_pt_mem()[vaddr];
Proof              | Code(Proo ProofDire Body(Proo  |                         assert({
Proof              | Code(Proo ProofDire Body(Proo  |                             &&& thread_state matches hlspec::AbstractArguments::Unmap {
Proof              | Code(Proo ProofDire Body(Proo  |                                 vaddr: v_addr,
Proof              | Code(Proo ProofDire Body(Proo  |                                 pte: Some(entry),
Proof              | Code(Proo ProofDire Body(Proo  |                             }
Proof              | Code(Proo ProofDire Body(Proo  |                             &&& vaddr === v_addr
Proof              | Code(Proo ProofDire Body(Proo  |                             &&& entry === pte
Proof              | Code(Proo ProofDire Body(Proo  |                         });
Proof              | Code(Proo ProofDire Body(Proo  |                         assert(overlap(
Proof              | Code(Proo ProofDire Body(Proo  |                             MemRegion { base: vaddr, size: pte.frame.size },
Proof              | Code(Proo ProofDire Body(Proo  |                             MemRegion { base: base, size: candidate_size },
Proof              | Code(Proo ProofDire Body(Proo  |                         ));
Proof              | Code(Proo ProofDire Body(Proo  |                     } else {
Proof              | Code(Proo ProofDire Body(Proo  |                         assert({
Proof              | Code(Proo ProofDire Body(Proo  |                             &&& thread_state matches hlspec::AbstractArguments::Unmap {
Proof              | Code(Proo ProofDire Body(Proo  |                                 vaddr: v_addr,
Proof              | Code(Proo ProofDire Body(Proo  |                                 pte: None,
Proof              | Code(Proo ProofDire Body(Proo  |                             }
Proof              | Code(Proo ProofDire Body(Proo  |                             &&& vaddr === v_addr
Proof              | Code(Proo ProofDire Body(Proo  |                         });
Proof              | Code(Proo ProofDire Body(Proo  |                         assert(overlap(
Proof              | Code(Proo ProofDire Body(Proo  |                             MemRegion { base: vaddr, size: 0 },
Proof              | Code(Proo ProofDire Body(Proo  |                             MemRegion { base: base, size: candidate_size },
Proof              | Code(Proo ProofDire Body(Proo  |                         ));
Proof              | Code(Proo ProofDire Body(Proo  |                     }
Proof              | Code(Proo ProofDire Body(Proo  |                 },
Proof              | Code(Proo ProofDire Body(Proo  |                 os::CoreState::UnmapOpExecuting { ULT_id: ult_id, vaddr, result, .. }
Proof              | Code(Proo ProofDire Body(Proo  |                 | os::CoreState::UnmapOpDone { ULT_id: ult_id, vaddr, result, .. }
Proof              | Code(Proo ProofDire Body(Proo  |                 | os::CoreState::UnmapShootdownWaiting { ULT_id: ult_id, vaddr, result, .. } => {
Proof              | Code(Proo ProofDire Body(Proo  |                     if result is Ok {
Proof              | Code(Proo ProofDire Body(Proo  |                         assert(ult_id == ULT_id);
Proof              | Code(Proo ProofDire Body(Proo  |                         assert({
Proof              | Code(Proo ProofDire Body(Proo  |                             &&& thread_state matches hlspec::AbstractArguments::Unmap {
Proof              | Code(Proo ProofDire Body(Proo  |                                 vaddr: v_addr,
Proof              | Code(Proo ProofDire Body(Proo  |                                 pte: Some(pte),
Proof              | Code(Proo ProofDire Body(Proo  |                             }
Proof              | Code(Proo ProofDire Body(Proo  |                             &&& vaddr === v_addr
Proof              | Code(Proo ProofDire Body(Proo  |                             &&& result.get_Ok_0() === pte
Proof              | Code(Proo ProofDire Body(Proo  |                         });
Proof              | Code(Proo ProofDire Body(Proo  |                         assert(overlap(
Proof              | Code(Proo ProofDire Body(Proo  |                             MemRegion { base: vaddr, size: result.get_Ok_0().frame.size },
Proof              | Code(Proo ProofDire Body(Proo  |                             MemRegion { base: base, size: candidate_size },
Proof              | Code(Proo ProofDire Body(Proo  |                         ));
Proof              | Code(Proo ProofDire Body(Proo  |                     } else {
Proof              | Code(Proo ProofDire Body(Proo  |                         assert({
Proof              | Code(Proo ProofDire Body(Proo  |                             &&& thread_state matches hlspec::AbstractArguments::Unmap {
Proof              | Code(Proo ProofDire Body(Proo  |                                 vaddr: v_addr,
Proof              | Code(Proo ProofDire Body(Proo  |                                 pte: None,
Proof              | Code(Proo ProofDire Body(Proo  |                             }
Proof              | Code(Proo ProofDire Body(Proo  |                             &&& vaddr === v_addr
Proof              | Code(Proo ProofDire Body(Proo  |                         });
Proof              | Code(Proo ProofDire Body(Proo  |                         assert(overlap(
Proof              | Code(Proo ProofDire Body(Proo  |                             MemRegion { base: vaddr, size: 0 },
Proof              | Code(Proo ProofDire Body(Proo  |                             MemRegion { base: base, size: candidate_size },
Proof              | Code(Proo ProofDire Body(Proo  |                         ));
Layout             | Code(Proo ProofDire Body(Proo  | 
Proof              | Code(Proo ProofDire Body(Proo  |                     }
Proof              | Code(Proo ProofDire Body(Proo  |                 },
Proof              | Code(Proo ProofDire Body(Proo  |                 _ => {},
Proof              | Code(Proo ProofDire Body(Proo  |             };
Proof              | Code(Proo ProofDire Body(Proo  |         } else {
Proof              | Code(Proo ProofDire Body(Proo  |         }
Proof              | Code(Proo ProofDire Body(Proo  |     };
Layout             | Code(Proof) Body(Proof)        | 
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Proof              | Signature(Proof)               | pub proof fn lemma_candidate_mapping_inflight_pmem_overlap_os_implies_hl(
Proof              | Signature(Proof)               |     c: os::OSConstants,
Proof              | Signature(Proof)               |     s: os::OSVariables,
Proof              | Signature(Proof)               |     candidate: PageTableEntry,
Proof              | Signature(Proof)               | )
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         s.basic_inv(c),
Spec               | Signature(Proo FunctionSpec    |         above_zero(candidate.frame.size),
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         os::candidate_mapping_overlaps_inflight_pmem(
Spec               | Signature(Proo FunctionSpec    |             s.interp_pt_mem(),
Spec               | Signature(Proo FunctionSpec    |             s.core_states.values(),
Spec               | Signature(Proo FunctionSpec    |             candidate,
Spec               | Signature(Proo FunctionSpec    |         ) ==> hlspec::candidate_mapping_overlaps_inflight_pmem(
Spec               | Signature(Proo FunctionSpec    |             s.interp(c).thread_state.values(),
Spec               | Signature(Proo FunctionSpec    |             candidate,
Spec               | Signature(Proo FunctionSpec    |         ),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proo ProofDire Body(Proo  |     assert(os::candidate_mapping_overlaps_inflight_pmem(
Proof              | Code(Proo ProofDire Body(Proo  |         s.interp_pt_mem(),
Proof              | Code(Proo ProofDire Body(Proo  |         s.core_states.values(),
Proof              | Code(Proo ProofDire Body(Proo  |         candidate,
Proof              | Code(Proo ProofDire Body(Proo  |     ) ==> hlspec::candidate_mapping_overlaps_inflight_pmem(
Proof              | Code(Proo ProofDire Body(Proo  |         s.interp(c).thread_state.values(),
Proof              | Code(Proo ProofDire Body(Proo  |         candidate,
Proof              | Code(Proo ProofDire Body(Proo  |     )) by {
Proof              | Code(Proo ProofDire Body(Proo  |         if os::candidate_mapping_overlaps_inflight_pmem(
Proof              | Code(Proo ProofDire Body(Proo  |             s.interp_pt_mem(),
Proof              | Code(Proo ProofDire Body(Proo  |             s.core_states.values(),
Proof              | Code(Proo ProofDire Body(Proo  |             candidate,
Proof              | Code(Proo ProofDire Body(Proo  |         ) {
Proof              | Code(Proo ProofDire Body(Proo  |             let corestate = choose|b: os::CoreState| #![auto]
Proof              | Code(Proo ProofDire Body(Proo  |                 {
Proof              | Code(Proo ProofDire Body(Proo  |                     &&& s.core_states.values().contains(b)
Proof              | Code(Proo ProofDire Body(Proo  |                     &&& match b {
Proof              | Code(Proo ProofDire Body(Proo  |                         os::CoreState::MapWaiting { vaddr, pte, .. }
Proof              | Code(Proo ProofDire Body(Proo  |                         | os::CoreState::MapExecuting { vaddr, pte, .. } => {
Proof              | Code(Proo ProofDire Body(Proo  |                             overlap(candidate.frame, pte.frame)
Proof              | Code(Proo ProofDire Body(Proo  |                         },
Proof              | Code(Proo ProofDire Body(Proo  |                         os::CoreState::UnmapWaiting { ULT_id, vaddr } => {
Proof              | Code(Proo ProofDire Body(Proo  |                             &&& s.interp_pt_mem().dom().contains(vaddr)
Proof              | Code(Proo ProofDire Body(Proo  |                             &&& overlap(candidate.frame, s.interp_pt_mem().index(vaddr).frame)
Proof              | Code(Proo ProofDire Body(Proo  |                         },
Proof              | Code(Proo ProofDire Body(Proo  |                         os::CoreState::UnmapOpExecuting { ULT_id, vaddr, result, .. }
Proof              | Code(Proo ProofDire Body(Proo  |                         | os::CoreState::UnmapOpDone { ULT_id, vaddr, result, .. }
Proof              | Code(Proo ProofDire Body(Proo  |                         | os::CoreState::UnmapShootdownWaiting { ULT_id, vaddr, result, .. } => {
Proof              | Code(Proo ProofDire Body(Proo  |                             &&& result is Ok
Proof              | Code(Proo ProofDire Body(Proo  |                             &&& overlap(candidate.frame, result.get_Ok_0().frame)
Proof              | Code(Proo ProofDire Body(Proo  |                         },
Proof              | Code(Proo ProofDire Body(Proo  |                         os::CoreState::Idle => false,
Proof              | Code(Proo ProofDire Body(Proo  |                     }
Proof              | Code(Proo ProofDire Body(Proo  |                 };
Proof              | Code(Proo ProofDire Body(Proo  |             let core = choose|core| #[trigger]
Proof              | Code(Proo ProofDire Body(Proo  |                 s.core_states.dom().contains(core) && s.core_states[core] == corestate;
Proof              | Code(Proo ProofDire Body(Proo  |             assert(hardware::valid_core(c.hw, core));
Proof              | Code(Proo ProofDire Body(Proo  |             match corestate {
Proof              | Code(Proo ProofDire Body(Proo  |                 os::CoreState::MapWaiting { ULT_id, vaddr, pte, .. }
Proof              | Code(Proo ProofDire Body(Proo  |                 | os::CoreState::MapExecuting { ULT_id, vaddr, pte, .. } => {
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(c.valid_ULT(ULT_id));
Proof              | Code(Proo ProofDire Body(Proo  |                     let thread_state = s.interp_thread_state(c)[ULT_id];
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(s.interp(c).thread_state[ULT_id] == thread_state);
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(s.interp(c).thread_state.dom().contains(ULT_id));
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(s.interp(c).thread_state.values().contains(thread_state));
Proof              | Code(Proo ProofDire Body(Proo  |                     assert({
Proof              | Code(Proo ProofDire Body(Proo  |                         &&& thread_state matches hlspec::AbstractArguments::Map {
Proof              | Code(Proo ProofDire Body(Proo  |                             vaddr: v_address,
Proof              | Code(Proo ProofDire Body(Proo  |                             pte: p_te,
Proof              | Code(Proo ProofDire Body(Proo  |                         }
Proof              | Code(Proo ProofDire Body(Proo  |                         &&& v_address === vaddr
Proof              | Code(Proo ProofDire Body(Proo  |                         &&& p_te === pte
Proof              | Code(Proo ProofDire Body(Proo  |                         &&& overlap(candidate.frame, pte.frame)
Proof              | Code(Proo ProofDire Body(Proo  |                     });
Proof              | Code(Proo ProofDire Body(Proo  |                 },
Proof              | Code(Proo ProofDire Body(Proo  |                 os::CoreState::UnmapWaiting { ULT_id, vaddr } => {
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(c.valid_ULT(ULT_id));
Proof              | Code(Proo ProofDire Body(Proo  |                     let thread_state = s.interp_thread_state(c)[ULT_id];
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(s.interp(c).thread_state.dom().contains(ULT_id));
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(s.interp(c).thread_state.values().contains(thread_state));
Proof              | Code(Proo ProofDire Body(Proo  |                     assert({
Proof              | Code(Proo ProofDire Body(Proo  |                         &&& thread_state matches hlspec::AbstractArguments::Unmap {
Proof              | Code(Proo ProofDire Body(Proo  |                             vaddr: v_address,
Proof              | Code(Proo ProofDire Body(Proo  |                             pte: Some(pte),
Proof              | Code(Proo ProofDire Body(Proo  |                         }
Proof              | Code(Proo ProofDire Body(Proo  |                         &&& v_address === vaddr
Proof              | Code(Proo ProofDire Body(Proo  |                         &&& s.interp_pt_mem()[vaddr] === pte
Proof              | Code(Proo ProofDire Body(Proo  |                         &&& overlap(candidate.frame, s.interp_pt_mem().index(vaddr).frame)
Proof              | Code(Proo ProofDire Body(Proo  |                     });
Proof              | Code(Proo ProofDire Body(Proo  |                 },
Proof              | Code(Proo ProofDire Body(Proo  |                 os::CoreState::UnmapOpExecuting { ULT_id, vaddr, result, .. }
Proof              | Code(Proo ProofDire Body(Proo  |                 | os::CoreState::UnmapOpDone { ULT_id, vaddr, result, .. }
Proof              | Code(Proo ProofDire Body(Proo  |                 | os::CoreState::UnmapShootdownWaiting { ULT_id, vaddr, result, .. } => {
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(c.valid_ULT(ULT_id));
Proof              | Code(Proo ProofDire Body(Proo  |                     let thread_state = s.interp_thread_state(c)[ULT_id];
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(s.interp(c).thread_state.dom().contains(ULT_id));
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(s.interp(c).thread_state.values().contains(thread_state));
Proof              | Code(Proo ProofDire Body(Proo  |                     assert({
Proof              | Code(Proo ProofDire Body(Proo  |                         &&& thread_state matches hlspec::AbstractArguments::Unmap {
Proof              | Code(Proo ProofDire Body(Proo  |                             vaddr: v_address,
Proof              | Code(Proo ProofDire Body(Proo  |                             pte: pte,
Proof              | Code(Proo ProofDire Body(Proo  |                         }
Proof              | Code(Proo ProofDire Body(Proo  |                         &&& v_address === vaddr
Proof              | Code(Proo ProofDire Body(Proo  |                         &&& match result {
Proof              | Code(Proo ProofDire Body(Proo  |                             Ok(pte_) => pte is Some && pte_ == pte->0,
Proof              | Code(Proo ProofDire Body(Proo  |                             Err(_) => pte is None,
Proof              | Code(Proo ProofDire Body(Proo  |                         }
Proof              | Code(Proo ProofDire Body(Proo  |                         &&& overlap(candidate.frame, pte->0.frame)
Proof              | Code(Proo ProofDire Body(Proo  |                     });
Proof              | Code(Proo ProofDire Body(Proo  |                 },
Proof              | Code(Proo ProofDire Body(Proo  |                 _ => {},
Proof              | Code(Proo ProofDire Body(Proo  |             };
Proof              | Code(Proo ProofDire Body(Proo  |         } else {
Proof              | Code(Proo ProofDire Body(Proo  |         };
Proof              | Code(Proo ProofDire Body(Proo  |     };
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Proof              | Signature(Proof)               | pub proof fn lemma_candidate_mapping_inflight_pmem_overlap_hl_implies_os(
Proof              | Signature(Proof)               |     c: os::OSConstants,
Proof              | Signature(Proof)               |     s: os::OSVariables,
Proof              | Signature(Proof)               |     candidate: PageTableEntry,
Proof              | Signature(Proof)               | )
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         s.basic_inv(c),
Spec               | Signature(Proo FunctionSpec    |         above_zero(candidate.frame.size),
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         hlspec::candidate_mapping_overlaps_inflight_pmem(
Spec               | Signature(Proo FunctionSpec    |             s.interp(c).thread_state.values(),
Spec               | Signature(Proo FunctionSpec    |             candidate,
Spec               | Signature(Proo FunctionSpec    |         ) ==> os::candidate_mapping_overlaps_inflight_pmem(
Spec               | Signature(Proo FunctionSpec    |             s.interp_pt_mem(),
Spec               | Signature(Proo FunctionSpec    |             s.core_states.values(),
Spec               | Signature(Proo FunctionSpec    |             candidate,
Spec               | Signature(Proo FunctionSpec    |         ),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proo ProofDire Body(Proo  |     assert(hlspec::candidate_mapping_overlaps_inflight_pmem(
Proof              | Code(Proo ProofDire Body(Proo  |         s.interp(c).thread_state.values(),
Proof              | Code(Proo ProofDire Body(Proo  |         candidate,
Proof              | Code(Proo ProofDire Body(Proo  |     ) ==> os::candidate_mapping_overlaps_inflight_pmem(
Proof              | Code(Proo ProofDire Body(Proo  |         s.interp_pt_mem(),
Proof              | Code(Proo ProofDire Body(Proo  |         s.core_states.values(),
Proof              | Code(Proo ProofDire Body(Proo  |         candidate,
Proof              | Code(Proo ProofDire Body(Proo  |     )) by {
Proof              | Code(Proo ProofDire Body(Proo  |         if (hlspec::candidate_mapping_overlaps_inflight_pmem(
Proof              | Code(Proo ProofDire Body(Proo  |             s.interp(c).thread_state.values(),
Proof              | Code(Proo ProofDire Body(Proo  |             candidate,
Proof              | Code(Proo ProofDire Body(Proo  |         )) {
Proof              | Code(Proo ProofDire Body(Proo  |             let thread_state = choose|b|
Proof              | Code(Proo ProofDire Body(Proo  |                 {
Proof              | Code(Proo ProofDire Body(Proo  |                     &&& s.interp(c).thread_state.values().contains(b)
Proof              | Code(Proo ProofDire Body(Proo  |                     &&& match b {
Proof              | Code(Proo ProofDire Body(Proo  |                         hlspec::AbstractArguments::Map { vaddr, pte } => {
Proof              | Code(Proo ProofDire Body(Proo  |                             overlap(candidate.frame, pte.frame)
Proof              | Code(Proo ProofDire Body(Proo  |                         },
Proof              | Code(Proo ProofDire Body(Proo  |                         hlspec::AbstractArguments::Unmap { vaddr, pte } => {
Proof              | Code(Proo ProofDire Body(Proo  |                             &&& pte.is_some()
Proof              | Code(Proo ProofDire Body(Proo  |                             &&& overlap(candidate.frame, pte.unwrap().frame)
Proof              | Code(Proo ProofDire Body(Proo  |                         },
Proof              | Code(Proo ProofDire Body(Proo  |                         _ => { false },
Proof              | Code(Proo ProofDire Body(Proo  |                     }
Proof              | Code(Proo ProofDire Body(Proo  |                 };
Proof              | Code(Proo ProofDire Body(Proo  |             let ULT_id = choose|id| #[trigger]
Proof              | Code(Proo ProofDire Body(Proo  |                 c.valid_ULT(id) && s.interp(c).thread_state[id] == thread_state;
Proof              | Code(Proo ProofDire Body(Proo  |             assert(c.valid_ULT(ULT_id));
Proof              | Code(Proo ProofDire Body(Proo  |             let core = c.ULT2core[ULT_id];
Proof              | Code(Proo ProofDire Body(Proo  |             assert(hardware::valid_core(c.hw, core));
Proof              | Code(Proo ProofDire Body(Proo  |             assert(s.core_states.dom().contains(core));
Proof              | Code(Proo ProofDire Body(Proo  |             let core_state = s.core_states[core];
Proof              | Code(Proo ProofDire Body(Proo  |             assert(s.core_states.values().contains(core_state));
Proof              | Code(Proo ProofDire Body(Proo  |             match core_state {
Proof              | Code(Proo ProofDire Body(Proo  |                 os::CoreState::MapWaiting { ULT_id: ult_id, vaddr, pte, .. }
Proof              | Code(Proo ProofDire Body(Proo  |                 | os::CoreState::MapExecuting { ULT_id: ult_id, vaddr, pte, .. } => {
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(ult_id == ULT_id);
Comment            | Comment                        |                   //  assert(above_zero(pte.frame.size));
Proof              | Code(Proo ProofDire Body(Proo  |                     assert({
Proof              | Code(Proo ProofDire Body(Proo  |                         &&& thread_state matches hlspec::AbstractArguments::Map {
Proof              | Code(Proo ProofDire Body(Proo  |                             vaddr: v_addr,
Proof              | Code(Proo ProofDire Body(Proo  |                             pte: entry,
Proof              | Code(Proo ProofDire Body(Proo  |                         }
Proof              | Code(Proo ProofDire Body(Proo  |                         &&& vaddr === v_addr
Proof              | Code(Proo ProofDire Body(Proo  |                         &&& entry === pte
Proof              | Code(Proo ProofDire Body(Proo  |                     });
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(overlap(candidate.frame, pte.frame));
Proof              | Code(Proo ProofDire Body(Proo  |                 },
Proof              | Code(Proo ProofDire Body(Proo  |                 os::CoreState::UnmapWaiting { ULT_id: ult_id, vaddr } => {
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(s.interp_pt_mem().dom().contains(vaddr));
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(ult_id == ULT_id);
Proof              | Code(Proo ProofDire Body(Proo  |                     let pte = s.interp_pt_mem()[vaddr];
Comment            | Comment                        |                    // assert(above_zero(pte.frame.size));
Proof              | Code(Proo ProofDire Body(Proo  |                     assert({
Proof              | Code(Proo ProofDire Body(Proo  |                         &&& thread_state matches hlspec::AbstractArguments::Unmap {
Proof              | Code(Proo ProofDire Body(Proo  |                             vaddr: v_addr,
Proof              | Code(Proo ProofDire Body(Proo  |                             pte: Some(entry),
Proof              | Code(Proo ProofDire Body(Proo  |                         }
Proof              | Code(Proo ProofDire Body(Proo  |                         &&& vaddr === v_addr
Proof              | Code(Proo ProofDire Body(Proo  |                         &&& entry === pte
Proof              | Code(Proo ProofDire Body(Proo  |                     });
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(overlap(candidate.frame, s.interp_pt_mem().index(vaddr).frame));
Proof              | Code(Proo ProofDire Body(Proo  |                 },
Proof              | Code(Proo ProofDire Body(Proo  |                 os::CoreState::UnmapOpExecuting { ULT_id: ult_id, vaddr, result, .. }
Proof              | Code(Proo ProofDire Body(Proo  |                 | os::CoreState::UnmapOpDone { ULT_id: ult_id, vaddr, result, .. }
Proof              | Code(Proo ProofDire Body(Proo  |                 | os::CoreState::UnmapShootdownWaiting { ULT_id: ult_id, vaddr, result, .. } => {
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(ult_id == ULT_id);
Comment            | Comment                        |                  //   assert(above_zero(result.get_Ok_0().frame.size));
Proof              | Code(Proo ProofDire Body(Proo  |                     assert({
Proof              | Code(Proo ProofDire Body(Proo  |                         &&& thread_state matches hlspec::AbstractArguments::Unmap {
Proof              | Code(Proo ProofDire Body(Proo  |                             vaddr: v_addr,
Proof              | Code(Proo ProofDire Body(Proo  |                             pte,
Proof              | Code(Proo ProofDire Body(Proo  |                         }
Proof              | Code(Proo ProofDire Body(Proo  |                         &&& vaddr === v_addr
Proof              | Code(Proo ProofDire Body(Proo  |                         &&& match result {
Proof              | Code(Proo ProofDire Body(Proo  |                             Ok(pte_) => pte is Some && pte_ == pte->0,
Proof              | Code(Proo ProofDire Body(Proo  |                             Err(_) => pte is None,
Proof              | Code(Proo ProofDire Body(Proo  |                         }
Proof              | Code(Proo ProofDire Body(Proo  |                     });
Proof              | Code(Proo ProofDire Body(Proo  |                     assert(overlap(candidate.frame, result.get_Ok_0().frame));
Proof              | Code(Proo ProofDire Body(Proo  |                 },
Proof              | Code(Proo ProofDire Body(Proo  |                 _ => {},
Proof              | Code(Proo ProofDire Body(Proo  |             };
Proof              | Code(Proo ProofDire Body(Proo  |         } else {
Proof              | Code(Proo ProofDire Body(Proo  |         }
Proof              | Code(Proo ProofDire Body(Proo  |     };
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
                   |                                | } // verus!

# extra.rs
                   |                                | use vstd::prelude::*;
                   |                                | use crate::definitions_t::aligned;
                   |                                | use vstd::map::*;
                   |                                | 
                   |                                | 
                   |                                | verus! {
                   |                                | 
Proof              | Signature(Proof)               | pub proof fn mod_add_zero(a: nat, b: nat, c: nat)
Spec               | Signature(Proo FunctionSpec    |     requires aligned(a, c), aligned(b, c), c > 0
Spec               | Signature(Proo FunctionSpec    |     ensures aligned(a + b, c)
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proof) Body(Proof)        |     vstd::arithmetic::div_mod::lemma_add_mod_noop(a as int, b as int, c as int);
Proof              | Code(Proo ProofDire Body(Proo  |     assert(0nat % c == (a + b) % c);
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Proof              | Signature(Proof)               | pub proof fn mod_mult_zero_implies_mod_zero(a: nat, b: nat, c: nat) by (nonlinear_arith)
Spec               | Signature(Proo FunctionSpec    |     requires aligned(a, b * c), b > 0, c > 0
Spec               | Signature(Proo FunctionSpec    |     ensures aligned(a, b)
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proof) Body(Proof)        |     broadcast use vstd::arithmetic::div_mod::lemma_mod_mod, vstd::arithmetic::div_mod::lemma_mod_breakdown;
Proof              | Code(Proo ProofDire Body(Proo  |     assert((a % (b * c)) % b == 0);
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Proof              | Signature(Proof)               | pub proof fn subtract_mod_eq_zero(a: nat, b: nat, c: nat)
Spec               | Signature(Proo FunctionSpec    |     requires aligned(a, c), aligned(b, c), a <= b, c > 0
Spec               | Signature(Proo FunctionSpec    |     ensures aligned((b - a) as nat, c)
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proof) Body(Proof)        |     let a = a as int; let b = b as int; let c = c as int;
Proof              | Code(Proof) Body(Proof)        |     vstd::arithmetic::div_mod::lemma_sub_mod_noop(b, a, c);
Proof              | Code(Proo ProofDire Body(Proo  |     assert(((b % c) - (a % c)) % c == (b - a) % c);
Proof              | Code(Proo ProofDire Body(Proo  |     assert(0int % c == (b - a) % c);
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Proof              | Signature(Proof)               | pub proof fn leq_add_aligned_less(a: nat, b: nat, c: nat) by (nonlinear_arith)
Spec               | Signature(Proo FunctionSpec    |     requires 0 < b, a < c, aligned(a, b), aligned(c, b),
Spec               | Signature(Proo FunctionSpec    |     ensures a + b <= c,
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proo ProofDire Body(Proo  |     assert(a == b * (a / b) + a % b);
Proof              | Code(Proo ProofDire Body(Proo  |     assert(c == b * (c / b) + c % b);
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Proof              | Signature(Proof)               | pub proof fn aligned_transitive_auto()
Spec               | Signature(Proo FunctionSpec    |     ensures forall|a: nat, b: nat, c: nat| 0 < b && 0 < c && aligned(a, b) && aligned(b, c) ==> aligned(a, c),
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proo ProofDire Body(Proo  |     assert forall|a: nat, b: nat, c: nat| 0 < b && 0 < c && aligned(a, b) && aligned(b, c) implies aligned(a, c) by {
Proof              | Code(Proo ProofDire Body(Proo  |         aligned_transitive(a, b, c);
Proof              | Code(Proo ProofDire Body(Proo  |     }
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Proof              | Signature(Proof)               | pub proof fn lemma_subset_is_finite<A>(
Proof              | Signature(Proof)               |     a: Set<A>,
Proof              | Signature(Proof)               |     b: Set<A>,
Proof              | Signature(Proof)               | )
Spec               | Signature(Proo FunctionSpec    |     requires 
Spec               | Signature(Proo FunctionSpec    |         a.finite(),
Spec               | Signature(Proo FunctionSpec    |         b.subset_of(a),
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         b.finite(),
Proof              | Code(Proof) Body(Proof)        | {   let c = a.difference(b);   
Proof              | Code(Proo ProofDire Body(Proo  |     assert (a.difference(c).finite());
Proof              | Code(Proo ProofDire Body(Proo  |     assert (a.difference(c) === b);
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Proof              | Signature(Proof)               | pub proof fn lemma_set_of_first_n_nat_is_finite( n: nat, )
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |     ensures Set::new(|i: nat| i < n).finite()
Spec               | Signature(Proo FunctionSpec    |     decreases n
Proof              | Code(Proof) Body(Proof)        | {   
Proof              | Code(Proof) Body(Proof)        |     let b = Set::new(|i: nat| i < n);
Proof              | Code(Proof) Body(Proof)        |     if (n == 0) {    
Proof              | Code(Proo ProofDire Body(Proo  |         assert(Set::new(|i: nat| i < 0) === Set::empty());
Proof              | Code(Proo ProofDire Body(Proo  |         assert(Set::new(|i: nat| i < 0).finite());
Proof              | Code(Proof) Body(Proof)        |     } else {
Proof              | Code(Proof) Body(Proof)        |         lemma_set_of_first_n_nat_is_finite((n - 1) as nat);
Proof              | Code(Proof) Body(Proof)        |         let c = Set::new(|i: nat| i < n - 1).insert((n - 1) as nat);
Proof              | Code(Proo ProofDire Body(Proo  |         assert(c.finite());
Proof              | Code(Proo ProofDire Body(Proo  |         assert(c === b);
Proof              | Code(Proo ProofDire Body(Proo  |         assert(b.finite());
Proof              | Code(Proof) Body(Proof)        |     }
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Proof              | Signature(Proof)               | pub proof fn lemma_aligned_iff_eq_mul_div(a: nat, b: nat)
Spec               | Signature(Proo FunctionSpec    |     requires b > 0
Spec               | Signature(Proo FunctionSpec    |     ensures aligned(a, b) <==> a == b * (a / b)
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proo ProofDire Body(Proo  |     assert(a % b == 0 ==> a == b * (a / b)) by (nonlinear_arith)
Proof              | Code(Proo ProofDire Body(Proo  |         requires b > 0;
Proof              | Code(Proo ProofDire Body(Proo  |     assert(a == b * (a / b) ==> a % b == 0) by (nonlinear_arith)
Proof              | Code(Proo ProofDire Body(Proo  |         requires b > 0;
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Proof              | Signature(Proof)               | pub proof fn aligned_transitive(a: nat, b: nat, c: nat)
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         0 < b,
Spec               | Signature(Proo FunctionSpec    |         0 < c,
Spec               | Signature(Proo FunctionSpec    |         aligned(a, b),
Spec               | Signature(Proo FunctionSpec    |         aligned(b, c),
Spec               | Signature(Proo FunctionSpec    |     ensures aligned(a, c)
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proof) Body(Proof)        |     lemma_aligned_iff_eq_mul_div(a, b);
Proof              | Code(Proof) Body(Proof)        |     lemma_aligned_iff_eq_mul_div(b, c);
Proof              | Code(Proof) Body(Proof)        |     lemma_aligned_iff_eq_mul_div(a, c);
Proof              | Code(Proof) Body(Proof)        |     let i = a / b; let j = b / c;
Proof              | Code(Proo ProofDire Body(Proo  |     assert((c * j) * i == c * (j * i)) by (nonlinear_arith);
Proof              | Code(Proo ProofDire Body(Proo  |     assert(a / c == j * i) by (nonlinear_arith)
Proof              | Code(Proo ProofDire Body(Proo  |         requires 0 < c, a == c * (j * i);
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Directives         | Directive                      | #[verifier(nonlinear)]
Proof              | Code(Proo Signature Body(Proo  | pub proof fn mod_less_eq(a: nat, b: nat) {
Proof              | Code(Proof) Body(Proof)        |     requires(b != 0);
Proof              | Code(Proof) Body(Proof)        |     ensures(a % b <= a);
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Directives         | Directive                      | #[verifier(nonlinear)]
Proof              | Signature(Proof)               | pub proof fn aligned_zero()
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         forall|a:nat| a != 0 ==> aligned(0, a)
Proof              | Code(Proof) Body(Proof)        | { }
                   |                                | 
Directives         | Directive                      | #[verifier(nonlinear)]
Proof              | Code(Proo Signature Body(Proo  | pub proof fn mul_distributive(a: nat, b: nat) {
Proof              | Code(Proof) Body(Proof)        |     ensures((a + 1) * b == a * b + b);
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Directives         | Directive                      | #[verifier(nonlinear)]
Proof              | Code(Proo Signature Body(Proo  | pub proof fn mul_commute(a: nat, b: nat) {
Proof              | Code(Proof) Body(Proof)        |     ensures(a * b == b * a);
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Directives         | Directive                      | #[verifier(nonlinear)]
Proof              | Code(Proo Signature Body(Proo  | pub proof fn div_mul_cancel(a: nat, b: nat) {
Proof              | Code(Proof) Body(Proof)        |     requires([
Proof              | Code(Proof) Body(Proof)        |              aligned(a, b),
Proof              | Code(Proof) Body(Proof)        |              b != 0
Proof              | Code(Proof) Body(Proof)        |     ]);
Proof              | Code(Proof) Body(Proof)        |     ensures(a / b * b == a);
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Directives         | Directive                      | #[verifier(nonlinear)]
Proof              | Code(Proo Signature Body(Proo  | pub proof fn less_mul_cancel(a: nat, b: nat, c: nat) {
Proof              | Code(Proof) Body(Proof)        |     requires(a * c < b * c);
Proof              | Code(Proof) Body(Proof)        |     ensures(a < b);
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Directives         | Directive                      | #[verifier(nonlinear)]
Proof              | Code(Proo Signature Body(Proo  | pub proof fn mult_leq_mono1(a: nat, b: nat, c: nat) {
Proof              | Code(Proof) Body(Proof)        |     requires(a <= b);
Proof              | Code(Proof) Body(Proof)        |     ensures(a * c <= b * c);
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Directives         | Directive                      | #[verifier(nonlinear)]
Proof              | Code(Proo Signature Body(Proo  | pub proof fn mult_leq_mono2(a: nat, b: nat, c: nat) {
Proof              | Code(Proof) Body(Proof)        |     requires(a <= b);
Proof              | Code(Proof) Body(Proof)        |     ensures(c * a <= c * a);
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Directives         | Directive                      | #[verifier(nonlinear)]
Proof              | Signature(Proof)               | pub proof fn mult_leq_mono_both(a: nat, b: nat, c: nat, d: nat)
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         a <= c,
Spec               | Signature(Proo FunctionSpec    |         b <= d,
Spec               | Signature(Proo FunctionSpec    |     ensures
Comment            | Comment                        |         // Including `0 <=` here because it's used in a place where this is part of an overflow VC
Comment            | Comment                        |         // and non-nonlinear z3 can't even deal with that.
Proof              | Code(P Signat Functi Body(P    |         0 <= a * b <= c * d;
                   |                                | 
Directives         | Directive                      | #[verifier(nonlinear)]
Proof              | Signature(Proof)               | pub proof fn mult_less_mono_both1(a: nat, b: nat, c: nat, d: nat)
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         a < c,
Spec               | Signature(Proo FunctionSpec    |         b <= d,
Spec               | Signature(Proo FunctionSpec    |         0 < c,
Spec               | Signature(Proo FunctionSpec    |         0 < d,
Spec               | Signature(Proo FunctionSpec    |     ensures
Proof              | Code(P Signat Functi Body(P    |         a * b < c * d;
                   |                                | 
Directives         | Directive                      | #[verifier(nonlinear)]
Proof              | Signature(Proof)               | pub proof fn mult_less_mono_both2(a: nat, b: nat, c: nat, d: nat)
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         a <= c,
Spec               | Signature(Proo FunctionSpec    |         b < d,
Spec               | Signature(Proo FunctionSpec    |         0 < c,
Spec               | Signature(Proo FunctionSpec    |         0 < d,
Spec               | Signature(Proo FunctionSpec    |     ensures
Proof              | Code(P Signat Functi Body(P    |         a * b < c * d;
                   |                                | 
                   |                                | 
Proof              | Signature(Proof)               | pub proof fn assert_maps_equal_contains_pair<K,V>(m1: Map<K,V>, m2: Map<K,V>)
Spec               | Signature(Proo FunctionSpec    |     requires
Spec               | Signature(Proo FunctionSpec    |         forall|k:K,v:V| m1.contains_pair(k, v) ==> m2.contains_pair(k, v),
Spec               | Signature(Proo FunctionSpec    |         forall|k:K,v:V| m2.contains_pair(k, v) ==> m1.contains_pair(k, v),
Spec               | Signature(Proo FunctionSpec    |     ensures
Spec               | Signature(Proo FunctionSpec    |         m1 === m2
Proof              | Code(Proof) Body(Proof)        | {
Proof              | Code(Proo ProofDire Body(Proo  |     assert forall|k|
Proof              | Code(Proo ProofDire Body(Proo  |         m1.dom().contains(k)
Proof              | Code(Proo ProofDire Body(Proo  |         implies m2.dom().contains(k) by
Proof              | Code(Proo ProofDire Body(Proo  |     { assert(m2.contains_pair(k, m1.index(k))); };
Proof              | Code(Proo ProofDire Body(Proo  |     assert forall|k|
Proof              | Code(Proo ProofDire Body(Proo  |         m2.dom().contains(k)
Proof              | Code(Proo ProofDire Body(Proo  |         implies m1.dom().contains(k) by
Proof              | Code(Proo ProofDire Body(Proo  |     { assert(m1.contains_pair(k, m2.index(k))); };
Proof              | Code(Proo ProofDire Body(Proo  |     assert forall|k|
Proof              | Code(Proo ProofDire Body(Proo  |         m1.dom().contains(k) && m2.dom().contains(k)
Proof              | Code(Proo ProofDire Body(Proo  |         implies #[trigger] m2.index(k) === #[trigger] m1.index(k) by
Proof              | Code(Proo ProofDire Body(Proo  |     {
Proof              | Code(Proo ProofDire Body(Proo  |         let v = m1.index(k);
Proof              | Code(Proo ProofDire Body(Proo  |         assert(m1.contains_pair(k, v));
Proof              | Code(Proo ProofDire Body(Proo  |         assert(m2.contains_pair(k, v));
Proof              | Code(Proo ProofDire Body(Proo  |     };
Proof              | Code(Proof) Body(Proof)        |     assert_maps_equal!(m1, m2);
Proof              | Code(Proof) Body(Proof)        | }
                   |                                | 
Comment            | Comment                        | // FIXME: Something like these functions should probably be added to vstd. One problem with that:
Comment            | Comment                        | // May want exec versions of the functions but can't give them the same name.
Spec               | Code(Spec Signature Body(Spec  | pub open spec(checked) fn result_map_ok<A,B,C>(res: Result<A,B>, f: spec_fn(A) -> C) -> Result<C,B> {
Spec               | Code(Spec) Body(Spec)          |     match res {
Spec               | Code(Spec) Body(Spec)          |         Ok(a)  => Ok(f(a)),
Spec               | Code(Spec) Body(Spec)          |         Err(b) => Err(b),
Spec               | Code(Spec) Body(Spec)          |     }
Spec               | Code(Spec) Body(Spec)          | }
                   |                                | 
Spec               | Code(Spec Signature Body(Spec  | pub open spec(checked) fn result_map<A,B>(res: Result<A,A>, f: spec_fn(A) -> B) -> Result<B,B> {
Spec               | Code(Spec) Body(Spec)          |     match res {
Spec               | Code(Spec) Body(Spec)          |         Ok(a)  => Ok(f(a)),
Spec               | Code(Spec) Body(Spec)          |         Err(a) => Err(f(a)),
Spec               | Code(Spec) Body(Spec)          |     }
Spec               | Code(Spec) Body(Spec)          | }
                   |                                | 
                   |                                | }

